<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>0.风变编程-Python基础</title>
    <url>/2020/01/20/0.python%E5%9F%BA%E7%A1%80%EF%BC%88%E9%A3%8E%E5%8F%98%E7%BC%96%E7%A8%8B%EF%BC%89/</url>
    <content><![CDATA[<p> <a href="https://github.com/Ryanhuo/Notebook/blob/master/3.%20python%E5%9F%BA%E7%A1%80/%E9%99%84%E4%BB%B6/0.%E9%A3%8E%E5%8F%98%E7%BC%96%E7%A8%8B-Python%E5%9F%BA%E7%A1%80%EF%BC%88%E6%95%B4%E7%90%86%E7%89%88%EF%BC%89.pdf" target="_blank" rel="noopener">0.风变编程-Python基础</a> </p>
]]></content>
      <categories>
        <category>data analytics</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>1. python简介及安装</title>
    <url>/2020/01/20/1.%20python%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="python简介"><a href="#python简介" class="headerlink" title="python简介"></a>python简介</h2><p><strong>编程语言</strong>是用来定义 计算机程序 的形式语言。我们通过编程语言来编写程序代码，再通过语言处理程序执行向计算机发送指令，让计算机完成对应的工作。</p>
<p>Python也是编程语言的一种,并且是高级的编程语言。Python语言可能是第一种即简单又功能强大的编程语言。</p>
<a id="more"></a>

<h2 id="python的优点"><a href="#python的优点" class="headerlink" title="python的优点"></a>python的优点</h2><ol>
<li><strong>简单</strong>：Python是一种代表简单主义思想的语言。阅读一个良好的Python程序就感觉像是在读英语一样，尽管这个英语的要求非常严格！Python的这种伪代码本质是它最大的优点之一。它使你能够专注于解决问题而不是去搞明白语言本身。</li>
</ol>
<ol start="2">
<li><strong>易学</strong>：就如同你即将看到的一样，Python极其容易上手。前面已经提到了，Python有极其简单的语法。</li>
</ol>
<ol start="3">
<li><p><strong>免费、开源</strong>：Python是FLOSS（自由/开放源码软件）之一。简单地说，你可以自由地发布这个软件的拷贝、阅读它的源代码、对它做改动、把它的一部分用于新的自由软件中。FLOSS是基于一个团体分享知识的概念。这是为什什么Python如此优秀的原因之一—它是由一群希望看到一个更更加优秀的Python的人创造并经常改进着的。</p>
</li>
<li><p><strong>层语言</strong>：当你用Python语言编写程序的时候，你无需考虑诸如如何管理理你的程序使用的内存一类的底层细节。</p>
</li>
<li><p><strong>可移植性</strong>：由于它的开源本质，Python已经被移植在许多平台上（经过改动使它能够工作在不不同平台上）。如果你小心地避免使用依赖于系统的特性，那么你的所有Python程无需修改就可以在下述任何平台上面运行。这些平台包括Linux、Windows、FreeBSD、Macintosh、Solaris、OS/2、Amiga、AROS、AS/400、BeOS、OS/390、z/OS、Palm OS、QNX、VMS、Psion、Acom RISC OS、VxWorks、PlayStation、Sharp Zaurus、Windows CE甚至还有PocketPC、Symbian以及Google基于linux开发的Android平台！</p>
</li>
<li><p><strong>解释性</strong>：这一点需要一些解释。一个用编译性语言比如C或C++写的程序可以从源文件（即C或C++语言）转换到一个你的计算机使用的语言（二进制代码，即0和1）。这个过程通过编译器和不同的标记、选项完成。当你运行你的程序的时候，连接/转载器软件把你的程序从硬盘复制到内存中并且运行。而Python语言写的程序不不需要编译成二进制代码。你可以直接从源代码运行程序。在计算机内部，Python解释器把源代码转换成称为字节码的中间形式，然后再把它翻译成计算机使用的机器器语言并运行。事实上，由于你不再需要担心如何编译程序，如何确保连接转载正确的库等等，所有这一切使得使用Python更更加简单。由于你只需要把你的Python程序拷贝到另外一台计算机上，它就可以工作了，这也使得你的Python程序更加易于移植。</p>
</li>
<li><p><strong>面向对象</strong>：Python既支持面向过程的编程也支持面向对象的编程。在“面向过程”的语言中，程序是由过程或仅仅是可重用代码的函数构建起来的。在“面向对象”的语言中，程序是由数据和功能组合而成的对象构建起来的。与其他主要的语言如C++和Java相比，Python以一种非常强大又简单的方式实现面向对象编程。</p>
</li>
<li><p><strong>可扩展性</strong>：如果你需要你的一段关键代码运行得更快或者希望某些算法不不公开，你可以把你的部分程序用C或C++编写，然后在你的Python程序中使用它们。</p>
</li>
<li><p><strong>丰富的库</strong>：Python标准库确实很庞大。它可以帮助你处理理各种工作，包括正则表达式、文档生成、单元测试、线程、数据库、网页浏览器、CGI、FTP、电子邮件、XML、XML-RPC、HTML、WAV文件、密码系统、GUI（图形用户界面）、Tk和其他与系统有关的操作。记住，只要安装了Python，所有这些功能都是可用的。这被称作Python的“功能齐全”理念。除了标准库以外，还有许多其他高质量的库，如wxPython、Twisted和Python图像库等等。</p>
</li>
<li><p><strong>规范的代码</strong>：Python采用强制缩进的方式使得代码具有极佳的可读性。</p>
</li>
</ol>
<h2 id="pycharm安装激活"><a href="#pycharm安装激活" class="headerlink" title="pycharm安装激活"></a>pycharm安装激活</h2><p>PyCharm是一 Python IDE，带有一 整套可以帮助用户在使用Python语言开发时提高其效率的工具，比如调试、语法高亮、Project管理、 代码跳转、智能提示、自动完成、单元测试、版本控制。此外，该IDE提供了-些高级功能，以用于支持Django框架下的专业Web开发。</p>
<h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><p><a href="https://www.jetbrains.com/pycharm/" target="_blank" rel="noopener">官方下载地址</a></p>
<h3 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h3><p>激活方式均选择License server。</p>
<p><img src="/2020/01/20/1.%20python%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%AE%89%E8%A3%85/1.0.jpg" alt></p>
<p>第一服务器License server address: <a href="http://39.105.114.41:1027" target="_blank" rel="noopener">http://39.105.114.41:1027</a></p>
<p>第二服务器License server address: <a href="http://36.110.99.11:3456" target="_blank" rel="noopener">http://36.110.99.11:3456</a></p>
<p>以上两台服务器任选一台。</p>
<h2 id="使用Anconda方式安装Python环境"><a href="#使用Anconda方式安装Python环境" class="headerlink" title="使用Anconda方式安装Python环境"></a>使用Anconda方式安装Python环境</h2><p>Anaconda指的是一个开源的Python发行版本，其包含了conda、Python等180多个科学包及其依赖项。 因为包含了大量的科学包，Anaconda 的下载文件比较大（约 600 MB），如果只需要某些包，或者需要节省带宽或存储空间，也可以使用Miniconda这个较小的发行版（仅包含conda和 Python）。</p>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p><a href="https://www.continuum.io/downloads" target="_blank" rel="noopener">Python3.6版本</a></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>根据安装步骤下一步安装完成即可</p>
<p>anaconda自带python3.6环境不需要自己再次去官网下载python了。</p>
<h4 id="注意：-Windows如果忘记勾选添加环境变量选项需要可以进行一下操作"><a href="#注意：-Windows如果忘记勾选添加环境变量选项需要可以进行一下操作" class="headerlink" title="注意： Windows如果忘记勾选添加环境变量选项需要可以进行一下操作"></a>注意： Windows如果忘记勾选添加环境变量选项需要可以进行一下操作</h4><p><img src="/2020/01/20/1.%20python%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%AE%89%E8%A3%85/1.1.png" alt><br><img src="/2020/01/20/1.%20python%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%AE%89%E8%A3%85/1.2.png" alt><br><img src="/2020/01/20/1.%20python%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%AE%89%E8%A3%85/1.3.png" alt></p>
<h4 id="注意：-Mac-添加环境变量"><a href="#注意：-Mac-添加环境变量" class="headerlink" title="注意： Mac 添加环境变量"></a>注意： Mac 添加环境变量</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PATH&#x3D;&quot;~&#x2F;anaconda3&#x2F;bin:$PATH&quot;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim~&#x2F;.bash_profile</span><br></pre></td></tr></table></figure>



<p>点进入编辑模式，进行编辑然后添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PATH&#x3D;&quot;~&#x2F;anaconda3&#x2F;bin:$PATH&quot;</span><br></pre></td></tr></table></figure>

<p>编辑完成后，点esc 退出</p>
<p>直接输入 ：:wq! 这四个字符后，回车即可保存。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="界面介绍"><a href="#界面介绍" class="headerlink" title="界面介绍"></a>界面介绍</h4><p><img src="/2020/01/20/1.%20python%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%AE%89%E8%A3%85/1.4.png" alt></p>
<h4 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h4><p><img src="/2020/01/20/1.%20python%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%AE%89%E8%A3%85/1.5.png" alt></p>
<h4 id="添加快捷键"><a href="#添加快捷键" class="headerlink" title="添加快捷键"></a>添加快捷键</h4><p><img src="/2020/01/20/1.%20python%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%AE%89%E8%A3%85/1.6.png" alt></p>
<h2 id="创建jupyter虚拟环境"><a href="#创建jupyter虚拟环境" class="headerlink" title="创建jupyter虚拟环境"></a>创建jupyter虚拟环境</h2><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><h4 id="conda关于环境的几个常用命令"><a href="#conda关于环境的几个常用命令" class="headerlink" title="conda关于环境的几个常用命令"></a>conda关于环境的几个常用命令</h4><p>anaconda国内下载源：<a href="https://repo.continuum.io/archive/" target="_blank" rel="noopener">https://repo.continuum.io/archive/</a></p>
<p>查看当前的环境列列表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ conda env list</span><br><span class="line"></span><br><span class="line">创建新的python环境，并且还可以指定python的版本</span><br><span class="line"></span><br><span class="line">$ conda create -n myenv python&#x3D;3.7 激活、进入某个环境： $ activate test 退出环境： $ deactivate</span><br><span class="line"></span><br><span class="line">删除环境： $ conda remove --name test --all</span><br></pre></td></tr></table></figure>

<h4 id="创建想要添加的虚拟环境"><a href="#创建想要添加的虚拟环境" class="headerlink" title="创建想要添加的虚拟环境"></a>创建想要添加的虚拟环境</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda create -n myenv python&#x3D;3.5</span><br></pre></td></tr></table></figure>

<p>创建好以后可以在C:\ProgramData\Anaconda3\envs\（具体与自己安装的anaconda路路径为准）  下找到新创建的环境</p>
<h4 id="将新的环境添加到jupyter中"><a href="#将新的环境添加到jupyter中" class="headerlink" title="将新的环境添加到jupyter中"></a>将新的环境添加到jupyter中</h4><p>第一：首先到C:\ProgramData\Anaconda3\share\jupyter\kernels 文件夹下，会有一个自带的Python3文件夹；</p>
<p>第二：然后在Python3  文件夹同级目录下创建一个文件夹test文件夹（名字自己随便取，记得是英文）；</p>
<p>第三：将Python3文件夹下的kernel.json文件复制到test文件夹下； </p>
<p>第四：用记事本打开后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123; &quot;argv&quot;: [ &quot;C:\\ProgramData\\Anaconda3\\python.exe&quot;, &quot;-m&quot;, &quot;ipykernel_launcher&quot;, &quot;-f&quot;, &quot;</span><br><span class="line">&#123;connection_ﬁle&#125;&quot; ], &quot;display_name&quot;: &quot;Python 3&quot;, &quot;language&quot;: &quot;python&quot; &#125;</span><br></pre></td></tr></table></figure>

<p>将路径改成新创建的环境路路径，然后Python 3改成jupyter中想显示的名字。</p>
<p>第五：重启jupyter-notebook,选择新建会出现你想要的环境。</p>
<h4 id="安装ipykernel库"><a href="#安装ipykernel库" class="headerlink" title="安装ipykernel库"></a>安装ipykernel库</h4><p>第一： activate myenv 激活你的虚拟环境</p>
<p>第二： conda install ipykernel , 中间会出现&lt;[y]/n&gt;? 在后面直接输入y,回车。</p>
<h4 id="重启jupyter即可"><a href="#重启jupyter即可" class="headerlink" title="重启jupyter即可"></a>重启jupyter即可</h4><h3 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h3><h4 id="mac中激活和退出某个环境的命令"><a href="#mac中激活和退出某个环境的命令" class="headerlink" title="mac中激活和退出某个环境的命令"></a>mac中激活和退出某个环境的命令</h4><p>激活、进入某个环境：<br>$ source activate test</p>
<p>注意： 最新的anaconda 命令改成了conda activate test<br>退出环境： $ source deactivate</p>
<p>注意： 最新的anaconda 命令改成了conda deactivate</p>
<h4 id="创建想要添加的虚拟环境-1"><a href="#创建想要添加的虚拟环境-1" class="headerlink" title="创建想要添加的虚拟环境"></a>创建想要添加的虚拟环境</h4><p>$ conda create -n myenv python=3.5</p>
<h4 id="查找kernel-json文件"><a href="#查找kernel-json文件" class="headerlink" title="查找kernel.json文件"></a>查找kernel.json文件</h4><p>$ ﬁnd . -name “kernel.json”</p>
<p>第一：然后在 ./Library/Jupyter/kernels/ 目录下<strong>手动创建一个文件夹</strong>，然后创建一个名为 kernel.json 的文件，让该文件和已有的虚拟环境相关联，即可使用该虚拟环境。该json文件的内容大概如此：/Users/mac/Library/Jupyter/kernels/python37</p>
<p>{ “display_name”: “py35”, “language”: “python”, “argv”: [ “/Users/mac/Library/Jupyter/kernels/python37/bin/python”, “-m”, “ipykernel_launcher”, “-f”, “{connection_ﬁle}” ] }</p>
<p>第二： 重启jupyter，就会出现新的环境</p>
<p>注意： 上面操作完成之后，会提示/Users/mac/anaconda3/envs/python37/bin/python3.7: No module named ipykernel_launcher</p>
<p>第三：激活虚拟环境，然后conda install ipykernel</p>
<p>第四： 重启</p>
<h2 id="Anaconda安装拓拓展"><a href="#Anaconda安装拓拓展" class="headerlink" title="Anaconda安装拓拓展"></a>Anaconda安装拓拓展</h2><p>第一： 终端输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pip install jupyter_contrib_nbextensions</span><br><span class="line">$ pip install jupyter_nbextensions_conﬁgurator</span><br><span class="line">$ jupyter contrib nbextension install --user</span><br></pre></td></tr></table></figure>

<p>第二： 重启jupyter</p>
<p><a href="https://jupyter-contrib-nbextensions.readthedocs.io/en/latest/nbextensions/code_prettify/README_code_prettify.html" target="_blank" rel="noopener">关 于 插 件 的 介 绍 </a></p>
<p>例如： Hinterland 代码提示</p>
<h2 id="jupyter汉化问题"><a href="#jupyter汉化问题" class="headerlink" title="jupyter汉化问题"></a>jupyter汉化问题</h2><h3 id="Mac-1"><a href="#Mac-1" class="headerlink" title="Mac"></a>Mac</h3><p>jupyter在浏览器器的显示语言是根据终端语言自适应的，如果你的终端是中文，那么启动jupyter后，浏览器器就以中文显示</p>
<ol>
<li>终端是中文状态，jupyter是中文</li>
</ol>
<p><img src="/2020/01/20/1.%20python%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%AE%89%E8%A3%85/1.7.png" alt></p>
<ol start="2">
<li>如果想显示英文，有两种方式可以设置</li>
</ol>
<h4 id="一种是临时的"><a href="#一种是临时的" class="headerlink" title="一种是临时的"></a>一种是临时的</h4><p>终端中依次输入以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export LC_ALL&#x3D;en_US.UTF-8</span><br><span class="line">export LANG&#x3D;en_US.UTF-8</span><br></pre></td></tr></table></figure>

<p>然后在当前终端输入<code>jupyter notebook</code> 启动jupyter；</p>
<p>注意：以上的命令设置只对当前终端生效，如果在新的终端启动jupyter，还是会显示中文，目前没有对所有终端生效的方法。</p>
<h4 id="一种是永久的"><a href="#一种是永久的" class="headerlink" title="一种是永久的"></a>一种是永久的</h4><ol>
<li>在终端中输入locale查看系统默认的语言设置；</li>
<li>使用vim编辑bash_proﬁle文件，修改设置，终端输入<br><code>vim~/.bash_profile</code></li>
</ol>
<p><img src="/2020/01/20/1.%20python%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%AE%89%E8%A3%85/1.8.png" alt></p>
<ol start="3">
<li><p>在最后一行添加<code>export LANG=en_US.UTF-8</code>这一行</p>
</li>
<li><p>保存文件退出，然后在终端输入<code>source ~/.bash_profile</code> ，让设置生效，然后启动</p>
</li>
</ol>
<p><img src="/2020/01/20/1.%20python%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%AE%89%E8%A3%85/1.9.png" alt></p>
<h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><p>windows中在cmd中启动jupyter，默认以英文显示，如果想要中文，需要下载git。</p>
<ol>
<li>下载地址：<a href="https://www.git-scm.com/download/win" target="_blank" rel="noopener">https://www.git-scm.com/download/win</a></li>
<li>一路路next，进行安装；</li>
<li>安装完毕，搜索git bash并打开；</li>
<li>打开Git bash输入命令<code>jupyter notebook</code>启动jupyter.</li>
</ol>
]]></content>
      <categories>
        <category>data analytics</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>1 .信息形化</title>
    <url>/2020/01/20/1.%20%E4%BF%A1%E6%81%AF%E5%8C%96/</url>
    <content><![CDATA[<h2 id="饼图"><a href="#饼图" class="headerlink" title="饼图"></a>饼图</h2><p><img src="/2020/01/20/1.%20%E4%BF%A1%E6%81%AF%E5%8C%96/image20191210104031453.png" alt="image-20191210104031453"></p>
<p>作用：将数据划分为互有明显区分的几个组。</p>
<p>使用场景：</p>
<ul>
<li>展示数据相对频数</li>
</ul>
<blockquote>
<h3 id="频数"><a href="#频数" class="headerlink" title="频数"></a><strong>频数</strong></h3><p>表示在一个特定组,或者说在一个特定区间内的统计对象的数目, 类似于数数</p>
</blockquote>
<p>缺点：各组比例相差无几，难以比较</p>
<a id="more"></a>

<h2 id="条形图"><a href="#条形图" class="headerlink" title="条形图"></a>条形图</h2><p>相比较饼图，更精准，更容易发现细小的差别</p>
<h3 id="垂直条形图"><a href="#垂直条形图" class="headerlink" title="垂直条形图"></a>垂直条形图</h3><p><img src="/2020/01/20/1.%20%E4%BF%A1%E6%81%AF%E5%8C%96/image20191210104158183.png" alt="image-20191210104158183"></p>
<h3 id="水平条形图"><a href="#水平条形图" class="headerlink" title="水平条形图"></a>水平条形图</h3><p><img src="/2020/01/20/1.%20%E4%BF%A1%E6%81%AF%E5%8C%96/image20191210104214642.png" alt="image-20191210104214642"></p>
<h3 id="堆积条形图"><a href="#堆积条形图" class="headerlink" title="堆积条形图"></a>堆积条形图</h3><p>处理多批数据时候</p>
<p><img src="/2020/01/20/1.%20%E4%BF%A1%E6%81%AF%E5%8C%96/image20191210104249566.png" alt="image-20191210104249566"></p>
<h3 id="分段条形图"><a href="#分段条形图" class="headerlink" title="分段条形图"></a>分段条形图</h3><p>堆积条形图无法反应频数及百分数</p>
<p><img src="/2020/01/20/1.%20%E4%BF%A1%E6%81%AF%E5%8C%96/image20191210104402459.png" alt="image-20191210104402459"></p>
<blockquote>
<h3 id="标度的影响力"><a href="#标度的影响力" class="headerlink" title="标度的影响力"></a><strong>标度的影响力</strong></h3><p>利用“标度”能让你创建强大的条形图,凸显你希望别人注意的主要事实。标度同样能隐匿与数据有关的重要事实。</p>
</blockquote>
<blockquote>
<h3 id="类别与数字"><a href="#类别与数字" class="headerlink" title="类别与数字"></a>类别与数字</h3><h4 id="类别数据-定性数椐"><a href="#类别数据-定性数椐" class="headerlink" title="类别数据(定性数椐)"></a>类别数据(定性数椐)</h4><p>目前我们讲过的大部分数据都是类别数据。数据被划分为各种类别,用以描述某类的性质或特征。因此, 类别数据也称为定性数据。游戏种类就是定性数据的一个实例一每个游戏种类形成一个独立的类别关于定性数据,请记住一个重点:不能将数据值理解为数字。</p>
<h4 id="数值型数据-定置数椐"><a href="#数值型数据-定置数椐" class="headerlink" title="数值型数据(定置数椐)"></a>数值型数据(定置数椐)</h4><p>数值型数据不同,它所涉及的是数字。数值型数据中的数值具有数字的意义,但还涉及计量或计数。由于数值型数据描述的是数量,所以也称为定量数据。</p>
</blockquote>
<h2 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h2><p>与条形图的区别</p>
<ul>
<li>每个长方形的面积与频数成比例</li>
<li>图上的长方形之间没有间隔</li>
</ul>
<p>直方图的特点</p>
<ul>
<li>长方形面积表示频率</li>
</ul>
<h3 id="不等宽区间图"><a href="#不等宽区间图" class="headerlink" title="不等宽区间图"></a>不等宽区间图</h3><p><img src="/2020/01/20/1.%20%E4%BF%A1%E6%81%AF%E5%8C%96/image20191210105829433.png" alt="image-20191210105829433"></p>
<ul>
<li><p>长方形的面积=每组的频数</p>
</li>
<li><p>频数=长方形宽度*长方形高度</p>
</li>
<li><p>$频度密度（长方形的高度）=\frac{频数}{长方形宽度}$</p>
</li>
</ul>
<blockquote>
<h4 id="频数密度"><a href="#频数密度" class="headerlink" title="频数密度"></a>频数密度</h4><p>数据中的数值密集度</p>
</blockquote>
<h2 id="累计频数图"><a href="#累计频数图" class="headerlink" title="累计频数图"></a>累计频数图</h2><p><img src="/2020/01/20/1.%20%E4%BF%A1%E6%81%AF%E5%8C%96/image20191210111643779.png" alt="image-20191210111643779"></p>
<p>累积频数决不会减小</p>
<h2 id="折线图"><a href="#折线图" class="headerlink" title="折线图"></a>折线图</h2><p>优点：很好的体现数据的趋势</p>
<p>缺点：不如条形图清洗</p>
]]></content>
      <categories>
        <category>data analytics</category>
      </categories>
      <tags>
        <tag>《深入浅出统计学》</tag>
      </tags>
  </entry>
  <entry>
    <title>2. excel导入数据</title>
    <url>/2020/01/20/2.%20excel%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h2 id="通过网站站导入数据"><a href="#通过网站站导入数据" class="headerlink" title="通过网站站导入数据"></a>通过网站站导入数据</h2><ul>
<li><a href="https://archive.ics.uci.edu/ml/machine-learning-databases/breast-cancer-wisconsin/breast-cancer-wisconsin.data" target="_blank" rel="noopener">数据源</a></li>
<li>具体步骤如下:<br><img src="/2020/01/20/2.%20excel%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE/clipimage014.jpg" alt="img"> </li>
</ul>
<a id="more"></a>



<p><img src="/2020/01/20/2.%20excel%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE/clipimage016.jpg" alt="img"></p>
<h2 id="导文本数据"><a href="#导文本数据" class="headerlink" title="导文本数据"></a>导文本数据</h2><p><img src="/2020/01/20/2.%20excel%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE/clipimage018.jpg" alt="img"></p>
<p>选择对应的文本文件之后, 需要选择分隔符和新表所在位置就可以完成导入数据</p>
<h2 id="导入MySQL数据库数据"><a href="#导入MySQL数据库数据" class="headerlink" title="导入MySQL数据库数据"></a>导入MySQL数据库数据</h2><p>需要安装MySQL connect/net工具</p>
<ol>
<li>提前准备好需要连接的数据库 demo</li>
</ol>
<p><img src="/2020/01/20/2.%20excel%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE/clipimage020.jpg" alt="img"></p>
<ol start="2">
<li><p>选择数据 —&gt; 新建查询</p>
<p><img src="/2020/01/20/2.%20excel%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE/clipimage021.jpg" alt="img"> </p>
</li>
<li><p>选择从MySQL数据库中获取数据</p>
</li>
</ol>
<p><img src="/2020/01/20/2.%20excel%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE/clipimage023.jpg" alt="img"></p>
<ol start="4">
<li>输入连接的服务器和数据库名称</li>
</ol>
<p><img src="/2020/01/20/2.%20excel%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE/clipimage025.jpg" alt="img"> </p>
<ol start="5">
<li>不要使用默认的windows服务, 选择数据库服务, 输用户户名和密码</li>
</ol>
<p><img src="/2020/01/20/2.%20excel%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE/clipimage027.jpg" alt="img"></p>
<ol start="6">
<li>数据加载成功</li>
</ol>
<p><img src="/2020/01/20/2.%20excel%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE/clipimage029.jpg" alt="img"></p>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p><img src="/2020/01/20/2.%20excel%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE/157559735762576a31e55c01e483f8ee315acbc9fd55d.png" alt></p>
]]></content>
      <categories>
        <category>data analytics</category>
      </categories>
      <tags>
        <tag>excel</tag>
      </tags>
  </entry>
  <entry>
    <title>2. python语法入</title>
    <url>/2020/01/20/2.%20python%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p> 对代码的解释和说明， 可以提供代码的可读性。</p>
<blockquote>
<p>注释分为单行注释和多行注释<br>单行注释是以 # 开始<br>多行注释，可以使用三个双引号或者三个单引号””” “”” ‘’’ ‘’’</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义字符串变量name</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">我是多行注释</span></span><br><span class="line"><span class="string">我是多行注释</span></span><br><span class="line"><span class="string">我是多行注释</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">age=<span class="number">19</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">我是多行注释</span></span><br><span class="line"><span class="string">我是多行注释</span></span><br><span class="line"><span class="string">我是多行注释</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">sex=<span class="string">'男'</span></span><br></pre></td></tr></table></figure>

<p>注意： ctr + / -&gt; 单⾏行注释快捷键</p>
<a id="more"></a>

<h2 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h2><p><strong>变量：</strong> 通俗理解就是存储程序数据的容器。</p>
<p><strong>变量定义的格式</strong>：变量名 = 数据 (变量名尽量有含义，方便理解 )</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">score=<span class="number">100</span> <span class="comment">#定义一个变量名字叫score，存储的数据是100</span></span><br><span class="line">print(score)</span><br><span class="line"></span><br><span class="line">name=<span class="string">'张三'</span></span><br><span class="line">print(name)</span><br><span class="line"></span><br><span class="line">pi=<span class="number">3.14</span></span><br><span class="line">print(pi)</span><br><span class="line"></span><br><span class="line">is_ok =<span class="literal">True</span></span><br><span class="line">print(is_ok)</span><br><span class="line"></span><br><span class="line"><span class="comment">#提示：在python里面不需要指定数据的类型，会根据数据自动推导出数据类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#通过type查看变量类型</span></span><br><span class="line">score_type=type(score)</span><br><span class="line">print(score_type)</span><br><span class="line"></span><br><span class="line">name_type=type(name)</span><br><span class="line">print(name_type)</span><br><span class="line"></span><br><span class="line">pi_type=type(pi)</span><br><span class="line">print(pi_type)</span><br><span class="line"></span><br><span class="line">print(type(is_ok))</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> 常用的数据类型 int，str, ﬂoat, bool, list, tuple, dict,set</p>
<h2 id="变量的命名规则"><a href="#变量的命名规则" class="headerlink" title="变量的命名规则"></a>变量的命名规则</h2><p><strong>变量名：</strong>是由字母，数字，下划线组成的，注意只有这三种，但不能以数字开头</p>
<p>错误的使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span>name=<span class="string">'李四'</span></span><br><span class="line">print(<span class="number">3</span>name)</span><br><span class="line">name!age=<span class="number">18</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>变量命名方式： 驼峰命名法 和 下划线命名法<br>驼峰命名法: 小驼峰和大驼峰 小驼峰: 第一个单词首字母要小写，其它单词首字母都大写 大驼峰: 每个单词首字母都大写<br>下划线命名： 单词都使用小写字母，单词之间使用下划线进行分割, 比如: my_name</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_name=<span class="string">'李四'</span> <span class="comment">#下划线命名</span></span><br><span class="line">myName=<span class="string">'李四'</span> <span class="comment">#小驼峰</span></span><br><span class="line">MyName=<span class="string">'李四'</span> <span class="comment">#大驼峰</span></span><br></pre></td></tr></table></figure>

<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p><strong>关键字：</strong> 在python里面具有特殊功能的标识符（理解成变量名、函数名）， 关键字不能作为变量名使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&#39;False&#39;, &#39;None&#39;, &#39;True&#39;, &#39;and&#39;, &#39;as&#39;,</span><br><span class="line"> &#39;assert&#39;, &#39;break&#39;, &#39;class&#39;, &#39;continue&#39;, &#39;def&#39;, </span><br><span class="line">&#39;del&#39;, &#39;elif&#39;, &#39;else&#39;, &#39;except&#39;, &#39;finally&#39;,</span><br><span class="line"> &#39;for&#39;, &#39;from&#39;, &#39;global&#39;, &#39;if&#39;, &#39;import&#39;,</span><br><span class="line"> &#39;in&#39;, &#39;is&#39;, &#39;lambda&#39;, &#39;nonlocal&#39;, &#39;not&#39;, </span><br><span class="line">&#39;or&#39;, &#39;pass&#39;, &#39;raise&#39;, &#39;return&#39;, &#39;try&#39;,</span><br><span class="line">&#39;while&#39;, &#39;with&#39;, &#39;yield&#39;]</span><br></pre></td></tr></table></figure>


<h2 id="常用的数据类型转换"><a href="#常用的数据类型转换" class="headerlink" title="常用的数据类型转换"></a>常用的数据类型转换</h2><table>
<thead>
<tr>
<th><strong>函数</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>int(x [,base ])</td>
<td>将x转换为一个整数</td>
</tr>
<tr>
<td>ﬂoat(x )</td>
<td>将x转换为一个浮点数</td>
</tr>
<tr>
<td>complex(real [,imag ])</td>
<td>创建一个复数，real为实部，imag为虚部</td>
</tr>
<tr>
<td>str(x )</td>
<td>将对象 x 转换为字符串串</td>
</tr>
<tr>
<td>repr(x )</td>
<td>将对象 x 转换为表达式字符串串</td>
</tr>
<tr>
<td>eval(str )</td>
<td>用来计算在字符串串中的有效Python表达式,并返回一个对象</td>
</tr>
<tr>
<td>tuple(s )</td>
<td>将序列列 s 转换为一个元组</td>
</tr>
<tr>
<td>list(s )</td>
<td>将序列列 s 转换为一个列列表</td>
</tr>
<tr>
<td>chr(x )</td>
<td>将一个整数转换为一个Unicode字符</td>
</tr>
<tr>
<td>ord(x )</td>
<td>将一个字符转换为它的ASCII整数值</td>
</tr>
<tr>
<td>hex(x )</td>
<td>将一个整数转换为一个十六进制字符串串</td>
</tr>
<tr>
<td>oct(x )</td>
<td>将一个整数转换为一个八进制字符串串</td>
</tr>
<tr>
<td>bin(x )</td>
<td>将一个整数转换为一个二进制字符串串</td>
</tr>
</tbody></table>
<h2 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h2><p>生活中无时无刻其实都存在输入和输出的例子,我们先举例看一下生活中有哪些输入输出的情况,在来对比Python中的输入输出和生活中的有什么相同和不同之处。</p>
<h3 id="生活中的输出"><a href="#生活中的输出" class="headerlink" title="生活中的输出"></a>生活中的输出</h3><p>我们经常会去电影院看电影,我们从电影院屏幕中获取影片的内容来观看影片,而影片的放映室经过投影仪””照射””到大屏幕,同样的也可以说是投影仪把影片输出到大荧幕上来供我们观看,这就是生活中最简单的输出方式。</p>
<h3 id="Python中的输出"><a href="#Python中的输出" class="headerlink" title="Python中的输出"></a>Python中的输出</h3><p>Python中的输出和生活中的输出是一样的原理理，只不不过Python中的输出，特指是在控制台中输出,或  者是将你准备要输出的内容相应的输出到你的设备上，如你在手机上看到的文字、图片、视频等数据,其 实本质上也是我们敲打代码输出到手机上的.那我们先来看一下第一种，如何将你想要输出文字输出到控制台.</p>
<p>例如我们将一段文字”Hello World”输出到控制台，这里面利用的 print() 函数进行输出,以后我们会讲到函数的概念，先暂时知道print()可以帮助我们进行输出。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'hello world'</span>)</span><br></pre></td></tr></table></figure>

<p>右键点击选择 Run 和你对应的要运⾏行的⽂文件名字就可以运⾏行刚刚的输出代码<br><img src="/2020/01/20/2.%20python%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A8/1.10.png" alt></p>
<p>我们在图⽚片最下方看见的输出结果为hello world 输出的位置就是控制台</p>
<p><img src="/2020/01/20/2.%20python%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A8/1.11.png" alt></p>
<p>我们可以试试输出100+100会是什什么结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="number">100</span>+<span class="number">100</span>)</span><br></pre></td></tr></table></figure>


<h3 id="生活中的输入"><a href="#生活中的输入" class="headerlink" title="生活中的输入"></a>生活中的输入</h3><p>生活中的输入无处不在，例如你需要在各种软件中输入的账号密码，去ATM机器取钱也同样需要输入密码。</p>
<p><img src="/2020/01/20/2.%20python%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A8/1.12.png" alt></p>
<h3 id="Python中的输入"><a href="#Python中的输入" class="headerlink" title="Python中的输入"></a>Python中的输入</h3><p>和输出同理理我们也可用到控制台来记录输入结果,同样用到一个函数 input() ，我们可以利用这段代码在控制台输入，然后在利用刚刚学的 print() 函数把你输入的结果在输出来。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name=input()</span><br><span class="line">print(name)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当你运行完毕 name = input () 代码并将鼠标光标移动到控制台，Python交互式命令就在等你的输入了,你可以输入任意字符,然后按回车完成输入。</p>
</blockquote>
<h2 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 格式化符号：%s，%d，%f，%x</span><br><span class="line"># %s:输出字符串</span><br><span class="line"># %d:输出int类型数字</span><br><span class="line"># %f:输出浮点数</span><br><span class="line"># %x:输出16进制数据</span><br><span class="line"></span><br><span class="line">score&#x3D;100</span><br><span class="line">print(&#39;python成绩为：%d&#39;% sore)</span><br></pre></td></tr></table></figure>

<h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><p>计算机之所以能做很多⾃自动化的任务，因为它可以自己做条件判断。</p>
<p>比如，输入用户年龄，根据年龄打印不同的内容，在Python程序中，用 if 语句实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age=<span class="number">20</span></span><br><span class="line"><span class="keyword">if</span> age &gt;=<span class="number">18</span>:</span><br><span class="line">    print(<span class="string">'your age is'</span>,age)</span><br><span class="line">    print(<span class="string">'adult'</span>)</span><br></pre></td></tr></table></figure>



<p>根据Python的缩进规则，如果 if 语句判断是 True ，就把缩进的两行print语句执行了，否则，什么也不做。</p>
<p>也可以给 if 添加一个 else 语句，意思是，如果 if 判断是 False ，不要执行 if 的内容，去把 else 执行了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = <span class="number">3</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">	print(<span class="string">'your age is'</span>, age) </span><br><span class="line">	print(<span class="string">'adult'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	print(<span class="string">'your age is'</span>, age) </span><br><span class="line">	print(<span class="string">'teenager'</span>)</span><br></pre></td></tr></table></figure>

<p>注意不不要少写了冒号: 。</p>
<p>当然上面的判断是很粗略的，完全可以用 elif 做更细致的判断：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = <span class="number">3</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">	print(<span class="string">'adult'</span>) </span><br><span class="line"><span class="keyword">elif</span> age &gt;= <span class="number">6</span>:</span><br><span class="line">	print(<span class="string">'teenager'</span>) </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	print(<span class="string">'kid'</span>)</span><br></pre></td></tr></table></figure>

<p>elif 是else if 的缩写，完全可以有多个 elif ，所以 if 语句的完整形式就是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> &lt;条件判断<span class="number">1</span>&gt;:</span><br><span class="line">	&lt;执行<span class="number">1</span>&gt;</span><br><span class="line"><span class="keyword">elif</span> &lt;条件判断<span class="number">2</span>&gt;:</span><br><span class="line">	&lt;执行<span class="number">2</span>&gt;</span><br><span class="line"><span class="keyword">elif</span> &lt;条件判断<span class="number">3</span>&gt;:</span><br><span class="line">	&lt;执行<span class="number">3</span>&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	&lt;执行<span class="number">4</span>&gt;</span><br></pre></td></tr></table></figure>

<p>if 语句执行有个特点，它是从上往下判断，如果在某个判断上是 True ，把该判断对应的语句执行后， 就忽略掉剩下的elif 和 else ，所以，请测试并解释为什么下面的程序打印的是 teenager ：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = <span class="number">20</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">6</span>:</span><br><span class="line">	print(<span class="string">'teenager'</span>) </span><br><span class="line"><span class="keyword">elif</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">	print(<span class="string">'adult'</span>) </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	print(<span class="string">'kid'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><p>Python支持以下几种运算符:</p>
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>描述</strong></th>
<th><strong>实例例</strong></th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>加</td>
<td>两个对象相加 a + b 输出结果 30</td>
</tr>
<tr>
<td>-</td>
<td>减</td>
<td>得到负数或是一个数减去另一个数  a - b 输出结果 -10</td>
</tr>
<tr>
<td>*</td>
<td>乘</td>
<td>两个数相乘或是返回一个被重复若⼲干次的字符串串 a * b 输出结果 200</td>
</tr>
<tr>
<td>/</td>
<td>除</td>
<td>b / a 输出结果  2</td>
</tr>
<tr>
<td>//</td>
<td>取整除</td>
<td>返回商的整数部分 9//2 输出结果 4 , 9.0//2.0 输出结果 4.0</td>
</tr>
<tr>
<td>%</td>
<td>取余</td>
<td>返回除法的余数 b % a 输出结果 0</td>
</tr>
<tr>
<td>**</td>
<td>指数</td>
<td>a**b 为10的20次方，  输出结果 100000000000000000000</td>
</tr>
</tbody></table>
<blockquote>
<p>混合运算时，优先级顺序为：(<em>*)高于(</em>)(/)(%)(//)高于(+)(-) 为了避免歧义，建议使用 () 来处理运算符优先级。并且，不同类型的数字在进行混合运算时，整数将会转换成浮点数进行运算。</p>
</blockquote>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>描述</strong></th>
<th><strong>实例例</strong></th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>赋值运算符</td>
<td>把 = 号右边的结果 赋给 左边的变量，如 num = 1  + 2 * 3，结果num的值为7</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 单个变量赋值</span></span><br><span class="line">num = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多个变量赋值</span></span><br><span class="line">num1, num2, f1, str1 = <span class="number">100</span>, <span class="number">200</span>, <span class="number">3.14</span>, <span class="string">"hello"</span></span><br></pre></td></tr></table></figure>


<h3 id="复合赋值运算符"><a href="#复合赋值运算符" class="headerlink" title="复合赋值运算符"></a>复合赋值运算符</h3><table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>描述</strong></th>
<th><strong>实例例</strong></th>
</tr>
</thead>
<tbody><tr>
<td>+=</td>
<td>加法赋值运算符</td>
<td>c += a 等效于 c = c + a</td>
</tr>
<tr>
<td>-=</td>
<td>减法赋值运算符</td>
<td>c -= a 等效于 c = c - a</td>
</tr>
<tr>
<td>*=</td>
<td>乘法赋值运算符</td>
<td>c *= a 等效于 c = c * a</td>
</tr>
<tr>
<td>/=</td>
<td>除法赋值运算符</td>
<td>c /= a 等效于 c = c / a</td>
</tr>
<tr>
<td>%=</td>
<td>取模赋值运算符</td>
<td>c %= a 等效于 c = c % a</td>
</tr>
<tr>
<td>**=</td>
<td>幂赋值运算符</td>
<td>c** <strong>= a</strong> <strong>等效于</strong>  <strong>c = c</strong> a</td>
</tr>
<tr>
<td>//=</td>
<td>取整除赋值运算符</td>
<td>c //= a 等效于 c = c // a</td>
</tr>
</tbody></table>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>我们来试想这样一种情况,现在让你们在控制台输出100条hello world ,本质上,我们写一百条 print 函数输出就可以了,但是如果一千条一万条呢.这就要用到循环语句了.</p>
<h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>while循环语句语法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件:</span><br><span class="line">	条件满足时，做的事情<span class="number">1</span> </span><br><span class="line">	条件满足时，做的事情<span class="number">2</span> </span><br><span class="line">	条件满足时，做的事情<span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>例例如输出100条 hello world</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">100</span></span><br><span class="line">whiel i &lt;=<span class="number">100</span>:</span><br><span class="line">	print(<span class="string">'hello world'</span>)</span><br><span class="line">	i + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>相对应,在while循环语句里面,每执行一次循环语句, i 就会加1,直到i 等于101时不满足 i&lt;=100 的条件,循环就结束了</p>
<h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>for循环和while一样同样可以进行循环,并且是运用最多的循环方式,而且它有一项非常厉害的功能——遍历 ,在Python中  for 循环可以遍历任何序列项目,如字符串,或者今后会学到的列表,例如我们遍历字符串,就特指将字符串的所有字符全部访问一遍</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">names = [<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>] </span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">	print(name)</span><br></pre></td></tr></table></figure>

<p>执行这段代码，会依次打印 names 的每一个元素：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Michael </span><br><span class="line">Bob </span><br><span class="line">Tracy</span><br></pre></td></tr></table></figure>

<p>所以for x in … 循环就是把每个元素代入变量x ，然后执行缩进块的语句。再比如我们想计算1-10的整数之和，可以用一个 sum 变量做累加：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]:</span><br><span class="line">	sum = sum + x </span><br><span class="line">	print(sum)</span><br></pre></td></tr></table></figure>

<p>Python还提供了一个range()函数,可以配合我们的for循环使用,例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>): </span><br><span class="line">	print(i)</span><br><span class="line"></span><br><span class="line"><span class="comment">#效果等同于 while 循环的：</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">5</span>:</span><br><span class="line">	print(i) </span><br><span class="line">	i += <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>我们在来学习两个关键字 breake continue ,这两个关键字是我们循环语句的好帮手</p>
<h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>在循环中， break 语句可以提前退出循环。例如，本来要循环打印1～100的数字：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> n &lt;= <span class="number">100</span>: </span><br><span class="line">	print(n)</span><br><span class="line">	n = n + <span class="number">1</span> </span><br><span class="line">print(<span class="string">'END'</span>)</span><br></pre></td></tr></table></figure>

<p>上面的代码可以打印出1~100。</p>
<p>如果要提前结束循环，可以用 break 语句：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> n &lt;= <span class="number">100</span>:</span><br><span class="line">	<span class="keyword">if</span> n &gt; <span class="number">10</span>: <span class="comment"># 当n = 11时，条件满足，执行break语句</span></span><br><span class="line">		<span class="keyword">break</span> <span class="comment"># break语句会结束当前循环</span></span><br><span class="line">	print(n) </span><br><span class="line">	n = n + <span class="number">1</span></span><br><span class="line">print(<span class="string">'END'</span>)</span><br></pre></td></tr></table></figure>

<p>执行上面的代码可以看到，打印出1~10后，紧接着打印 END ，程序结束。可见 break 的作用是提前结束循环。</p>
<h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>在循环过程中，也可以通过 continue 语句，跳过当前的这次循环，直接开始下一次循环。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> n &lt; <span class="number">10</span>:</span><br><span class="line">	n = n + <span class="number">1</span> </span><br><span class="line">	print(n)</span><br></pre></td></tr></table></figure>

<p>上面的程序可以打印出1～10。但是，如果我们想只打印奇数，可以用 continue 语句跳过某些循环：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> n &lt; <span class="number">10</span>:</span><br><span class="line">	n = n + <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>: <span class="comment"># 如果n是偶数，执行continue语句</span></span><br><span class="line">		<span class="keyword">continue</span> <span class="comment"># continue语句会直接继续下⼀一轮循环，后续的print()语句不不会执行</span></span><br><span class="line">	print(n)</span><br></pre></td></tr></table></figure>

<p>执行上面的代码可以看到，打印的不再是1～10，而是1，3，5，7，9。    可见 continue 的作用是提前结束本轮循环，并直接开始下一轮循环。</p>
]]></content>
      <categories>
        <category>data analytics</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>1.认识excel</title>
    <url>/2020/01/20/1.%20%E8%AE%A4%E8%AF%86excel/</url>
    <content><![CDATA[<h2 id="Excel的常见对象"><a href="#Excel的常见对象" class="headerlink" title="Excel的常见对象"></a>Excel的常见对象</h2><ul>
<li>工作簿: 工作表的集合</li>
<li>工作表 (数据的集合)</li>
<li>字段: 数据的列标题</li>
<li>记录: 一行数据</li>
</ul>
<a id="more"></a>

<p><img src="/2020/01/20/1.%20%E8%AE%A4%E8%AF%86excel/clipimage009.jpg" alt="img"></p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li><p>基本数据类型</p>
<p>文本型</p>
<p>数值型</p>
<p>整数型</p>
<p>小数型</p>
<p>日期型</p>
<p>布尔型</p>
<p>其他类型</p>
</li>
<li><p>变量类型</p>
<p>名义型：没有顺序，只表示分类（男女）</p>
<p>有序型：优良中差</p>
<p>连续型：身高，体重……</p>
<p>星期属于有序型，时间属于连续型</p>
</li>
</ul>
<p><img src="/2020/01/20/1.%20%E8%AE%A4%E8%AF%86excel/15755973575563ccce84116434250b142855add4fd1d5.png" alt></p>
<p><img src="/2020/01/20/1.%20%E8%AE%A4%E8%AF%86excel/clipimage011.jpg" alt="img"></p>
<blockquote>
<p>注: 如果将纯数字存储为文本格式将导致无法计算, 此时可以通过 某列 * 1来快速修改数据类型</p>
</blockquote>
<p><img src="/2020/01/20/1.%20%E8%AE%A4%E8%AF%86excel/15755973575802db39373188546f886725305392087fe.png" alt></p>
<p><img src="/2020/01/20/1.%20%E8%AE%A4%E8%AF%86excel/1575597357601457ecb632c28490e9942f7e3cd5905ea.png" alt></p>
]]></content>
      <categories>
        <category>data analytics</category>
      </categories>
      <tags>
        <tag>excel</tag>
      </tags>
  </entry>
  <entry>
    <title>2. 集中趋势的量度</title>
    <url>/2020/01/20/2.%20%E9%9B%86%E4%B8%AD%E8%B6%8B%E5%8A%BF%E7%9A%84%E9%87%8F%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="均值"><a href="#均值" class="headerlink" title="均值"></a>均值</h2><ul>
<li><p>平均数的一般量度</p>
</li>
<li><p>将所有数字加起来，除以数字个数</p>
</li>
</ul>
<ol>
<li><p>求和</p>
<p>$x_1+x_2+……+x_n=\sum x$</p>
</li>
<li><p>平均值</p>
<p>$\mu=\frac{sum_x}{x}$</p>
</li>
</ol>
<h2 id="频数均值"><a href="#频数均值" class="headerlink" title="频数均值"></a>频数均值</h2><p>$\mu=\frac{\sum fx}{\sum_f}$</p>
<ul>
<li><p>$\sum fx$表示每个数字乘以其频数，然后相加</p>
</li>
<li><p>$\sum f$表示每个数频数相加</p>
</li>
</ul>
<a id="more"></a>

<blockquote>
<h3 id="异常值"><a href="#异常值" class="headerlink" title="异常值"></a>异常值</h3><p>与其他数据格格不入的极高值或者极低值</p>
<h3 id="偏斜数据"><a href="#偏斜数据" class="headerlink" title="偏斜数据"></a>偏斜数据</h3><p>当异常值将数据向左或向右“拉”时即产生偏斜数据</p>
<p><strong>中位数均值同偏移的关系</strong></p>
<ul>
<li>向右偏斜<br><img src="/2020/01/20/2.%20%E9%9B%86%E4%B8%AD%E8%B6%8B%E5%8A%BF%E7%9A%84%E9%87%8F%E5%BA%A6/image20191210113836558.png" alt="image-20191210113836558"></li>
<li>向左偏斜<br><img src="/2020/01/20/2.%20%E9%9B%86%E4%B8%AD%E8%B6%8B%E5%8A%BF%E7%9A%84%E9%87%8F%E5%BA%A6/image20191210114242519.png" alt="image-20191210114242519"></li>
<li>对称数椐<br><img src="/2020/01/20/2.%20%E9%9B%86%E4%B8%AD%E8%B6%8B%E5%8A%BF%E7%9A%84%E9%87%8F%E5%BA%A6/image20191210114300105.png" alt="image-20191210114300105"></li>
</ul>
</blockquote>
<h2 id="中位数"><a href="#中位数" class="headerlink" title="中位数"></a>中位数</h2><p>当偏斜数据和异常值使均值产生误导时,我们就需要用其他方式表示典型值。我们可以取中间值，中位数永近处于中间,它是个中间值。</p>
<p>*<em>求中位数三步法: *</em></p>
<ol>
<li><p>按顺序排列数字:从最小値排列到最大値。</p>
</li>
<li><p>如果奇数个数,则中位数为位于中间的数値。位置为$\frac{m+1}{2}$</p>
</li>
<li><p>如果偶数个数,将两个中间数相加,然后除以2。位置为$\frac{m\pm1}{2}$</p>
</li>
</ol>
<p><strong>中位数与偏移的关系</strong>：</p>
<p><img src="/2020/01/20/2.%20%E9%9B%86%E4%B8%AD%E8%B6%8B%E5%8A%BF%E7%9A%84%E9%87%8F%E5%BA%A6/image20191210115448774.png" alt="image-20191210115448774"></p>
<h2 id="众数"><a href="#众数" class="headerlink" title="众数"></a>众数</h2><ul>
<li>数据集中的数</li>
<li>出现最频繁的数值</li>
<li>可能不止一个（有个众数：双峰数据）</li>
<li>既能用于数值数据，又能用于类别数据</li>
</ul>
<p><strong>众数的计算</strong></p>
<ul>
<li>不同类别的数值或类别找出</li>
<li>列出频数</li>
<li>找出最值</li>
</ul>
]]></content>
      <categories>
        <category>data analytics</category>
      </categories>
      <tags>
        <tag>《深入浅出统计学》</tag>
      </tags>
  </entry>
  <entry>
    <title>3. excel常见的操作</title>
    <url>/2020/01/20/3.%20excel%E5%B8%B8%E8%A7%81%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h2><p><img src="/2020/01/20/3.%20excel%E5%B8%B8%E8%A7%81%E7%9A%84%E6%93%8D%E4%BD%9C/clipimage032.gif" alt="img"> </p>
<a id="more"></a>

<p><img src="/2020/01/20/3.%20excel%E5%B8%B8%E8%A7%81%E7%9A%84%E6%93%8D%E4%BD%9C/clipimage034.jpg" alt="img"></p>
<h2 id="拆分"><a href="#拆分" class="headerlink" title="拆分"></a>拆分</h2><p><img src="/2020/01/20/3.%20excel%E5%B8%B8%E8%A7%81%E7%9A%84%E6%93%8D%E4%BD%9C/clipimage037.gif" alt="img"> </p>
<h2 id="排序和筛选"><a href="#排序和筛选" class="headerlink" title="排序和筛选"></a>排序和筛选</h2><p><img src="/2020/01/20/3.%20excel%E5%B8%B8%E8%A7%81%E7%9A%84%E6%93%8D%E4%BD%9C/clipimage039.jpg" alt="img"></p>
<p><img src="/2020/01/20/3.%20excel%E5%B8%B8%E8%A7%81%E7%9A%84%E6%93%8D%E4%BD%9C/clipimage041.jpg" alt="img"> </p>
<h2 id="下拉表"><a href="#下拉表" class="headerlink" title="下拉表"></a>下拉表</h2><p><img src="/2020/01/20/3.%20excel%E5%B8%B8%E8%A7%81%E7%9A%84%E6%93%8D%E4%BD%9C/clipimage043.jpg" alt="img"> </p>
<p><img src="/2020/01/20/3.%20excel%E5%B8%B8%E8%A7%81%E7%9A%84%E6%93%8D%E4%BD%9C/clipimage045.jpg" alt="img"></p>
<h2 id="单元格"><a href="#单元格" class="headerlink" title="单元格"></a>单元格</h2><p><img src="/2020/01/20/3.%20excel%E5%B8%B8%E8%A7%81%E7%9A%84%E6%93%8D%E4%BD%9C/1575597357644fc7dbbbd70b14f05b14f0444dfe4294f.png" alt></p>
<h2 id="查找和替换"><a href="#查找和替换" class="headerlink" title="查找和替换"></a>查找和替换</h2><p><img src="/2020/01/20/3.%20excel%E5%B8%B8%E8%A7%81%E7%9A%84%E6%93%8D%E4%BD%9C/1575597357644fc7dbbbd70b14f05b14f0444dfe4294f15759.png" alt></p>
<h2 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h2><p><img src="/2020/01/20/3.%20excel%E5%B8%B8%E8%A7%81%E7%9A%84%E6%93%8D%E4%BD%9C/15755973576873f6834aaea2340f29561aecb4b91f198.png" alt></p>
<h2 id="表格转表"><a href="#表格转表" class="headerlink" title="表格转表"></a>表格转表</h2><ul>
<li>列是基础的数据字段</li>
<li>易于处理大量数据</li>
<li>关联外部数据</li>
</ul>
<p><img src="/2020/01/20/3.%20excel%E5%B8%B8%E8%A7%81%E7%9A%84%E6%93%8D%E4%BD%9C/15755973576873f6834aaea2340f29561aecb4b91f19815759.png" alt></p>
]]></content>
      <categories>
        <category>data analytics</category>
      </categories>
      <tags>
        <tag>excel</tag>
      </tags>
  </entry>
  <entry>
    <title>3. python数据类型</title>
    <url>/2020/01/20/3.%20python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="字符串（str）"><a href="#字符串（str）" class="headerlink" title="字符串（str）"></a>字符串（str）</h2><h3 id="字符串的定义"><a href="#字符串的定义" class="headerlink" title="字符串的定义"></a>字符串的定义</h3><p>我们在介绍数据类型的时候,简单介绍了一下字符串类型.因为字符串是Python语言中特别重要的概念(不仅是Python,在其他语言中也有着举重若轻的位置),我们详细的讲解一下字符串的用法。</p>
<p>我们已经知道了,单引号,双引号,包括三引号包围的字符组,就是字符串,例如</p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str = <span class="string">'hello'</span><span class="comment">#定义字符串变量</span></span><br><span class="line">str = <span class="string">"helo"</span><span class="comment">#定义字符串变量</span></span><br><span class="line">str = <span class="string">"""hello</span></span><br><span class="line"><span class="string">hello"""</span><span class="comment">#定义多行字符串变量</span></span><br></pre></td></tr></table></figure>

<h3 id="下标和切片"><a href="#下标和切片" class="headerlink" title="下标和切片"></a>下标和切片</h3><h4 id="下标索引"><a href="#下标索引" class="headerlink" title="下标索引"></a>下标索引</h4><p>下标在Python中的概念就是编号的意思, 字符串 元组 列表 都会经常用到下标的概念,我们可以根据下标找到它们所对应的元素.就好像生活中你要准备去看电影,电影票上的座位号找到对应的位置。</p>
<p>我们现在考虑这样⼀一个问题,例例如我们创建了一个字符串name = zhang ,我现在想取到名为 name 字符串里面的a字符.如何去取呢?,其实我们可以通过我们讲过的for循环来遍历这个字符串,通过这种方法来取出字符串里的字符,但是 Python 给我们提供了了更为简便的方法,我们就可以用下标来取出a 字符</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name=<span class="string">'zhangsan'</span></span><br><span class="line">print(name[<span class="number">2</span>])</span><br></pre></td></tr></table></figure>

<pre><code>a</code></pre><h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><p>我们可以利用下表索引取到字符串里面对应的一个元素,但如果想要截取一段元素就要用到切片。</p>
<p>切片是指对操作的对象截取其中一部分的操作。<strong>字符串、列表、元组</strong>都支持切片操作。 <strong>切片的语法: [起始:结束:步长]</strong><br>我们以字符串为例例讲解。</p>
<p>如果取出一部分，则可以在中括号 [] 中，使用:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">'abcdef'</span></span><br><span class="line">print(name[<span class="number">0</span>:<span class="number">3</span>]) <span class="comment"># 取 下标0~2 的字符</span></span><br><span class="line">print(name[<span class="number">3</span>:<span class="number">5</span>]) <span class="comment"># 取 下标为3、4 的字符</span></span><br><span class="line">print(name[<span class="number">2</span>:]) <span class="comment"># 取 下标为2开始到最后的字符</span></span><br><span class="line"><span class="comment">#支持负数</span></span><br><span class="line">name = <span class="string">'abcdef'</span></span><br><span class="line">print(name[<span class="number">1</span>:<span class="number">-1</span>]) <span class="comment"># 取  下标为1开始  到  最后第2个	之间的字符</span></span><br></pre></td></tr></table></figure>

<pre><code>abc
de
cdef
bcde</code></pre><h3 id="字符串的常见操作"><a href="#字符串的常见操作" class="headerlink" title="字符串的常见操作"></a>字符串的常见操作</h3><p>如有字符串mystr = ‘hello world kkb’ ，以下是常见的操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mystr = <span class="string">'hello world kkb'</span></span><br></pre></td></tr></table></figure>

<h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p>检测    是否包含在 mystr中，如果是返回开始的索引值，否则返回-1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mystr.find(str, start&#x3D;0, end&#x3D;len(mystr))</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mystr.find(<span class="string">'kkb'</span>)</span><br></pre></td></tr></table></figure>


<pre><code>12</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mystr.find(<span class="string">'kkb'</span>,<span class="number">0</span>,<span class="number">10</span>)<span class="comment">#在mstr字符串串0-10下标范围查询</span></span><br></pre></td></tr></table></figure>


<pre><code>-1</code></pre><h4 id="index"><a href="#index" class="headerlink" title="index"></a>index</h4><p>跟 find() 方法一样，只不过如果 str 不在 mystr中会报一个异常.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mystr.index(str, start=<span class="number">0</span>, end=len(mystr))</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mystr.index(<span class="string">'ab'</span>)</span><br></pre></td></tr></table></figure>


<pre><code>---------------------------------------------------------------------------

ValueError                                Traceback (most recent call last)

&lt;ipython-input-9-46892962653f&gt; in &lt;module&gt;()
----&gt; 1 mystr.index(&apos;ab&apos;)


ValueError: substring not found</code></pre><h4 id="count"><a href="#count" class="headerlink" title="count"></a>count</h4><p>返回str在start和end之间在mystr里面出现的次数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mystr.count(str,start,end=len(mystr))</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mystr.count(<span class="string">'kkb'</span>)</span><br></pre></td></tr></table></figure>


<pre><code>1</code></pre><h4 id="replce"><a href="#replce" class="headerlink" title="replce"></a>replce</h4><p>把mystr中的str1替换成str2 ,如果count指定，则替换不超过count次。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mystr.replace(str1,str2,mystr.count(str1))</span><br></pre></td></tr></table></figure>

<h4 id="split"><a href="#split" class="headerlink" title="split"></a>split</h4><p>以str为分隔符切片 mystr，如果maxsplit有指定值，则仅分隔maxsplit个子字符串。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mystr.split(str&#x3D;&quot; &quot;, 2)</span><br></pre></td></tr></table></figure>

<h4 id="capitallize"><a href="#capitallize" class="headerlink" title="capitallize"></a>capitallize</h4><p>把字符串的第一个字母大写</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mystr.capitalize()</span><br></pre></td></tr></table></figure>


<pre><code>&apos;Hello world kkb&apos;</code></pre><h4 id="title"><a href="#title" class="headerlink" title="title"></a>title</h4><p>首字母大写</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mystr.title()</span><br></pre></td></tr></table></figure>


<pre><code>&apos;Hello World Kkb&apos;</code></pre><h4 id="startswith"><a href="#startswith" class="headerlink" title="startswith"></a>startswith</h4><p>检查字符串是否是以hello开头, 是则返回True，否则返False</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mystr.startswith(<span class="string">'hello'</span>)</span><br></pre></td></tr></table></figure>


<pre><code>True</code></pre><h4 id="endswith"><a href="#endswith" class="headerlink" title="endswith"></a>endswith</h4><p>检查字符串是否以obj结尾，如果是则返回True，否则返False</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mystr.endswith(<span class="string">'obj'</span>)</span><br></pre></td></tr></table></figure>


<pre><code>False</code></pre><h4 id="lower"><a href="#lower" class="headerlink" title="lower"></a>lower</h4><p>转换mystr中所有大写字符为小写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mystr.lower()</span><br></pre></td></tr></table></figure>

<h4 id="upper"><a href="#upper" class="headerlink" title="upper"></a>upper</h4><p>转换mystr中所有小写字符为大写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mystr.upper()</span><br></pre></td></tr></table></figure>

<h4 id="ljust"><a href="#ljust" class="headerlink" title="ljust"></a>ljust</h4><p>返回一个原字符串左对齐,并使用空格填充至长度width的新字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">width=<span class="number">32</span></span><br><span class="line">mystr.ljust(width)</span><br></pre></td></tr></table></figure>


<pre><code>&apos;hello world kkb                 &apos;</code></pre><h4 id="rjust"><a href="#rjust" class="headerlink" title="rjust"></a>rjust</h4><p>返回一个原字符串右对齐,并使用空格填充至长度width的新字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mystr.rjust(width)</span><br></pre></td></tr></table></figure>

<h4 id="center"><a href="#center" class="headerlink" title="center"></a>center</h4><p>返回一个原字符串居中对齐,并使用空格填充至长度width的新字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mystr.center()</span><br></pre></td></tr></table></figure>

<h4 id="lstrip"><a href="#lstrip" class="headerlink" title="lstrip"></a>lstrip</h4><p>删除mystr左边的空白字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mystr.lstrip()</span><br></pre></td></tr></table></figure>

<h4 id="rstrip"><a href="#rstrip" class="headerlink" title="rstrip"></a>rstrip</h4><p>删除mystr右边的空白字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mystr.rstrip()</span><br></pre></td></tr></table></figure>

<h4 id="strip"><a href="#strip" class="headerlink" title="strip"></a>strip</h4><p>删除mystr两端的空白字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mystr.strip()</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">"\n\t kkb \t\n"</span> </span><br><span class="line">print(a)</span><br><span class="line">a.strip()</span><br></pre></td></tr></table></figure>


<pre><code>     kkb     



&apos;kkb&apos;</code></pre><h4 id="rfind"><a href="#rfind" class="headerlink" title="rfind"></a>rfind</h4><p>类似于 find() 函数，不不过是从右边开始查找.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mystr.find(str, start=<span class="number">0</span>,end=len(mystr))</span><br></pre></td></tr></table></figure>

<h4 id="rindex"><a href="#rindex" class="headerlink" title="rindex"></a>rindex</h4><p>类似于 index() ，不不过是从右边开始.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mystr.rindex(str, start=<span class="number">0</span>,end=len(mystr))</span><br></pre></td></tr></table></figure>

<h4 id="partition"><a href="#partition" class="headerlink" title="partition"></a>partition</h4><p>把 mystr以str分割成三部分, str前， str和str后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mystr.partition(str)</span><br></pre></td></tr></table></figure>

<h4 id="rpartition"><a href="#rpartition" class="headerlink" title="rpartition"></a>rpartition</h4><p>类似于 partition()函数,不不过是从右边开始.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mystr.rpartition(str)</span><br></pre></td></tr></table></figure>

<h4 id="splitlines"><a href="#splitlines" class="headerlink" title="splitlines"></a>splitlines</h4><p>按照行分隔，返回一个包含各行作为元素的列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mystr.splitlines()</span><br></pre></td></tr></table></figure>

<h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><p>mystr中每个元素后面插入 str ,构造出⼀一个新的字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mystr.jion(str)</span><br></pre></td></tr></table></figure>

<h2 id="列表（list）"><a href="#列表（list）" class="headerlink" title="列表（list）"></a>列表（list）</h2><h3 id="列表简介"><a href="#列表简介" class="headerlink" title="列表简介"></a>列表简介</h3><p>Python内置的一种数据类型是列表： list 。 list 是一种有序的集合，可以随时添加和删除其中的元素，写在方括号之间、用逗号分隔开的数值列表。列表内的项目不必全是相同的类型。</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1= [<span class="string">'spam'</span>,<span class="string">'eggs'</span>,<span class="string">'12'</span>,<span class="number">123</span>]</span><br></pre></td></tr></table></figure>

<p>注意：比C语言的数组强大的地方在于列表中的元素可以是<strong>不同类型的。</strong></p>
<h3 id="列表的常见操作"><a href="#列表的常见操作" class="headerlink" title="列表的常见操作"></a>列表的常见操作</h3><h4 id="列表的长度"><a href="#列表的长度" class="headerlink" title="列表的长度"></a>列表的长度</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#⽤用len()函数可以获得list元素的个数：</span></span><br><span class="line">namesList = [<span class="string">'xiaoWang'</span>,<span class="string">'xiaoZhang'</span>,<span class="string">'xiaoHua'</span>] </span><br><span class="line">len(namesList)</span><br></pre></td></tr></table></figure>


<pre><code>3</code></pre><h4 id="列表的访问"><a href="#列表的访问" class="headerlink" title="列表的访问"></a>列表的访问</h4><p>用索引来访问 list 中每一个位置的元素，记得索引是<strong>从0开始的</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">namesList = [<span class="string">'xiaoWang'</span>,<span class="string">'xiaoZhang'</span>,<span class="string">'xiaoHua'</span>] </span><br><span class="line">print(namesList[<span class="number">0</span>])</span><br><span class="line">print(namesList[<span class="number">1</span>]) </span><br><span class="line">print(namesList[<span class="number">2</span>]) </span><br><span class="line">print(namesList[<span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<pre><code>xiaoWang
xiaoZhang
xiaoHua




---------------------------------------------------------------------------

IndexError                                Traceback (most recent call last)

&lt;ipython-input-42-c578a48b9b76&gt; in &lt;module&gt;()
      3 print(namesList[1])
      4 print(namesList[2])
----&gt; 5 print(namesList[3])



IndexError: list index out of range</code></pre><p>注意：当索引超出了范围时，Python会报一个 IndexError 错误，所以，要确保索引不要越界，记得最后一个元素的索引是len(classmates) - 1 </p>
<p>如果要取最后一个元素，除了了计算索引位置外，还可以用-1做索引，直接获取最后一个元素：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(namesList[<span class="number">-1</span>])</span><br><span class="line"><span class="comment">#以此类推，可以获取倒数第2个、倒数第3个：</span></span><br><span class="line">print(namesList[<span class="number">-2</span>])</span><br><span class="line">print(namesList[<span class="number">-3</span>])</span><br></pre></td></tr></table></figure>

<pre><code>xiaoHua
xiaoZhang
xiaoWang</code></pre><h4 id="列表的切片"><a href="#列表的切片" class="headerlink" title="列表的切片"></a>列表的切片</h4><p>切片: 根据下标的范围获取一部分数据，⽐比如: 列表，字符串可以使用切片。</p>
<p><strong>切片的使用格式</strong></p>
<p>数据[起始下标:结束下标:步长]</p>
<p>提示： 起始下标默认0， 结束下标是不包含， 步长默认是1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用切片的方式获取一部分数据</span></span><br><span class="line">my_str=[<span class="string">'zhangsan'</span>,<span class="string">'lisi'</span>,<span class="string">'wangwu'</span>,<span class="number">45</span>,<span class="number">781</span>,<span class="string">'erf'</span>]</span><br><span class="line">result = my_str[<span class="number">1</span>:<span class="number">4</span>:<span class="number">1</span>]</span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line"><span class="comment">#前三个</span></span><br><span class="line">result = my_str[<span class="number">0</span>:<span class="number">3</span>] </span><br><span class="line">print(result)</span><br><span class="line">result = my_str[:<span class="number">3</span>] </span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>

<pre><code>[&apos;lisi&apos;, &apos;wangwu&apos;, 45]
[&apos;zhangsan&apos;, &apos;lisi&apos;, &apos;wangwu&apos;]
[&apos;zhangsan&apos;, &apos;lisi&apos;, &apos;wangwu&apos;]</code></pre><h4 id="添加元素-append-extend-insert"><a href="#添加元素-append-extend-insert" class="headerlink" title="添加元素( append , extend , insert )"></a>添加元素( append , extend , insert )</h4><p>通过 append 可以向列列表添加元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义变量量A，默认有3个元素</span></span><br><span class="line">A = [<span class="string">'xiaoWang'</span>,<span class="string">'xiaoZhang'</span>,<span class="string">'xiaoHua'</span>]</span><br><span class="line"></span><br><span class="line">print(<span class="string">"-----添加之前，列列表A的数据	"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> tempName <span class="keyword">in</span> A: </span><br><span class="line">    print(tempName)</span><br><span class="line"><span class="comment">#提示、并添加元素</span></span><br><span class="line">temp = input(<span class="string">'请输入要添加的学生姓名:'</span>) </span><br><span class="line">A.append(temp)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"-----添加之后，列列表A的数据	"</span>)</span><br><span class="line"><span class="keyword">for</span> tempName <span class="keyword">in</span> A:</span><br><span class="line">    print(tempName)</span><br></pre></td></tr></table></figure>

<pre><code>-----添加之前，列列表A的数据    
xiaoWang
xiaoZhang
xiaoHua
请输入要添加的学生姓名:huohuo
-----添加之后，列列表A的数据    
xiaoWang
xiaoZhang
xiaoHua
huohuo</code></pre><p>通过 extend 可以将另⼀一个集合中的元素逐⼀一添加到列列表中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">b = [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">a.append(b)</span><br><span class="line">print(a)</span><br><span class="line">print(<span class="string">'-----'</span>)</span><br><span class="line">a.extend(b)</span><br><span class="line">print(a)</span><br><span class="line">print(<span class="string">'-----'</span>)</span><br><span class="line"><span class="comment"># insert(index,object)` 在指定位置`index`前插入元素`object</span></span><br><span class="line"></span><br><span class="line">a = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">a.insert(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>

<pre><code>[1, 2, [3, 4]]
-----
[1, 2, [3, 4], 3, 4]
-----
[0, 3, 1, 2]</code></pre><h4 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h4><p>修改元素的时候，要通过<strong>下标</strong>来确定要修改的是哪个元素，然后才能进行修改</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义变量量A，默认有3个元素</span></span><br><span class="line">A = [<span class="string">'xiaoWang'</span>,<span class="string">'xiaoZhang'</span>,<span class="string">'xiaoHua'</span>]</span><br><span class="line"></span><br><span class="line">print(<span class="string">"-----修改之前，列列表A的数据	"</span>)</span><br><span class="line"><span class="keyword">for</span> tempName <span class="keyword">in</span> A: print(tempName)</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改元素</span></span><br><span class="line">A[<span class="number">1</span>] = <span class="string">'xiaoLu'</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"-----修改之后，列列表A的数据	"</span>)</span><br><span class="line"><span class="keyword">for</span> tempName <span class="keyword">in</span> A: print(tempName)</span><br></pre></td></tr></table></figure>

<pre><code>-----修改之前，列列表A的数据    
xiaoWang
xiaoZhang
xiaoHua
-----修改之后，列列表A的数据    
xiaoWang
xiaoLu
xiaoHua</code></pre><h4 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h4><p>所谓的查找，就是看看指定的元素是否存在。</p>
<p>python中查找的常用方法为：</p>
<ul>
<li><p>in （存在）,如果存在那么结果为 true ，否则为 false</p>
</li>
<li><p>not in （不存在），如果不存在那么结果为 true ，否则 false</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#待查找的列表</span></span><br><span class="line">nameList = [<span class="string">'xiaoWang'</span>,<span class="string">'xiaoZhang'</span>,<span class="string">'xiaoHua'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取用户要查找的名字</span></span><br><span class="line">findName = input(<span class="string">'请输入要查找的姓名:'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#查找是否存在</span></span><br><span class="line"><span class="keyword">if</span> findName <span class="keyword">in</span> nameList:</span><br><span class="line">    print(<span class="string">'在字典中找到了了相同的名字'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'没有找到'</span>)</span><br></pre></td></tr></table></figure>

<pre><code>请输入要查找的姓名:Ryan
没有找到</code></pre><p>index 和 count 与字符串中的用法相同</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>]</span><br><span class="line">a.index(<span class="string">'a'</span>, <span class="number">1</span>, <span class="number">3</span>) <span class="comment"># 注意左闭右开区间</span></span><br></pre></td></tr></table></figure>


<pre><code>---------------------------------------------------------------------------

ValueError                                Traceback (most recent call last)

&lt;ipython-input-2-5317aed0f6cc&gt; in &lt;module&gt;()
      1 a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;a&apos;, &apos;b&apos;]
----&gt; 2 a.index(&apos;a&apos;, 1, 3) # 注意左闭右开区间



ValueError: &apos;a&apos; is not in list</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.index(<span class="string">'a'</span>,<span class="number">1</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure>


<pre><code>3</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.count(<span class="string">'b'</span>)</span><br></pre></td></tr></table></figure>


<pre><code>2</code></pre><h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><p>列表元素的常用删除方法有：</p>
<ul>
<li><p>del：根据下标进行删除pop：</p>
</li>
<li><p>删除最后一个元素remove：</p>
</li>
<li><p>根据元素的值进行删除</p>
</li>
</ul>
<ol>
<li>del</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>]</span><br><span class="line"></span><br><span class="line">print(<span class="string">'------删除之前'</span>)</span><br><span class="line"><span class="keyword">for</span> tempName <span class="keyword">in</span> list1:</span><br><span class="line">    print(tempName)</span><br><span class="line"></span><br><span class="line">movieName=list1  </span><br><span class="line"><span class="keyword">del</span> movieName[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">print(<span class="string">'------ 删除之后 '</span>)</span><br><span class="line"><span class="keyword">for</span> tempName <span class="keyword">in</span> list1:</span><br><span class="line">    print(tempName)</span><br></pre></td></tr></table></figure>

<pre><code>------删除之前
a
b
c
d
e
f
------ 删除之后 
a
b
d
e
f</code></pre><ol start="2">
<li>pop</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list2 = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>]</span><br><span class="line"></span><br><span class="line">print(<span class="string">'------删除之前	'</span>)</span><br><span class="line"><span class="keyword">for</span> tempName <span class="keyword">in</span> list2:</span><br><span class="line">    print(tempName)</span><br><span class="line"></span><br><span class="line">movieName=list2  </span><br><span class="line">movieName.pop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(<span class="string">'------删除之后	'</span>)</span><br><span class="line"><span class="keyword">for</span> tempName <span class="keyword">in</span> list2:</span><br><span class="line">    print(tempName)</span><br></pre></td></tr></table></figure>

<pre><code>------删除之前    
a
b
c
d
e
f
------删除之后    
a
b
c
d
e</code></pre><ol start="3">
<li>remove</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list2 = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>]</span><br><span class="line"></span><br><span class="line">print(<span class="string">'------删除之前	'</span>)</span><br><span class="line"><span class="keyword">for</span> tempName <span class="keyword">in</span> list2:</span><br><span class="line">    print(tempName)</span><br><span class="line"></span><br><span class="line">movieName=list2  </span><br><span class="line">movieName.remove(<span class="string">'e'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(<span class="string">'------删除之后	'</span>)</span><br><span class="line"><span class="keyword">for</span> tempName <span class="keyword">in</span> list2:</span><br><span class="line">    print(tempName)</span><br></pre></td></tr></table></figure>

<pre><code>------删除之前    
a
b
c
d
e
f
------删除之后    
a
b
c
d
f</code></pre><ol start="4">
<li><p>排序<br> sort 方法是将 list 按特定顺序重新排列，默认为由小到大，参数 reverse=True 可改为倒序，由大到小。</p>
<p>  reverse 方法是将 list 逆置。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">print(a)</span><br><span class="line">a.sort()</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>

<pre><code>[1, 4, 3, 2]
[1, 2, 3, 4]</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">print(a)</span><br><span class="line">a.reverse()</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>

<pre><code>[1, 4, 3, 2]
[2, 3, 4, 1]</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">print(a)</span><br><span class="line">print(<span class="string">'-----'</span>)</span><br><span class="line">a.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">print(a)</span><br><span class="line">print(<span class="string">'-----'</span>)</span><br><span class="line">a.sort(reverse=<span class="literal">False</span>)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>

<pre><code>[1, 4, 3, 2]
-----
[4, 3, 2, 1]
-----
[1, 2, 3, 4]</code></pre><h3 id="列表的遍历"><a href="#列表的遍历" class="headerlink" title="列表的遍历"></a>列表的遍历</h3><h4 id="使用for循环"><a href="#使用for循环" class="headerlink" title="使用for循环"></a>使用for循环</h4><p>为了更有效率的输出<strong>列表的每个数据</strong>，可以使用循环来完成</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">namesList = [<span class="string">'xiaoWang'</span>,<span class="string">'xiaoZhang'</span>,<span class="string">'xiaoHua'</span>] </span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> namesList:</span><br><span class="line">    print(name)</span><br></pre></td></tr></table></figure>

<pre><code>xiaoWang
xiaoZhang
xiaoHua</code></pre><h4 id="使用while循环"><a href="#使用while循环" class="headerlink" title="使用while循环"></a>使用while循环</h4><p>为了更有效率的输出<strong>列表的每个数据</strong>，可以使用循环来完成</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">namesList = [<span class="string">'xiaoWang'</span>,<span class="string">'xiaoZhang'</span>,<span class="string">'xiaoHua'</span>] </span><br><span class="line">lenth=len(namesList)</span><br><span class="line">i=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; lenth:</span><br><span class="line">    print(namesList[i])</span><br><span class="line">    i+=<span class="number">1</span></span><br></pre></td></tr></table></figure>

<pre><code>xiaoWang
xiaoZhang
xiaoHua</code></pre><h2 id="元组（tuple）"><a href="#元组（tuple）" class="headerlink" title="元组（tuple）"></a>元组（tuple）</h2><p>另一种有序列列表叫元组：tuple。 tuple和list非常类似，但是 tuple一旦初始化就不能修改，比如同样是列出同学的名字：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">classmates = (<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>)</span><br></pre></td></tr></table></figure>

<p>现在， classmates这个tuple不能变了，它也没有append()，insert( )这样的方法。其他获取元素的方法和list是一样的，你可以正常地使用 classmates[0] ， classmates[-1] ，但不能赋值成另外的元素。</p>
<p>不可变的tuple有什什么意义？因为tuple不不可变，所以代码更安全。如果可能，能用tuple代list就尽量用tuple。</p>
<p>如果要定义一个空的tuple，可以写成()：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t=()</span><br><span class="line">print(t,type(t))</span><br></pre></td></tr></table></figure>

<pre><code>() &lt;class &apos;tuple&apos;&gt;</code></pre><p>但是，要定义一个只有1个元素的tuple ，如果你这么定义：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t=(<span class="number">1</span>)</span><br><span class="line">print(t,type(t))</span><br></pre></td></tr></table></figure>

<pre><code>1 &lt;class &apos;int&apos;&gt;</code></pre><p>定义的不是tuple，是1这个数！这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这 就产生了了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是1。</p>
<p>所以，只有1个元素的tuple定义时必须加一个逗号，来消除歧义：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t=(<span class="number">1</span>,)</span><br><span class="line">print(t,type(t))</span><br></pre></td></tr></table></figure>

<pre><code>(1,) &lt;class &apos;tuple&apos;&gt;</code></pre><p>Python在显示只有1个元素的tuple时，也会加一个逗号，以免你误解成数学计算意义上的括号。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = (<span class="string">'a'</span>, <span class="string">'b'</span>, [<span class="string">'A'</span>, <span class="string">'B'</span>])</span><br><span class="line">t[<span class="number">2</span>][<span class="number">0</span>] = <span class="string">'X'</span></span><br><span class="line">t[<span class="number">2</span>][<span class="number">1</span>] = <span class="string">'Y'</span></span><br><span class="line">t</span><br></pre></td></tr></table></figure>


<pre><code>(&apos;a&apos;, &apos;b&apos;, [&apos;X&apos;, &apos;Y&apos;])</code></pre><p>最后来看一个<strong>“可变的”</strong>tuple</p>
<h2 id="字典（dict）"><a href="#字典（dict）" class="headerlink" title="字典（dict）"></a>字典（dict）</h2><h3 id="字典简介"><a href="#字典简介" class="headerlink" title="字典简介"></a>字典简介</h3><p>字典是另一种可变容器器模型，且可存储任意类型对象。</p>
<p>字典的每个键值(<strong>key=&gt;value</strong>)对用冒号(:)分割，每个对之间用逗号(,)分割，整个字典包括在花括号{}中</p>
<p>举个例子，假设要根据同学的名字查找对应的成绩，如果用 list 实现，需要两个 list ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">names &#x3D; [&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;]</span><br><span class="line">scores &#x3D; [95, 75, 85]</span><br></pre></td></tr></table></figure>

<p>给定一个名字，要查找对应的成绩，就先要在 names 中找到对应的位置，再从 scores 取出对应的成绩， list 越长，耗时越长。</p>
<p>如果用 dict 实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大， 查找速度都不不会变慢。用Python写一个 dict 如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">'Michael'</span>: <span class="number">95</span>, <span class="string">'Bob'</span>: <span class="number">75</span>, <span class="string">'Tracy'</span>: <span class="number">85</span>&#125;</span><br><span class="line">d[<span class="string">'Michael'</span>]</span><br></pre></td></tr></table></figure>


<pre><code>95</code></pre><p>由于一个 key 只能对应⼀一个 value ，所以，多次对一个 key 放入 value ，后面的值会把前面的值冲掉：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d[<span class="string">'Ryan'</span>]=<span class="number">100</span></span><br><span class="line">d[<span class="string">'Ryan'</span>]</span><br></pre></td></tr></table></figure>


<pre><code>100</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d[<span class="string">'Ryan'</span>]=<span class="number">99</span></span><br><span class="line">d[<span class="string">'Ryan'</span>]</span><br></pre></td></tr></table></figure>


<pre><code>99</code></pre><p>如果key不不存在，dict就会报错：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d[<span class="string">'Thomas'</span>]</span><br></pre></td></tr></table></figure>


<pre><code>---------------------------------------------------------------------------

KeyError                                  Traceback (most recent call last)

&lt;ipython-input-40-bf27a9c462ee&gt; in &lt;module&gt;()
----&gt; 1 d[&apos;Thomas&apos;]



KeyError: &apos;Thomas&apos;</code></pre><h3 id="字典的常见操作"><a href="#字典的常见操作" class="headerlink" title="字典的常见操作"></a>字典的常见操作</h3><h4 id="修改元素-1"><a href="#修改元素-1" class="headerlink" title="修改元素"></a>修改元素</h4><p>字典的每个元素中的数据是可以修改的，只要通过 key 找到，即可修改</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">info = &#123;<span class="string">'name'</span>:<span class="string">'kkb'</span>, <span class="string">'id'</span>:<span class="number">100</span>, <span class="string">'sex'</span>:<span class="string">'f'</span>, <span class="string">'address'</span>:<span class="string">'中国北北京'</span>&#125;</span><br><span class="line">new_id = input(<span class="string">'请输入新的学号:'</span>)</span><br><span class="line">info[<span class="string">'id'</span>] = int(new_id)</span><br><span class="line">print(<span class="string">'修改之后的id为: %d'</span> % info[<span class="string">'id'</span>])</span><br></pre></td></tr></table></figure>

<pre><code>请输入新的学号:12
修改之后的id为: 12</code></pre><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><ol>
<li>访问不不存在的元素</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">info = &#123;<span class="string">'name'</span>:<span class="string">'kkb'</span>, <span class="string">'sex'</span>:<span class="string">'f'</span>, <span class="string">'address'</span>:<span class="string">'中国北北京'</span>&#125;</span><br><span class="line">print(<span class="string">'id为:%d'</span> % info[<span class="string">'id'</span>])</span><br></pre></td></tr></table></figure>


<pre><code>---------------------------------------------------------------------------

KeyError                                  Traceback (most recent call last)

&lt;ipython-input-43-0f8e22620be6&gt; in &lt;module&gt;()
      1 #访问不不存在的元素
      2 info = {&apos;name&apos;:&apos;kkb&apos;, &apos;sex&apos;:&apos;f&apos;, &apos;address&apos;:&apos;中国北北京&apos;}
----&gt; 3 print(&apos;id为:%d&apos; % info[&apos;id&apos;])



KeyError: &apos;id&apos;</code></pre><p>如果在使用变量量名[‘键’] = 数据 时，这个“键”在字典中，不存在，那么就会新增这个元素。</p>
<ol start="2">
<li>添加新的元素</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">info = &#123;<span class="string">'name'</span>:<span class="string">'kkb'</span>, <span class="string">'sex'</span>:<span class="string">'f'</span>, <span class="string">'address'</span>:<span class="string">'中国北北京'</span>&#125;</span><br><span class="line"><span class="comment"># print('id为:%d'%info['id'])#程序会终端运⾏行行，因为访问了了不不存在的键</span></span><br><span class="line">newId = input(<span class="string">'请输入新的学号：'</span>)</span><br><span class="line">info[<span class="string">'id'</span>] =int(newId)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'添加之后的id为:%d'</span> % info[<span class="string">'id'</span>])</span><br></pre></td></tr></table></figure>

<pre><code>请输入新的学号：345
添加之后的id为:345</code></pre><ol start="3">
<li>删除元素<br> 对字典进行删除操作，有以一下几种：</li>
</ol>
<ul>
<li>del</li>
<li>clear()</li>
</ul>
<p><strong>del删除指定的元素</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">info = &#123;<span class="string">'name'</span>:<span class="string">'kkb'</span>, <span class="string">'sex'</span>:<span class="string">'f'</span>, <span class="string">'address'</span>:<span class="string">'中国北北京'</span>&#125;</span><br><span class="line"></span><br><span class="line">print(<span class="string">'删除前,%s'</span> % info[<span class="string">'name'</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> info[name]</span><br><span class="line"></span><br><span class="line">print(<span class="string">'删除后,%s'</span> % info[<span class="string">'name'</span>])</span><br><span class="line"><span class="comment">#删除后不存在name字段</span></span><br></pre></td></tr></table></figure>

<pre><code>删除前,kkb


---------------------------------------------------------------------------

KeyError                                  Traceback (most recent call last)

&lt;ipython-input-55-02d163400996&gt; in &lt;module&gt;()
      3 print(&apos;删除前,%s&apos; % info[&apos;name&apos;])
      4 
----&gt; 5 del info[name]
      6 
      7 print(&apos;删除后,%s&apos; % info[&apos;name&apos;])



KeyError: &apos;xiaoHua&apos;</code></pre><p><strong>del删除整个字典</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">info &#x3D; &#123;&#39;name&#39;:&#39;monitor&#39;, &#39;sex&#39;:&#39;f&#39;, &#39;address&#39;:&#39;China&#39;&#125;</span><br><span class="line">print(&#39;删除前,%s&#39; % info)</span><br><span class="line">del info</span><br><span class="line">print(&#39;删除后,%s&#39; % info)</span><br></pre></td></tr></table></figure>

<p><strong>clear清空整个字典</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">info &#x3D; &#123;&#39;name&#39;:&#39;monitor&#39;, &#39;sex&#39;:&#39;f&#39;, &#39;address&#39;:&#39;China&#39;&#125;</span><br><span class="line">print(&#39;清空前,%s&#39; % info)</span><br><span class="line">info.clear()</span><br><span class="line">print(&#39;删除后,%s&#39; % info)</span><br></pre></td></tr></table></figure>

<p><strong>keys</strong></p>
<p>返回一个包含字典所有key的列列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d1 = &#123;<span class="string">'name'</span>:<span class="string">'abc'</span>,<span class="string">'age'</span>:<span class="string">'18'</span>, <span class="string">'class'</span>:<span class="string">'cnh'</span>&#125; </span><br><span class="line">print(list(d1.keys()))</span><br></pre></td></tr></table></figure>

<pre><code>[&apos;name&apos;, &apos;age&apos;, &apos;class&apos;]</code></pre><p><strong>values</strong></p>
<p>返回一个包含字典所有value的列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d1 = &#123;<span class="string">'name'</span>:<span class="string">'abc'</span>,<span class="string">'age'</span>:<span class="string">'18'</span>, <span class="string">'class'</span>:<span class="string">'cnh'</span>&#125; </span><br><span class="line">print(list(d1.values()))</span><br></pre></td></tr></table></figure>

<pre><code>[&apos;abc&apos;, &apos;18&apos;, &apos;cnh&apos;]</code></pre><p><strong>items</strong><br>返回一个包含<strong>所有（值，键）</strong>元祖的列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d1 = &#123;<span class="string">'name'</span>:<span class="string">'abc'</span>,<span class="string">'age'</span>:<span class="string">'18'</span>, <span class="string">'class'</span>:<span class="string">'cnh'</span>&#125; </span><br><span class="line">print(list(d1.items()))</span><br></pre></td></tr></table></figure>

<pre><code>[(&apos;name&apos;, &apos;abc&apos;), (&apos;age&apos;, &apos;18&apos;), (&apos;class&apos;, &apos;cnh&apos;)]</code></pre><h2 id="集合（set）"><a href="#集合（set）" class="headerlink" title="集合（set）"></a>集合（set）</h2><p>集合（set）是一个无序的<strong>不重复元素</strong>序列。<br>可以使用大括号 { } 或者 set() 函数创建集合，注意：创建一个空集合必须用 set() 而不不是 { }，因为 { }是用来创建⼀一个空字典。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_set = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="string">'abc'</span>, <span class="string">'hello'</span>&#125;</span><br><span class="line"><span class="comment"># 不支持下标赋值和取值</span></span><br><span class="line"><span class="comment"># my_set[0] = 3</span></span><br><span class="line"><span class="comment"># value = my_set[0] # print(value)</span></span><br><span class="line"><span class="comment"># print(value)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#支持通过遍历获取数据</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> my_set:</span><br><span class="line">    print(value)</span><br></pre></td></tr></table></figure>

<pre><code>1
hello
4
abc</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_set2=&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>&#125;</span><br><span class="line"><span class="keyword">for</span> index,value <span class="keyword">in</span> enumerate(my_set2):</span><br><span class="line">    print(index,value)</span><br></pre></td></tr></table></figure>

<pre><code>0 1
1 4
2 7</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义空的集合的时候不能直接使用&#123;&#125;</span></span><br><span class="line">my_set = set()</span><br><span class="line">my_set.add(<span class="number">1</span>) </span><br><span class="line">my_set.add(<span class="number">1</span>)</span><br><span class="line">print(my_set, type(my_set))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 集合可以对容器器类型数据去重</span></span><br><span class="line">my_list = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment"># 把列列表转成集合，会把数据去重</span></span><br><span class="line">my_set = set(my_list)</span><br><span class="line">print(my_set)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列列表，元组， 集合 三者之间可以相互转换</span></span><br><span class="line">my_tuple = (<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">print(my_tuple, type(my_tuple))</span><br></pre></td></tr></table></figure>

<pre><code>{1} &lt;class &apos;set&apos;&gt;
{1, 3, 5}
(5, 3) &lt;class &apos;tuple&apos;&gt;</code></pre>]]></content>
      <categories>
        <category>data analytics</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>3. 分散性与变异性的量度</title>
    <url>/2020/01/20/3.%20%E5%88%86%E6%95%A3%E6%80%A7%E4%B8%8E%E5%8F%98%E5%BC%82%E6%80%A7%E7%9A%84%E9%87%8F%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="分散性"><a href="#分散性" class="headerlink" title="分散性"></a>分散性</h1><h2 id="量度全距"><a href="#量度全距" class="headerlink" title="量度全距"></a>量度全距</h2><p>极差，用于量度数据集分散程度的方法。</p>
<p>$全距=上界-下界$即$=MAX-MIN$</p>
<blockquote>
<p>全距很容易受异常值影响</p>
</blockquote>
<p><img src="/2020/01/20/3.%20%E5%88%86%E6%95%A3%E6%80%A7%E4%B8%8E%E5%8F%98%E5%BC%82%E6%80%A7%E7%9A%84%E9%87%8F%E5%BA%A6/image20191210140221531.png" alt="image-20191210140221531"></p>
<h2 id="四分位数"><a href="#四分位数" class="headerlink" title="四分位数"></a>四分位数</h2><p><img src="/2020/01/20/3.%20%E5%88%86%E6%95%A3%E6%80%A7%E4%B8%8E%E5%8F%98%E5%BC%82%E6%80%A7%E7%9A%84%E9%87%8F%E5%BA%A6/image20191210140431884.png" alt="image-20191210140431884"></p>
<p>构建迷你距的一个办法是:仅使用数据中心周边的数值。</p>
<a id="more"></a>

<ul>
<li>升序排列数据</li>
<li>分成相等四个数据块</li>
</ul>
<p><strong>四分位数的计算</strong>：</p>
<ul>
<li>中位数同上</li>
<li>下四分位数<ul>
<li>$\frac{n}{4}$若为整数取这个数及下个数平均值</li>
<li>$\frac{n}{4}$不是整数，向上取整</li>
</ul>
</li>
<li>上四分位数<ul>
<li>计算$\frac{3n}{4}$判断</li>
</ul>
</li>
</ul>
<h3 id="四分位距"><a href="#四分位距" class="headerlink" title="四分位距"></a>四分位距</h3><p><img src="/2020/01/20/3.%20%E5%88%86%E6%95%A3%E6%80%A7%E4%B8%8E%E5%8F%98%E5%BC%82%E6%80%A7%E7%9A%84%E9%87%8F%E5%BA%A6/image20191210141228977.png" alt="image-20191210141228977"></p>
<p>$$四分位距=上四分位数一下四分位数 $$</p>
<ul>
<li>与全距相比,较少受到异常值的影响。</li>
</ul>
<h2 id="百分位数"><a href="#百分位数" class="headerlink" title="百分位数"></a>百分位数</h2><p><img src="/2020/01/20/3.%20%E5%88%86%E6%95%A3%E6%80%A7%E4%B8%8E%E5%8F%98%E5%BC%82%E6%80%A7%E7%9A%84%E9%87%8F%E5%BA%A6/image20191210141250132.png" alt="image-20191210141250132"></p>
<p>若数据被分成10份,因此起分割作用的数值被称为十分位数。 我们可以用百分位数构建一个新的距,称为<strong>百分位距</strong>。</p>
<p><strong>百分位数的计算</strong>：</p>
<ul>
<li>升序</li>
<li>$$k\frac{n}{100}$$其中$k$为第$k$百分位数</li>
<li>判断计算</li>
</ul>
<h3 id="箱线图绘制各种“距”"><a href="#箱线图绘制各种“距”" class="headerlink" title="箱线图绘制各种“距”"></a>箱线图绘制各种“距”</h3><p><img src="/2020/01/20/3.%20%E5%88%86%E6%95%A3%E6%80%A7%E4%B8%8E%E5%8F%98%E5%BC%82%E6%80%A7%E7%9A%84%E9%87%8F%E5%BA%A6/image20191210141530933.png" alt="image-20191210141530933"></p>
<blockquote>
<p>以上利用分散性看到稳定程度，同时也希望看到数据的变异性</p>
</blockquote>
<h1 id="变异性"><a href="#变异性" class="headerlink" title="变异性"></a>变异性</h1><h2 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h2><p>量度数据变异性的方法</p>
<p>$方差=\frac{\sum(x-\mu)^2}{n}$</p>
<p>方差是数据值与均值的距离的平方数的平均值</p>
<blockquote>
<p><strong>快速计算方法</strong>$方差=\frac{\sum x^2}{n}-\mu^2$</p>
</blockquote>
<h2 id="标准差"><a href="#标准差" class="headerlink" title="标准差"></a>标准差</h2><p>不用距离的平方来指出分散性</p>
<p>$\sigma=\sqrt{方差}=\sqrt{\frac{\sum(x-\mu)^2}{n}}$</p>
<h2 id="标准分"><a href="#标准分" class="headerlink" title="标准分"></a>标准分</h2><p><img src="/2020/01/20/3.%20%E5%88%86%E6%95%A3%E6%80%A7%E4%B8%8E%E5%8F%98%E5%BC%82%E6%80%A7%E7%9A%84%E9%87%8F%E5%BA%A6/image20191210143601097.png" alt="image-20191210143601097"></p>
<p><strong>特定数据值的标准分</strong></p>
<p>$z=\frac{x-\mu}{\sigma}$</p>
<p>$\mu,\sigma$为数据所在数据集的均值，标准差</p>
<h3 id="标准分的作用"><a href="#标准分的作用" class="headerlink" title="标准分的作用"></a>标准分的作用</h3><p><img src="/2020/01/20/3.%20%E5%88%86%E6%95%A3%E6%80%A7%E4%B8%8E%E5%8F%98%E5%BC%82%E6%80%A7%E7%9A%84%E9%87%8F%E5%BA%A6/image20191210144156051.png" alt="image-20191210144156051"></p>
<ul>
<li><p>用于对比不用数据集的数据，他将数据转化为通用的新分布形态，新的分布均值为0，标准差为1</p>
</li>
<li><p><img src="/2020/01/20/3.%20%E5%88%86%E6%95%A3%E6%80%A7%E4%B8%8E%E5%8F%98%E5%BC%82%E6%80%A7%E7%9A%84%E9%87%8F%E5%BA%A6/image20191210144331623.png" alt="image-20191210144331623"></p>
</li>
<li><p>用距离均值若干个标准差表示某个特定数值的相对位置</p>
</li>
</ul>
]]></content>
      <categories>
        <category>data analytics</category>
      </categories>
      <tags>
        <tag>《深入浅出统计学》</tag>
      </tags>
  </entry>
  <entry>
    <title>10. 统计抽样的运用</title>
    <url>/2020/01/20/10.%20%E7%BB%9F%E8%AE%A1%E6%8A%BD%E6%A0%B7%E7%9A%84%E8%BF%90%E7%94%A8/</url>
    <content><![CDATA[<h2 id="总体与样本"><a href="#总体与样本" class="headerlink" title="总体与样本"></a>总体与样本</h2><p><strong>总体</strong>：进行测量，研究或者分析的整个群体。</p>
<p>普查：堆总体进行的研究或调查。</p>
<p><strong>样本</strong>：总体中选取的部分对象。</p>
<p>样本调查：对总体样本进行研究或调查</p>
<h2 id="设计抽样"><a href="#设计抽样" class="headerlink" title="设计抽样"></a>设计抽样</h2><ol>
<li>确定目标总体</li>
<li>确定抽样单位<br>抽取哪一类对象</li>
<li>确定抽样空间<br>编号好的抽样单位汇总表，可以选中样本</li>
</ol>
<a id="more"></a>

<h2 id="抽样偏倚"><a href="#抽样偏倚" class="headerlink" title="抽样偏倚"></a>抽样偏倚</h2><h3 id="无偏样本"><a href="#无偏样本" class="headerlink" title="无偏样本"></a>无偏样本</h3><p>可以代表目标总体，具有相似特性</p>
<p><img src="/2020/01/20/10.%20%E7%BB%9F%E8%AE%A1%E6%8A%BD%E6%A0%B7%E7%9A%84%E8%BF%90%E7%94%A8/image-20200108134955794.png" alt="image-20200108134955794"></p>
<h3 id="偏倚样本"><a href="#偏倚样本" class="headerlink" title="偏倚样本"></a>偏倚样本</h3><p>无法代表总体，特性不相似</p>
<p><img src="/2020/01/20/10.%20%E7%BB%9F%E8%AE%A1%E6%8A%BD%E6%A0%B7%E7%9A%84%E8%BF%90%E7%94%A8/image-20200108135029859.png" alt="image-20200108135029859"></p>
<h3 id="偏倚产生的原因"><a href="#偏倚产生的原因" class="headerlink" title="偏倚产生的原因"></a>偏倚产生的原因</h3><ol>
<li>抽样空间条目不齐全，未包含总体的所有对象</li>
<li>抽样单位不正确</li>
<li>为样本选取的一个个抽样单位未出现在实际样本中（并不是人人给你的问卷回应）</li>
<li>问题设计不当</li>
<li>缺乏随机性</li>
</ol>
<p>==归咎与样本选取方法==</p>
<h2 id="抽样方法"><a href="#抽样方法" class="headerlink" title="抽样方法"></a>抽样方法</h2><ul>
<li><strong>简单随机抽样</strong>：通过随机过程选取一个大小为n的样本，所有大小为n的可能样本被选中为可能性相同<ul>
<li>重复抽样：选取一个抽样单位，再将这个单位放回总体</li>
<li>不重复抽样：不将抽样单位放回总体</li>
</ul>
</li>
<li><strong>分层抽样</strong>：将总体分割为几个相似的组，每个组具有类似的特征，每组称为==层==</li>
<li><strong>整群抽样</strong>：总体中包括大量相似的组或群，对<strong>群或组</strong>进行简单随机抽样</li>
<li><strong>系统抽样</strong>：按某中顺序列出总体名单，没k个单位进行一次调查，其中k为一个特殊数字<em>（缺点：若总体存在某种循环，样本将会偏倚）</em></li>
</ul>
]]></content>
      <categories>
        <category>data analytics</category>
      </categories>
      <tags>
        <tag>《深入浅出统计学》</tag>
      </tags>
  </entry>
  <entry>
    <title>4. python函数</title>
    <url>/2020/01/20/4.%20python%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="函数的简介"><a href="#函数的简介" class="headerlink" title="函数的简介"></a>函数的简介</h2><p>如果在开发程序时，需要某块代码多次，但是为了提高编写的效率以及代码的重用，所以把具有独立功能的代码块组织为一个小模块，这就是函数。你已经知道Python提供了许多内建函数，比如print()。但你也可以自己创建函数，这被叫做用户自定义函数。</p>
<p>例如：我们知道圆的面积计算公式为：$S = πr^2$</p>
<p>当我们知道半径r的值时，就可以根据公式计算出面积。假设我们需要计算3个不同大小的圆的面积：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">r1 &#x3D; 12.34</span><br><span class="line">r2 &#x3D; 9.08</span><br><span class="line">r3 &#x3D; 73.1</span><br><span class="line">s1 &#x3D; 3.14 * r1 * r1 s2 &#x3D; 3.14 * r2 * r2 s3 &#x3D; 3.14 * r3 * r3</span><br></pre></td></tr></table></figure>

<p>当代码出现有规律的重复的时候，你就需要当心了，每次写3.14 * x * x不仅很麻烦，而且，如果要把3.14改成3.14159265359的时候，得全部替换。</p>
<p>有了函数，我们就不再每次写s = 3.14 * x * x，而是写成更有意义的函数调用s = area_of_circle(x)， 而函数area_of_circle本身只需要写一次，就可以多次调用。</p>
<p>基本上所有的高级语言都支持函数，Python也不例外。Python不但能非常灵活地定义函数，而且本身内置了很多有用的函数，可以直接调用。</p>
<a id="more"></a>

<h2 id="函数定义和调用"><a href="#函数定义和调用" class="headerlink" title="函数定义和调用"></a>函数定义和调用</h2><h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def 函数名(): 代码</span><br><span class="line"># 定义一个函数，能够完成打印信息的功能</span><br><span class="line">def printInfo():</span><br><span class="line">print(&#39;	&#39;)</span><br><span class="line">print(&#39;	人生苦短，我用Python&#39;)</span><br><span class="line">print(&#39;	&#39;)</span><br></pre></td></tr></table></figure>

<h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><p>定义了函数之后，就相当于有了一个具有某些功能的代码，想要让这些代码能够执行，需要调用它调用函数很简单的，通过 函数名() 即可完成调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 定义完函数后，函数是不会自动执行的，需要调用它才可以</span><br><span class="line">printInfo()</span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong></p>
<ul>
<li>每次调用函数时，函数都会从头开始执行，当这个函数中的代码执行完毕后，意味着调用结束了  </li>
<li>当然了如果函数中执行到了return也会结束函数</li>
</ul>
<h2 id="函数的文档说明"><a href="#函数的文档说明" class="headerlink" title="函数的文档说明"></a>函数的文档说明</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    <span class="string">'''用来完成对2个数求和'''</span></span><br><span class="line">    print(<span class="string">"%d"</span>%(a+b))</span><br><span class="line"></span><br><span class="line">test(<span class="number">11</span>,<span class="number">22</span>) </span><br><span class="line"></span><br><span class="line">help(test)</span><br></pre></td></tr></table></figure>

<pre><code>33
Help on function test in module __main__:

test(a, b)
    用来完成对2个数求和</code></pre><p>还可以用test. doc 直接查看文档说明</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    <span class="string">"用来完成对2个数求和"</span></span><br><span class="line">    print(<span class="string">"%d"</span>%(a+b))</span><br><span class="line"></span><br><span class="line">    print(test. doc )</span><br></pre></td></tr></table></figure>

<p>来完成对两个数的求和</p>
<h2 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h2><p>Python的函数定义非常简单，但灵活度却非常大。除了正常定义的必选参数外，还可以使用默认参数、可变参数和关   键字参数，使得函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码。</p>
<h3 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h3><p>我们先写一个计算x^2 的函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">power</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * x</span><br></pre></td></tr></table></figure>

<p>对于power(x)函数，参数x就是一个位置参数。<br>当我们调用power函数时，必须传入有且仅有的一个<strong>参数x</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">power(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>




<pre><code>25</code></pre><p>现在，如果我们要计算$x^3$怎么办？可以再定义一个power3函数，但是如果要计算 $x^4$ 、 $x^5$ ……怎么办？我们不可能定义无限多个函数。<br>你也许想到了，可以把power(x)修改为power(x, n)，用来计$x^n$ ，说干就干：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">power</span><span class="params">(x, n)</span>:</span> </span><br><span class="line">    s = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        n = n - <span class="number">1</span> </span><br><span class="line">        s = s * x</span><br><span class="line">    <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>

<p>对于这个修改后的power(x, n)函数，可以计算任意n次方：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">power(<span class="number">5</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>


<pre><code>25</code></pre><p>修改后的power(x, n)函数有两个参数：x和n，这两个参数都是位置参数，调用函数时，传入的两个值按照位置顺序依次赋给参数x和n。</p>
<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>新的power(x, n)函数定义没有问题，但是，旧的调用代码失败了，原因是我们增加了一个参数，导致旧的代码因为缺少一个参数而无法正常调用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">power(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>


<pre><code>---------------------------------------------------------------------------

TypeError                                 Traceback (most recent call last)

&lt;ipython-input-89-4cd340f296c6&gt; in &lt;module&gt;()
----&gt; 1 power(5)


TypeError: power() missing 1 required positional argument: &apos;n&apos;</code></pre><p>Python的错误信息很明确：调用函数power()缺少了一个位置参数n。<br>这个时候，默认参数就排上用场了。由于我们经常计算 x^2 ，所以，完全可以把第二个参数n的默认值设定为2：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">power</span><span class="params">(x, n=<span class="number">2</span>)</span>:</span> </span><br><span class="line">    s = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        n = n - <span class="number">1</span> </span><br><span class="line">        s = s * x</span><br><span class="line">    <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>

<p>这样，当我们调用power(5)时，相当于调用power(5, 2)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">power(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>


<pre><code>25</code></pre><p>而对于n &gt; 2的其他情况，就必须明确地传入n，比如power(5, 3)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">power(<span class="number">5</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>


<pre><code>125</code></pre><p>从上面的例子可以看出，默认参数可以简化函数的调用。设置默认参数时，有几点要注意： </p>
<ul>
<li>一是必选参数在前，默认参数在后，否则Python的解释器会报错；</li>
<li>二是当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。</li>
</ul>
<h3 id="使用默认参数有什么好处？"><a href="#使用默认参数有什么好处？" class="headerlink" title="使用默认参数有什么好处？"></a>使用默认参数有什么好处？</h3><p>举个例子，我们写个一年级小学生注册的函数，需要传入name和gender两个参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">enroll</span><span class="params">(name, gender)</span>:</span> </span><br><span class="line">    print(<span class="string">'name:'</span>, name) </span><br><span class="line">    print(<span class="string">'gender:'</span>, gender)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 调用</span></span><br><span class="line">enroll(<span class="string">'张三'</span>,<span class="string">'M'</span>)</span><br></pre></td></tr></table></figure>

<pre><code>name: 张三
gender: M</code></pre><p>如果要继续传入年龄、城市等信息怎么办？这样会使得调用函数的复杂度大大增加。 我们可以把年龄和城市设为默认参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">enroll</span><span class="params">(name, gender,city=<span class="string">'amoy'</span>)</span>:</span> </span><br><span class="line">    print(<span class="string">'name:'</span>, name) </span><br><span class="line">    print(<span class="string">'gender:'</span>, gender)</span><br><span class="line">    print(<span class="string">'city:'</span>, city)</span><br><span class="line">    </span><br><span class="line">enroll(<span class="string">'李四'</span>,<span class="string">'F'</span>)</span><br></pre></td></tr></table></figure>

<pre><code>name: 李四
gender: F
city: amoy</code></pre><p>这样，大多数学生注册时不需要提供年龄和城市，只提供必须的两个参数,只有与默认参数不符的学生才需要提供额外的信息.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">enroll(<span class="string">'李四'</span>,<span class="string">'F'</span>,<span class="string">'chengdu'</span>)</span><br></pre></td></tr></table></figure>

<pre><code>name: 李四
gender: F
city: chengdu</code></pre><p>可见，默认参数降低了<strong>函数调用的难度</strong>，而一旦需要更复杂的调用时，又可以传递更多的参数来实现。无论是简单调用还是复杂调用，函数只需要定义一个。</p>
<p>有多个默认参数时，调用的时候，既可以按顺序提供默认参数，比如调用enroll(‘Bob’, ‘M’,  7)，意思是，除了name，gender这两个参数外，最后1个参数应用在参数age上，city参数由于没有提供，仍然使用默认值。</p>
<p>也可以不按顺序提供部分默认参数。当不按顺序提供部分默认参数时，需要把参数名写上。比如调用enroll(‘Adam’, ‘M’,  city=’Tianjin’)，意思是，city参数用传进去的值，其他默认参数继续使用默认值。</p>
<p><strong>注意</strong>：默认参数有个最大的坑，演示如下：</p>
<p>先定义一个函数，传入一个list，添加一个END再返回：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_end</span><span class="params">(L=[])</span>:</span> </span><br><span class="line">    L.append(<span class="string">'END'</span>)</span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line"></span><br><span class="line"><span class="comment">#调用</span></span><br><span class="line">add_end([<span class="number">1</span>,<span class="number">24</span>,<span class="number">4</span>])</span><br></pre></td></tr></table></figure>


<pre><code>[1, 24, 4, &apos;END&apos;]</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#默认参数调用的时候</span></span><br><span class="line">add_end()</span><br><span class="line">add_end()</span><br><span class="line">add_end()</span><br></pre></td></tr></table></figure>


<pre><code>[&apos;END&apos;, &apos;END&apos;, &apos;END&apos;, &apos;END&apos;]</code></pre><p>很多初学者很疑惑，默认参数是[]，但是函数似乎每次都“记住了”上次添加了’END’后的list。 原因解释如下：</p>
<p>Python函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L也是一个变量，它指向对象[]，  每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。</p>
<p>定义默认参数要牢记一点：<strong>默认参数必须指向不变对象！</strong></p>
<p>要修改上面的例子，我们可以用None这个不变对象来实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_end</span><span class="params">(L=None)</span>:</span> </span><br><span class="line">    <span class="keyword">if</span> L <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        L = []</span><br><span class="line">    L.append(<span class="string">'END'</span>) </span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line"><span class="comment">#调用</span></span><br><span class="line">add_end()</span><br><span class="line">add_end()</span><br><span class="line">add_end()</span><br></pre></td></tr></table></figure>


<pre><code>[&apos;END&apos;]</code></pre><p>为什么要设计str、None这样的不变对象呢？因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。</p>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>在Python函数中，还可以定义可变参数。顾名思义，可变参数就是传入的参数个数是可变的，可以是1个、2个到任意个，还可以是0个。<br>我们以数学题为例子，给定一组数字a，b，c……，请计算$a^2 + b^2 + c^2 +….$。</p>
<p>要定义出这个函数，我们必须确定输入的参数。由于参数个数不确定，我们首先想到可以把a，b，c……作为一个list或tuple传进来，这样，函数可以定义如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(numbers)</span>:</span> </span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">        sum = sum + n * n </span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line"></span><br><span class="line"><span class="comment">#调用</span></span><br><span class="line">calc([<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>])</span><br></pre></td></tr></table></figure>


<pre><code>35</code></pre><p>所以，我们把函数的参数改为可变参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(*numbers)</span>:</span> </span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">        sum = sum + n * n </span><br><span class="line">    <span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure>

<p>定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个号。在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">calc(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>


<pre><code>5</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">calc()</span><br></pre></td></tr></table></figure>


<pre><code>0</code></pre><p>如果已经有一个list或者tuple，要调用一个可变参数怎么办？可以这样做：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">calc(nums[<span class="number">0</span>], nums[<span class="number">1</span>], nums[<span class="number">2</span>])</span><br></pre></td></tr></table></figure>


<pre><code>14</code></pre><p>这种写法当然是可行的，问题是太繁琐，所以Python允许你在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">calc(*nums)</span><br></pre></td></tr></table></figure>


<pre><code>14</code></pre><p>*nums表示把nums这个list的所有元素作为可变参数传进去。这种写法相当有用，而且很常见。</p>
<h3 id="命名关键字参数"><a href="#命名关键字参数" class="headerlink" title="命名关键字参数"></a>命名关键字参数</h3><p>对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数。至于到底传入了哪些，就需要在函数内部通过kw检查。</p>
<p>仍以person()函数为例，我们希望检查是否有city和job参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, **kw)</span>:</span> </span><br><span class="line">    <span class="keyword">if</span> <span class="string">'city'</span> <span class="keyword">in</span> kw:<span class="comment"># 有city参数</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">'job'</span> <span class="keyword">in</span> kw:<span class="comment"># 有job参数</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    print(<span class="string">'name:'</span>, name, <span class="string">'age:'</span>, age, <span class="string">'other:'</span>, kw)</span><br></pre></td></tr></table></figure>

<p>但是调用者仍可以传入不受限制的关键字参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">person(<span class="string">'Jack'</span>, <span class="number">24</span>, city=<span class="string">'Beijing'</span>, addr=<span class="string">'Chaoyang'</span>, zipcode=<span class="number">123456</span>)</span><br></pre></td></tr></table></figure>

<pre><code>name: Jack age: 24 other: {&apos;city&apos;: &apos;Beijing&apos;, &apos;addr&apos;: &apos;Chaoyang&apos;, &apos;zipcode&apos;: 123456}</code></pre><p>如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义的函数如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, *, city, job)</span>:</span> </span><br><span class="line">    print(name, age, city, job)</span><br></pre></td></tr></table></figure>

<p>和关键字参数kw不同，命名关键字参数需要一个特殊分隔符<em>，</em>后面的参数被视为命名关键字参数。调用方式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">person(<span class="string">'Jack'</span>, <span class="number">24</span>, city=<span class="string">'Beijing'</span>, job=<span class="string">'Engineer'</span>)</span><br></pre></td></tr></table></figure>

<pre><code>Jack 24 Beijing Engineer</code></pre><p>如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, *args, city, job)</span>:</span></span><br><span class="line">    print(name, age, args, city, job)</span><br></pre></td></tr></table></figure>

<p>命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">person(<span class="string">'Jack'</span>, <span class="number">24</span>, <span class="string">'Beijing'</span>,<span class="string">'Engineer'</span>)</span><br></pre></td></tr></table></figure>


<pre><code>---------------------------------------------------------------------------

TypeError                                 Traceback (most recent call last)

&lt;ipython-input-17-7465e072842a&gt; in &lt;module&gt;()
----&gt; 1 person(&apos;Jack&apos;, 24, &apos;Beijing&apos;,&apos;Engineer&apos;)



TypeError: person() missing 2 required keyword-only arguments: &apos;city&apos; and &apos;job&apos;</code></pre><p>由于调用时缺少参数名city和job，Python解释器把这4个参数均视为位置参数，但person()函数仅接受2个位置参数。</p>
<p>命名关键字参数可以有缺省值，从而简化调用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, *, city=<span class="string">'Beijing'</span>, job)</span>:</span> </span><br><span class="line">    print(name, age, city, job)</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用默认值，调用时可以不用传入</span></span><br><span class="line">person(<span class="string">'Jack'</span>, <span class="number">24</span>, job=<span class="string">'Engineer'</span>)</span><br></pre></td></tr></table></figure>

<pre><code>Jack 24 Beijing Engineer</code></pre><p>使用命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个<em>作为特殊分隔符。如果缺少</em>，Python解释器将无法识别位置参数和命名关键字参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def person(name, age, city, job):</span><br><span class="line"></span><br><span class="line"># 缺少 *，city和job被视为位置参数 pass</span><br></pre></td></tr></table></figure>

<h3 id="参数组合"><a href="#参数组合" class="headerlink" title="参数组合"></a>参数组合</h3><p>在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：<strong>必选参数</strong>、<strong>默认参数</strong>、<strong>可变参数</strong>、<strong>命名关键字参数</strong>和<strong>关键字参数</strong>。</p>
<p>比如定义一个函数，包含上述若干种参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(a, b, c=<span class="number">0</span>, *args, **kw)</span>:</span></span><br><span class="line">    print(<span class="string">'a ='</span>, a, <span class="string">'b ='</span>, b, <span class="string">'c ='</span>, c, <span class="string">'args ='</span>, args, <span class="string">'kw ='</span>, kw)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">(a, b, c=<span class="number">0</span>, *, d, **kw)</span>:</span></span><br><span class="line">    print(<span class="string">'a ='</span>, a, <span class="string">'b ='</span>, b, <span class="string">'c ='</span>, c, <span class="string">'d ='</span>, d, <span class="string">'kw ='</span>, kw)</span><br><span class="line"></span><br><span class="line"><span class="comment">#调用</span></span><br><span class="line">f1(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<pre><code>a = 1 b = 2 c = 0 args = () kw = {}</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f1(<span class="number">1</span>,<span class="number">2</span>,c=<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<pre><code>a = 1 b = 2 c = 3 args = () kw = {}</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f1(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">'a'</span>,<span class="string">'b'</span>)</span><br></pre></td></tr></table></figure>

<pre><code>a = 1 b = 2 c = 3 args = (&apos;a&apos;, &apos;b&apos;) kw = {}</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f1(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">'a'</span>,<span class="string">'b'</span>,x=<span class="number">99</span>)</span><br></pre></td></tr></table></figure>

<pre><code>a = 1 b = 2 c = 3 args = (&apos;a&apos;, &apos;b&apos;) kw = {&apos;x&apos;: 99}</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f2(<span class="number">1</span>, <span class="number">2</span>, d=<span class="number">99</span>, ext=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<pre><code>a = 1 b = 2 c = 0 d = 99 kw = {&apos;ext&apos;: None}</code></pre><p>最神奇的是通过一个tuple和dict，你也可以调用上述函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">args = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">kw = &#123;<span class="string">'d'</span>: <span class="number">99</span>, <span class="string">'x'</span>: <span class="string">'#'</span>&#125;</span><br><span class="line">f1(*args, **kw)</span><br></pre></td></tr></table></figure>

<pre><code>a = 1 b = 2 c = 3 args = (4,) kw = {&apos;d&apos;: 99, &apos;x&apos;: &apos;#&apos;}</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">args = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">kw = &#123;<span class="string">'d'</span>: <span class="number">88</span>, <span class="string">'x'</span>: <span class="string">'#'</span>&#125;</span><br><span class="line">f2(*args, **kw)</span><br></pre></td></tr></table></figure>

<pre><code>a = 1 b = 2 c = 3 d = 88 kw = {&apos;x&apos;: &apos;#&apos;}</code></pre><p>所以，对于任意函数，都可以通过类似func(<em>args, *</em>kw)的形式调用它，无论它的参数是如何定义的。虽然可以组合多达5种参数，但不要同时使用太多的组合，否则函数接口的可理解性很差。</p>
<h2 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h2><h3 id="“返回值”介绍"><a href="#“返回值”介绍" class="headerlink" title="“返回值”介绍"></a>“返回值”介绍</h3><ul>
<li>现实生活中的场景:</li>
</ul>
<p>我给儿子10块钱，让他给我买包烟。这个例子中，10块钱是我给儿子的，就相当于调用函数时传递到参数，让儿子买烟这个事情最终的目标是，让他把烟给你带回来然后给你对么，此时烟就是返回值</p>
<ul>
<li>开发中的场景：</li>
</ul>
<p>定义了一个函数，完成了获取室内温度，想一想是不是应该把这个结果给调用者，只有调用者拥有了这个返回值，才能够根据当前的温度做适当的调整所谓“<strong>返回值</strong>”，就是程序中函数完成一件事情后，最后给调用者的结果</p>
<h3 id="带有返回值的函数"><a href="#带有返回值的函数" class="headerlink" title="带有返回值的函数"></a>带有返回值的函数</h3><p>想要在函数中把结果返回给调用者，需要在函数中使用return如下示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add2num</span><span class="params">(a, b)</span>:</span> </span><br><span class="line">c = a+b</span><br><span class="line"><span class="keyword">return</span> c</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def add2num(a, b): </span><br><span class="line">return a+b</span><br></pre></td></tr></table></figure>

<h3 id="保存函数的返回值"><a href="#保存函数的返回值" class="headerlink" title="保存函数的返回值"></a>保存函数的返回值</h3><p>在“买烟”的例子中，最后儿子给你烟时，你一定是从儿子手中接过来 对么，程序也是如此，如果一个函数返回了一个数据，那么想要用这个数据，那么就需要保存.</p>
<p>保存函数的返回值示例如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add2num</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line"><span class="comment">#调用函数，顺便保存函数的返回值 </span></span><br><span class="line"></span><br><span class="line">result = add2num(<span class="number">100</span>,<span class="number">98</span>)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>

<pre><code>198</code></pre><h3 id="如何返回多个值"><a href="#如何返回多个值" class="headerlink" title="如何返回多个值"></a>如何返回多个值</h3><h4 id="多个ruturn？"><a href="#多个ruturn？" class="headerlink" title="多个ruturn？"></a>多个ruturn？</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_nums</span><span class="params">()</span>:</span> </span><br><span class="line">    print(<span class="string">"---1---"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="comment"># 函数中下面的代码不会被执行，因为return除了能够将数据返回之外，还有一个隐藏的功能：结束函数</span></span><br><span class="line">    print(<span class="string">"---2---"</span>) </span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    print(<span class="string">"---3---"</span>)</span><br></pre></td></tr></table></figure>

<p><strong>总结1</strong>一个函数中可以有多个return语句，但是只要有一个return语句被执行到，那么这个函数就会结束了，因此后面的return没有什么用处 如果程序设计为如下，是可以的因为不同的场景下执行不同的return</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_nums</span><span class="params">(num)</span>:</span> </span><br><span class="line">    print(<span class="string">"---1---"</span>) </span><br><span class="line">    <span class="keyword">if</span> num == <span class="number">100</span>:</span><br><span class="line">        print(<span class="string">"---2---"</span>)</span><br><span class="line">        <span class="keyword">return</span> num+<span class="number">1</span> <span class="comment"># 函数中下面的代码不会被执行，因为return除了能够将数据返回之外，还有一个隐藏的功能：结束函数</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"---3---"</span>) </span><br><span class="line">        <span class="keyword">return</span> num+<span class="number">2</span></span><br><span class="line">    print(<span class="string">"---4---"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">result1 = create_nums(<span class="number">100</span>)</span><br><span class="line">print(result1) <span class="comment"># 打印101 </span></span><br><span class="line">result2 = create_nums(<span class="number">200</span>) </span><br><span class="line">print(result2) <span class="comment"># 打印202</span></span><br></pre></td></tr></table></figure>

<pre><code>---1---
---2---
101
---1---
---3---
202</code></pre><h4 id="一个函数返回多个数据的方式"><a href="#一个函数返回多个数据的方式" class="headerlink" title="一个函数返回多个数据的方式"></a>一个函数返回多个数据的方式</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">divid</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    shang = a//b </span><br><span class="line">    yushu = a%b</span><br><span class="line">    <span class="keyword">return</span> shang, yushu <span class="comment">#默认是元组</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">result = divid(<span class="number">5</span>, <span class="number">2</span>) </span><br><span class="line">print(result) <span class="comment"># 输 出 (2, 1)</span></span><br></pre></td></tr></table></figure>

<pre><code>(2, 1)</code></pre><p><strong>总结2</strong>： return后面可以是元组，列表、字典等，只要是能够存储多个数据的类型，就可以一次性返回多个数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function</span><span class="params">()</span>:</span></span><br><span class="line"><span class="comment"># return [1, 2, 3]</span></span><br><span class="line"><span class="comment"># return (1, 2, 3)</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">"num1"</span>: <span class="number">1</span>, <span class="string">"num2"</span>: <span class="number">2</span>, <span class="string">"num3"</span>: <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>

<p>如果return后面有多个数据，那么默认是元组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [1]: a &#x3D; 1, 2</span><br><span class="line"></span><br><span class="line">In [2]: a</span><br><span class="line"></span><br><span class="line">Out[2]: (1, 2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">In [3]:</span><br><span class="line"></span><br><span class="line">In [3]: b &#x3D; (1, 2)</span><br><span class="line"></span><br><span class="line">In [4]: b</span><br><span class="line"></span><br><span class="line">Out[4]: (1, 2)</span><br></pre></td></tr></table></figure>

<h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><p>在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是<strong>递归函数</strong>。</p>
<p>举个例子，我们来计算阶乘n! = 1 x 2 x 3 x … x n，用函数fact(n)表示，可以看出：</p>
<p>$fact(n) = n! = 1 x 2 x 3 x … x (n-1) x n = (n-1)! x n = fact(n-1) x n$</p>
<p>所以，fact(n)可以表示为n x fact(n-1)，只有n=1时需要特殊处理。于是，fact(n)用递归的方式写出来就是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> n * fact(n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fact(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>


<pre><code>2</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fact(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>


<pre><code>24</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fact(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>


<pre><code>1</code></pre><p>递归函数的<strong>优点</strong>是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。</p>
<p>使用递归函数需要<strong>注意</strong>防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fact(<span class="number">10000</span>)</span><br></pre></td></tr></table></figure>


<pre><code>---------------------------------------------------------------------------

RecursionError                            Traceback (most recent call last)

&lt;ipython-input-37-0b1842e84853&gt; in &lt;module&gt;()
----&gt; 1 fact(10000)



&lt;ipython-input-32-6cee500c0290&gt; in fact(n)
      2     if n==1:
      3         return 1
----&gt; 4     return n * fact(n - 1)



... last 1 frames repeated, from the frame below ...



&lt;ipython-input-32-6cee500c0290&gt; in fact(n)
      2     if n==1:
      3         return 1
----&gt; 4     return n * fact(n - 1)



RecursionError: maximum recursion depth exceeded in comparison</code></pre><p>解决递归调用栈溢出的方法是通过<strong>尾递归</strong>优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。</p>
<p><strong>尾递归</strong>是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。</p>
<p>上面的fact(n)函数由于return n * fact(n - 1)引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> fact_iter(n, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact_iter</span><span class="params">(num, product)</span>:</span> </span><br><span class="line">    <span class="keyword">if</span> num == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> product</span><br><span class="line">    <span class="keyword">return</span> fact_iter(num - <span class="number">1</span>, num * product)</span><br></pre></td></tr></table></figure>

<p>可以看到，return fact_iter(num - 1, num * product)仅返回递归函数本身，num - 1和num*product在函数调用前就会被计算，不影响函数调用。</p>
<p>尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。</p>
<p>遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化，所以，即使把上面的fact(n)函数改成尾递归方式，也会导致栈溢出<br><strong>小结</strong></p>
<ul>
<li><p>使用递归函数的优点是逻辑简单清晰，缺点是过深的调用会导致栈溢出。</p>
</li>
<li><p>针对尾递归优化的语言可以通过尾递归防止栈溢出。尾递归事实上和循环是等价的，没有循环语句的编程语言只能通过尾递归实现循环。</p>
</li>
<li><p>Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题。</p>
</li>
</ul>
<h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><ul>
<li>局部变量，就是在函数内部定义的变量。</li>
<li><strong>作用范围</strong>是这个函数内部，即只能在这个函数中使用，在函数的外部是不能使用的。因为其作用范围只是在自己的函数内部，所以不同的函数可以定义相同名字的局部变量（打个比方，把你、我是当做成函数，把局部变量理解为每个人手里的手机，你可有个iPhone8，我当然也可以有个iPhone8了， 互不相关）</li>
<li>局部变量的作用，为了临时保存数据需要在函数中定义变量来进行存储。</li>
<li>当函数调用时，局部变量被创建，当函数调用完成后这个变量就不能够使用了。函数调用时，局部变量被创建，当函数调用完成后这个变量就不能够使用了。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">()</span>:</span></span><br><span class="line"><span class="comment"># 局部变量</span></span><br><span class="line">    score = <span class="number">100</span></span><br><span class="line">    print(<span class="string">"分数:"</span>, score) </span><br><span class="line">show()</span><br></pre></td></tr></table></figure>

<pre><code>分数: 100</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(score)</span><br></pre></td></tr></table></figure>


<pre><code>---------------------------------------------------------------------------

NameError                                 Traceback (most recent call last)

&lt;ipython-input-41-4405d376f933&gt; in &lt;module&gt;()
----&gt; 1 print(score)



NameError: name &apos;score&apos; is not defined</code></pre><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>如果一个变量，既能在一个函数中使用，也能在其他的函数中使用，这样的变量就是<strong>全局变量</strong>。</p>
<p><strong>例如</strong>：有2个兄弟 各自都有手机，各自有自己的小秘密在手机里，不让另外一方使用（可以理解为<strong>局部变量</strong>）；但是家里的电话是2个兄弟都可以随便使用的（可以理解为<strong>全局变量</strong>）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义全局变量</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    print(a) <span class="comment"># 虽然没有定义变量a但是依然可以获取其数据</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    print(a) <span class="comment"># 虽然没有定义变量a但是依然可以获取其数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line"></span><br><span class="line">test1()</span><br><span class="line">test2()</span><br></pre></td></tr></table></figure>

<pre><code>100
100</code></pre><p><strong>总结</strong>:</p>
<ul>
<li>在函数外边定义的变量叫做全局变量</li>
<li>全局变量能够在所有的函数中进行访问</li>
</ul>
<h3 id="全局变量和局部变量名字相同问题"><a href="#全局变量和局部变量名字相同问题" class="headerlink" title="全局变量和局部变量名字相同问题"></a>全局变量和局部变量名字相同问题</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义全局变量</span></span><br><span class="line">a = <span class="number">100</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line"><span class="comment"># 定义局部变量</span></span><br><span class="line">    a = <span class="number">300</span></span><br><span class="line">    print(<span class="string">'---test1---%d'</span>%a)</span><br><span class="line">test1()</span><br><span class="line"><span class="comment">#修改</span></span><br><span class="line">a = <span class="number">200</span></span><br><span class="line">print(<span class="string">'修改后的%d'</span>%a)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'a = %d'</span>%a)</span><br><span class="line"></span><br><span class="line">test2()</span><br></pre></td></tr></table></figure>

<pre><code>---test1---300
修改后的200
a = 200</code></pre><p><strong>总结</strong>:</p>
<ul>
<li>当函数内出现局部变量和全局变量相同名字时，函数内部中的 变量名 = 数据 此时理解为定义了一个局部变量，而不是修改全局变量的值</li>
</ul>
<h3 id="修改全局变量"><a href="#修改全局变量" class="headerlink" title="修改全局变量"></a>修改全局变量</h3><p>函数中进行使用<strong>全局变量</strong>时可否进行修改呢？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义全局变量</span></span><br><span class="line">a = <span class="number">100</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line"><span class="comment"># 定义局部变量</span></span><br><span class="line">    <span class="keyword">global</span> a</span><br><span class="line">    print(<span class="string">'修改之前：%d'</span>%a)</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改</span></span><br><span class="line">a = <span class="number">200</span></span><br><span class="line">print(<span class="string">'修改后的%d'</span>%a)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'a = %d'</span>%a)</span><br><span class="line"></span><br><span class="line">test1() </span><br><span class="line">test2()</span><br></pre></td></tr></table></figure>

<pre><code>修改后的200
修改之前：200
a = 200</code></pre>]]></content>
      <categories>
        <category>data analytics</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>11. 总体和样本的估计</title>
    <url>/2020/01/20/11.%20%E6%80%BB%E4%BD%93%E5%92%8C%E6%A0%B7%E6%9C%AC%E7%9A%84%E4%BC%B0%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="点估计量估计总体参数"><a href="#点估计量估计总体参数" class="headerlink" title="点估计量估计总体参数"></a>点估计量估计总体参数</h2><p><img src="/2020/01/20/11.%20%E6%80%BB%E4%BD%93%E5%92%8C%E6%A0%B7%E6%9C%AC%E7%9A%84%E4%BC%B0%E8%AE%A1/image-20200108142318040.png" alt="image-20200108142318040"></p>
<p>样本的均值被称为总体均值的<strong>点估计量</strong></p>
<h3 id="均值"><a href="#均值" class="headerlink" title="均值"></a>均值</h3><ul>
<li><p>$\mu$为总体均值</p>
</li>
<li><p>$\hat{\mu}$为样本均值</p>
<p>$\hat{\mu}=\bar{x}=\frac{\sum x}{n}$</p>
</li>
</ul>
<h3 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h3><ul>
<li>总体方差 $\sigma^2=\frac{\sum(x-\mu)^2}{n}$</li>
<li>估计总体方差：$s^2=\hat{\sigma^2}=\frac{\sum(x-\bar{x})^2}{n}$</li>
</ul>
<a id="more"></a>

<h2 id="比例"><a href="#比例" class="headerlink" title="比例"></a>比例</h2><p>用X表示总体成功事件数量，X符合二项分布，n为总体中的人数，p为成功事件的比例</p>
<p>总体成功比例的点估计量$\hat{p}=P_s=\frac{成功数目}{样本数目}$</p>
<blockquote>
<p>计算上，概率与比例相同</p>
<p>p=probability(概率)=proportion(比例)</p>
</blockquote>
<h2 id="样本概率"><a href="#样本概率" class="headerlink" title="样本概率"></a>样本概率</h2><p>已知总体求样本概率</p>
<ol>
<li>查看与特定样本大小相同的所有样本</li>
<li>观察样本比例形成的分布，求出比例的期望和方差</li>
<li>利用分布求出概率</li>
</ol>
<blockquote>
<p>例：每盒有100颗糖，糖总体中25%为红色，求每盒100颗糖中40颗为红色概率为多少？</p>
<ul>
<li>X代表样本中红糖数目，则X~B$(n,p)$，其中n=100，p=0.25</li>
<li>样本中红糖比例取决与样本中红糖的数量X，比例本身为随机变量，记$P_s=\frac{X}{n}$</li>
</ul>
<p><img src="/2020/01/20/11.%20%E6%80%BB%E4%BD%93%E5%92%8C%E6%A0%B7%E6%9C%AC%E7%9A%84%E4%BC%B0%E8%AE%A1/image-20200113164134540.png" alt="image-20200113164134540"></p>
<p><img src="/2020/01/20/11.%20%E6%80%BB%E4%BD%93%E5%92%8C%E6%A0%B7%E6%9C%AC%E7%9A%84%E4%BC%B0%E8%AE%A1/image-20200113164147222.png" alt="image-20200113164147222"></p>
<p><img src="/2020/01/20/11.%20%E6%80%BB%E4%BD%93%E5%92%8C%E6%A0%B7%E6%9C%AC%E7%9A%84%E4%BC%B0%E8%AE%A1/image-20200113164225860.png" alt="image-20200113164225860"></p>
<ul>
<li>得出所有样本比例分布，称为<strong>比例的抽样分布</strong>，称为$P_s$分布</li>
</ul>
</blockquote>
<p>利用比例的抽样分布，求出某个随机选择的，大小为n的样本的<strong>“成功比例”的概率</strong>。</p>
<h3 id="P-s-的期望"><a href="#P-s-的期望" class="headerlink" title="$P_s$的期望"></a>$P_s$的期望</h3><p>$E(P_s)=E(\frac{X}{n})=\frac{E(X)}{n}$</p>
<ul>
<li>样本比例等于红球的数量除以样本糖球的总数</li>
</ul>
<p>由$E(X)=np$，故$E(P_s)=p$</p>
<h3 id="P-s-的方差"><a href="#P-s-的方差" class="headerlink" title="$P_s$的方差"></a>$P_s$的方差</h3><p>$Var(P_s)=Var(\frac{X}{n})=\frac{Var(X)}{n^2}$</p>
<p>$Var(X)=npq$</p>
<p>得到$Var(P_s)=\frac{pq}{n}$</p>
<p>$P_s$的标准差=比例标准误差=$\sqrt{\frac{pq}{n}}$</p>
<h3 id="P-s-的分布"><a href="#P-s-的分布" class="headerlink" title="$P_s$的分布"></a>$P_s$的分布</h3><p><img src="/2020/01/20/11.%20%E6%80%BB%E4%BD%93%E5%92%8C%E6%A0%B7%E6%9C%AC%E7%9A%84%E4%BC%B0%E8%AE%A1/image-20200113171713958.png" alt="image-20200113171713958"></p>
<p>==当n很大时，$P_s$的分布接近正态分布（n$\geqq$30），n越大越接近正态分布==</p>
<p>当n很大时，$P_s$~$N(p,\frac{pq}{n})$</p>
<ul>
<li>利用正态分布计算概率</li>
<li>需要对抽样分布进行连续性修正</li>
</ul>
<blockquote>
<p>连续性修正：</p>
<ul>
<li>用X表示样本中成功的数目，X的正态连续性修正为$\pm\frac{1}{2n}$</li>
<li>如果n很大，则可以忽略连续性修正</li>
</ul>
</blockquote>
<h2 id="样本均值的分布"><a href="#样本均值的分布" class="headerlink" title="样本均值的分布"></a>样本均值的分布</h2><blockquote>
<p>例：小袋糖果均值为10，方差为1</p>
</blockquote>
<ol>
<li><p>研究样本大小相同的所有可能样本</p>
</li>
<li><p>查看样本分布，样本均值的期望和方差</p>
</li>
<li><p>利用分布求出概率</p>
</li>
</ol>
<ul>
<li><p>取n包糖，$X_1,X_2,\dots,X_n$</p>
</li>
<li><p>每个$X_i$都是一个独立观察结果，期望为$\mu$，方差为$\sigma^2$</p>
<p>$\bar X=\frac{X_1+X_2+\dots+X_n}{n}$</p>
</li>
</ul>
<p>$\bar X$ 为均值的抽样分布，计算样本均值的概率方法</p>
<h3 id="bar-X-的期望"><a href="#bar-X-的期望" class="headerlink" title="$\bar X$ 的期望"></a>$\bar X$ 的期望</h3><p>$$E(\bar X)=E(\frac{X_1+X_2+\dots+X_n}{n})\\qquad =E(\frac{1}{n}X_1+\frac{1}{n}X_1X_2+\dots+\frac{1}{n}X_1X_n)\\qquad =\frac{1}{n}(E(X_1)+E(X_1)+E(X_2)+\dots+E(X_n))$$</p>
<p>由每个$X_i$都是一个独立观察值，且$E(X)=\mu$,即$$E(\bar X)=\mu$$</p>
<h3 id="bar-X-的方差"><a href="#bar-X-的方差" class="headerlink" title="$\bar X$ 的方差"></a>$\bar X$ 的方差</h3><p>同理可得：</p>
<p>$$Var(\bar X)=Var(\frac{X_1+X_2+\dots+X_n}{n})\\quad=(\frac{1}{n})^2(Var(X_1)+Var(X_2)+\dots+Var(X_n))\\quad =\frac{\sigma^2}{n}$$</p>
<p>$$均值标准误差=\frac{\sigma}{\sqrt n}$$</p>
<p><img src="/2020/01/20/11.%20%E6%80%BB%E4%BD%93%E5%92%8C%E6%A0%B7%E6%9C%AC%E7%9A%84%E4%BC%B0%E8%AE%A1/image-20200114100541065.png" alt="image-20200114100541065"></p>
<h3 id="bar-X-的分布"><a href="#bar-X-的分布" class="headerlink" title="$\bar X$ 的分布"></a>$\bar X$ 的分布</h3><ul>
<li>若X为正态分布，$\bar X$ 符合正态分布，即：</li>
</ul>
<p>X<del>$N(\mu,\sigma^2)$，则$\bar X$</del>$N(\mu,\frac{\sigma^2}{n})$</p>
<p><img src="/2020/01/20/11.%20%E6%80%BB%E4%BD%93%E5%92%8C%E6%A0%B7%E6%9C%AC%E7%9A%84%E4%BC%B0%E8%AE%A1/image-20200114100832825.png" alt="image-20200114100832825"></p>
<ul>
<li>若X不符合正态分布，当n很大的时候，$\bar X$仍用正态分布</li>
</ul>
<h2 id="中心极限定理"><a href="#中心极限定理" class="headerlink" title="中心极限定理"></a>中心极限定理</h2><p>如果从一个非正态总体X中取出一个样本，且样本很大，则$\bar X$的分布近似为正态分布，若总体的均值和方差为$\mu,\sigma^2$,且n很大，大于30，则：</p>
<p>$\bar X$~$$N(\mu,\frac{\sigma^2}{n})$$</p>
<h3 id="运用"><a href="#运用" class="headerlink" title="运用"></a>运用</h3><ol>
<li>二项分布</li>
</ol>
<ul>
<li>总体X~$B(n,p)$ 其中n&gt;30</li>
<li>$\mu=np$</li>
<li>$\sigma^2=npq$</li>
</ul>
<p>$\bar X$~$N(np,pq)$</p>
<ol start="2">
<li>泊松分布</li>
</ol>
<ul>
<li>总体 X~$Po(\lambda)$，其中n&gt;30</li>
<li>$\mu=\sigma^2=\lambda$</li>
</ul>
<p>$\bar X$~$N(\lambda,\frac{\lambda}{n})$</p>
<blockquote>
<p>利用正态分布表查找概率</p>
</blockquote>
]]></content>
      <categories>
        <category>data analytics</category>
      </categories>
      <tags>
        <tag>《深入浅出统计学》</tag>
      </tags>
  </entry>
  <entry>
    <title>5. excel图表</title>
    <url>/2020/01/20/5.%20excel%E5%9B%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="插入图表"><a href="#插入图表" class="headerlink" title="插入图表"></a>插入图表</h2><p><img src="/2020/01/20/5.%20excel%E5%9B%BE%E8%A1%A8/clipimage062.jpg" alt="img"> </p>
<a id="more"></a>

<h2 id="图表的坐标轴"><a href="#图表的坐标轴" class="headerlink" title="图表的坐标轴"></a>图表的坐标轴</h2><p><img src="/2020/01/20/5.%20excel%E5%9B%BE%E8%A1%A8/clipimage064.jpg" alt="img"> </p>
<h2 id="图表的次坐标轴"><a href="#图表的次坐标轴" class="headerlink" title="图表的次坐标轴"></a>图表的次坐标轴</h2><p><img src="/2020/01/20/5.%20excel%E5%9B%BE%E8%A1%A8/clipimage066.jpg" alt="img"></p>
]]></content>
      <categories>
        <category>data analytics</category>
      </categories>
      <tags>
        <tag>excel</tag>
      </tags>
  </entry>
  <entry>
    <title>12. 置信区间的构建</title>
    <url>/2020/01/20/12.%20%E7%BD%AE%E4%BF%A1%E5%8C%BA%E9%97%B4%E7%9A%84%E6%9E%84%E5%BB%BA/</url>
    <content><![CDATA[<p><strong>点估计有价值，但存在误差</strong></p>
<h2 id="置信区间"><a href="#置信区间" class="headerlink" title="置信区间"></a>置信区间</h2><p>不给出确定数值，指定两个数值（期望值介于中间）</p>
<p><img src="/2020/01/20/12.%20%E7%BD%AE%E4%BF%A1%E5%8C%BA%E9%97%B4%E7%9A%84%E6%9E%84%E5%BB%BA/image-20200114105053852.png" alt="image-20200114105053852"></p>
<p>若令区间包含总体均值的几率为95%，使得：$P(a&lt;\mu&lt;b)=0.95$</p>
<p>$(a,b)$称为<strong>置信区间</strong></p>
<h3 id="求解置信区间"><a href="#求解置信区间" class="headerlink" title="求解置信区间"></a>求解置信区间</h3><ol>
<li><p>选择总体统计量</p>
</li>
<li><p>求出统计量抽样分布<br>$E(\bar X)=\mu \qquad Var(\bar X)=\frac{\sigma^2}{n}=\frac{s^2}{n}$</p>
</li>
<li><p>决定置信水平<br>置信水平越高，区间越宽，置信区间包含总体统计量的几率越大</p>
</li>
<li><p>求出置信上下限</p>
</li>
</ol>
<a id="more"></a>

<p>   <img src="/2020/01/20/12.%20%E7%BD%AE%E4%BF%A1%E5%8C%BA%E9%97%B4%E7%9A%84%E6%9E%84%E5%BB%BA/image-20200114105943611.png" alt="image-20200114105943611"></p>
<p>   $\bar X$符合正态分布，$\bar X$~$N(\mu,0.25)$</p>
<ul>
<li>求出标准化正态分布Z</li>
<li>求出$z_a,z_b$</li>
</ul>
<p><img src="/2020/01/20/12.%20%E7%BD%AE%E4%BF%A1%E5%8C%BA%E9%97%B4%E7%9A%84%E6%9E%84%E5%BB%BA/image-20200114110350517.png" alt="image-20200114110350517"></p>
<h3 id="置信区间的简便算法"><a href="#置信区间的简便算法" class="headerlink" title="置信区间的简便算法"></a>置信区间的简便算法</h3><p><img src="/2020/01/20/12.%20%E7%BD%AE%E4%BF%A1%E5%8C%BA%E9%97%B4%E7%9A%84%E6%9E%84%E5%BB%BA/image-20200114110454895.png" alt="image-20200114110454895"></p>
<p><img src="/2020/01/20/12.%20%E7%BD%AE%E4%BF%A1%E5%8C%BA%E9%97%B4%E7%9A%84%E6%9E%84%E5%BB%BA/image-20200114110514744.png" alt="image-20200114110514744"></p>
<p>一般情况下</p>
<ul>
<li>统计量$\pm$(误差范围)</li>
</ul>
<p>误差范围等于c与检验统计量的标准差的乘积</p>
<ul>
<li>误差范围=c * (统计量的标准差)</li>
</ul>
<p>==P500==</p>
]]></content>
      <categories>
        <category>data analytics</category>
      </categories>
      <tags>
        <tag>《深入浅出统计学》</tag>
      </tags>
  </entry>
  <entry>
    <title>5.python面向对象</title>
    <url>/2020/01/20/5.python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>顾名思义就是函数没有名字，使用lambda关键字定义的函数就是匿名函数,简化代码，增加运行效率。 特点： 匿名函数只适合做一下简单的操作，返回值不需要加上return。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a,b,c)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a+b+c</span><br><span class="line">print(func(<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br></pre></td></tr></table></figure>

<pre><code>8</code></pre><a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#匿名函数</span></span><br><span class="line">result=(<span class="keyword">lambda</span> a,b,c:a+b+c)(<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="comment"># 匿名函数也是函数</span></span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>

<pre><code>8</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对字典列表排序的时候还可以使用匿名函数</span></span><br><span class="line">my_list=&#123;<span class="string">'age'</span>:<span class="number">23</span>,<span class="string">'name'</span>:<span class="string">'张三'</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_value</span><span class="params">(item)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> item[<span class="string">'age'</span>]</span><br><span class="line"></span><br><span class="line">get_value(my_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># my_list.sort(key=get_value,reverse=True)print(my_list)</span></span><br></pre></td></tr></table></figure>




<pre><code>23</code></pre><h2 id="面向对象的编程"><a href="#面向对象的编程" class="headerlink" title="面向对象的编程"></a>面向对象的编程</h2><p>面向对象编程——Object Oriented Programming，简称<strong>OOP</strong>，是一种程序设计思想。OOP把对象作为程序的<strong>基本单元</strong>，一个对象包含了数据和操作数据的函数。</p>
<p><strong>面向过程</strong>的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。</p>
<p>而<strong>面向对象</strong>的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。</p>
<p>在Python中，<strong>所有数据类型都可以视为对象</strong>，当然也可以自定义对象。自定义的对象数据类型就是面向对象中的类（Class）的概念。</p>
<p>我们以一个例子来说明面向过程和面向对象在程序流程上的不同之处。</p>
<p>假设我们要处理学生的成绩表，为了表示一个学生的成绩，面向过程的程序可以用一个dict表示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">std1 = &#123; <span class="string">'name'</span>: <span class="string">'Curry'</span>, <span class="string">'score'</span>: <span class="number">98</span> &#125;</span><br><span class="line">std2 = &#123; <span class="string">'name'</span>: <span class="string">'James'</span>, <span class="string">'score'</span>: <span class="number">81</span> &#125;</span><br></pre></td></tr></table></figure>

<p>而处理学生成绩可以通过函数实现，比如打印学生的成绩：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_score</span><span class="params">(std)</span>:</span></span><br><span class="line">    print(<span class="string">'%s: %s'</span> % (std[<span class="string">'name'</span>], std[<span class="string">'score'</span>]))</span><br></pre></td></tr></table></figure>

<p>如果采用<strong>面向对象的程序设计思想</strong>，我们首选思考的不是程序的执行流程，而是Student这种数据类型应该被视为一个对象，这个对象拥有name和score这两个<strong>属性</strong>（Property）。如果要打印一个学生的成绩，首先必须创建出这 个学生对应的对象，然后，给对象发一个print_score消息，让对象自己把自己的数据打印出来。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init</span> <span class="params">(self, name, score)</span>:</span> </span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_score</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'%s: %s'</span> % (self.name, self.score))</span><br></pre></td></tr></table></figure>

<p>给对象发消息实际上就是调用对象对应的关联函数，我们称之为对象的<strong>方法</strong>（Method）。面向对象的程序写出来就像这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bart &#x3D; Student(&#39;Bart Simpson&#39;, 59) </span><br><span class="line">lisa &#x3D; Student(&#39;Lisa Simpson&#39;, 87) </span><br><span class="line">bart.print_score() </span><br><span class="line">lisa.print_score()</span><br></pre></td></tr></table></figure>

<p>面向对象的设计思想是从自然界中来的，因为在自然界中，<strong>类</strong>（Class）和<strong>实例</strong>（Instance）的概念是很自然的。</p>
<p>Class是一种抽象概念，比如我们定义的Class——Student，是指学生这个概念，而<strong>实例（**</strong>Instance<strong>**）</strong>则是一个个具  体的Student，比如，Bart Simpson和Lisa Simpson是两个具体的Student。</p>
<p>所以，面向对象的设计思想是抽象出Class，根据Class创建Instance。</p>
<p>面向对象的抽象程度又比函数要高，因为一个Class既包含数据，又包含操作数据的方法。</p>
<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p><strong>面向对象编程</strong>的2个非常重要的概念：<strong>类和对象</strong></p>
<p><strong>对象</strong>是面向对象编程的核心，在使用对象的过程中，为了将具有共同特征和行为的一组对象抽象定义，提出了另外一个新的概念——<strong>类</strong></p>
<p><strong>类</strong>就相当于制造飞机时的图纸，用它来进行创建的飞机就相当于<strong>对象</strong>。</p>
<blockquote>
<p><strong>补充：</strong></p>
<ul>
<li>需求：做一道西红柿炒鸡蛋</li>
</ul>
<p><strong>方法1</strong>：按步骤一步一步制作（面向过程）——<strong>[将每个过程打包成函数，需要时依次调用]</strong></p>
<p><strong>方法2</strong>：制作一台机器人，告诉机器人炒菜（面向对象）——<strong>[打包成类与对象]</strong></p>
<p><strong>类</strong>作为母版制作出很多<strong>对象</strong></p>
</blockquote>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>人以类聚物以群分。 具有相似内部状态和运动规律的实体的集合(或统称为抽象)。 具有相同<strong>属性</strong>和<strong>行为</strong>事物的统称类是抽象的,在使用的时候通常会找到这个类的一个具体的存在,使用这个具体的存在。<strong>一个类可以找到多个对象</strong></p>
<p><img src="/2020/01/20/5.python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/1.13.jpg" alt></p>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>某一个具体事物的存在 ,在现实世界中可以是看得见摸得着的。 可以是直接使用的</p>
<p><img src="/2020/01/20/5.python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/1.14.jpg" alt></p>
<h3 id="类和对象之间的关系"><a href="#类和对象之间的关系" class="headerlink" title="类和对象之间的关系"></a>类和对象之间的关系</h3><p><img src="/2020/01/20/5.python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/1.15.jpg" alt></p>
<h3 id="定义类和创建对象"><a href="#定义类和创建对象" class="headerlink" title="定义类和创建对象"></a>定义类和创建对象</h3><p>定义一个类，格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class 类名:</span><br><span class="line"></span><br><span class="line">方法列表</span><br><span class="line"></span><br><span class="line"># class Hero: # 经典类（旧式类）定义形式</span><br><span class="line"># class Hero():</span><br><span class="line"></span><br><span class="line">class Hero(object): # 新式类定义形式</span><br><span class="line">    def info(self): </span><br><span class="line">        print(&quot;hero&quot;)</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li><p>定义类时有2种形式：<strong>新式类和经典类</strong>，上面代码中的Hero为新式类，前两行注释部分则为经典类；</p>
</li>
<li><p>object 是Python 里所有类的最顶级父类； 类名 的命名规则按照”大驼峰命名法”；</p>
</li>
<li><p>info 是一个实例方法，第一个参数一般是self，表示实例对象本身，当然了可以将self换为其它的名字，其作用是一个变量 这个变量指向了实例对象.</p>
</li>
<li><p>python中，可以根据已经定义的类去创建出一个或多个对象。</p>
</li>
</ul>
<p><strong>创建对象的格式为</strong></p>
<p>对象名1 = 类名() </p>
<p>对象名2 = 类名() </p>
<p>对象名3 = 类名()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hero</span><span class="params">(object)</span>:</span> <span class="comment"># 新式类定义形式</span></span><br><span class="line">    <span class="string">'''info 是一个实例方法，类对象可以调用实例方法，实例方法的第一个参数一定是self'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''当对象调用实例方法时，Python会自动将对象本身的引用做为参数， 传递到实例方法的第一个参数self里'''</span></span><br><span class="line">        print(self)</span><br><span class="line">        print(<span class="string">"self各不同，对象是出处。"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Hero这个类 实例化了一个对象</span></span><br><span class="line">hero = Hero()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对象调用实例方法info()，执行info()里的代码</span></span><br><span class="line"><span class="comment"># . 表示选择属性或者方法</span></span><br><span class="line">hero.info()</span><br><span class="line">print(hero) <span class="comment"># 打印对象，则默认打印对象在内存的地址，结果等同于info里的print(self)</span></span><br></pre></td></tr></table></figure>

<pre><code>&lt;__main__.Hero object at 0x0000000005413EF0&gt;
self各不同，对象是出处。
&lt;__main__.Hero object at 0x0000000005413EF0&gt;</code></pre><h3 id="补充：类与对象"><a href="#补充：类与对象" class="headerlink" title="补充：类与对象"></a>补充：类与对象</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#类的使用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> 成绩单<span class="params">()</span>:</span></span><br><span class="line"><span class="meta">    @classmethod#类的方法（函数）同类的属性（变量）结合</span></span><br><span class="line">    <span class="comment">#类的属性作为类方法的参数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> 录入成绩单<span class="params">(cls)</span>:</span></span><br><span class="line">        cls.学生姓名=input(<span class="string">'请输入学生姓名：'</span>)</span><br><span class="line">        cls.语文_成绩=int(input(<span class="string">'请输入语文成绩：'</span>))</span><br><span class="line">        cls.数学_成绩=int(input(<span class="string">'请输入数学成绩：'</span>))</span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> 打印成绩单<span class="params">(cls)</span>:</span></span><br><span class="line">        print(cls.学生姓名+<span class="string">'的成绩如下：'</span>)</span><br><span class="line">        print(<span class="string">'语文成绩：'</span>+str(cls.语文_成绩))</span><br><span class="line">        print(<span class="string">'语文成绩：'</span>+str(cls.语文_成绩))</span><br><span class="line">    </span><br><span class="line">成绩单.录入成绩单()</span><br><span class="line">成绩单.打印成绩单()</span><br></pre></td></tr></table></figure>

<pre><code>请输入学生姓名：Ryan
请输入语文成绩：100
请输入数学成绩：99
Ryan的成绩如下：
语文成绩：100
语文成绩：100</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#实例化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> 成绩单<span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#①</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> 录入成绩单<span class="params">(self)</span>:</span><span class="comment">#②</span></span><br><span class="line">        self.学生姓名=input(<span class="string">'请输入学生姓名：'</span>)</span><br><span class="line">        self.语文_成绩=int(input(<span class="string">'请输入语文成绩：'</span>))</span><br><span class="line">        self.数学_成绩=int(input(<span class="string">'请输入数学成绩：'</span>))</span><br><span class="line"><span class="comment">#③</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> 打印成绩单<span class="params">(self)</span>:</span></span><br><span class="line">        print(self.学生姓名+<span class="string">'的成绩如下：'</span>)</span><br><span class="line">        print(<span class="string">'语文成绩：'</span>+str(self.语文_成绩))</span><br><span class="line">        print(<span class="string">'语文成绩：'</span>+str(self.语文_成绩))</span><br><span class="line"></span><br><span class="line"><span class="comment">#④</span></span><br><span class="line">成绩单<span class="number">1</span>=成绩单()<span class="comment">#实例化得到成绩单1</span></span><br><span class="line"><span class="comment">#调用实例化变量</span></span><br><span class="line">成绩单<span class="number">1.</span>录入成绩单()</span><br><span class="line">成绩单<span class="number">1.</span>打印成绩单()</span><br></pre></td></tr></table></figure>

<pre><code>请输入学生姓名：Ryan
请输入语文成绩：34
请输入数学成绩：53
Ryan的成绩如下：
语文成绩：34
语文成绩：34</code></pre><p><strong>对比分析</strong>：</p>
<ul>
<li><p>①是空着的，意思是这里不再需要@classmethod的声明</p>
</li>
<li><p>第②处，把cls替换成了 self.</p>
</li>
<li><p>实例化后再使用的格式，需要先赋值然后再调用(第③处)在第④步骤， 我们需要用实例名=类(的方式(实例名其实就是任取一个变量名)，为类创建一个实例， 然后再使用实例名函数0的方式调用对应的方法。</p>
</li>
</ul>
<h2 id="对象的属性和方法"><a href="#对象的属性和方法" class="headerlink" title="对象的属性和方法"></a>对象的属性和方法</h2><h3 id="添加和获取对象的属性"><a href="#添加和获取对象的属性" class="headerlink" title="添加和获取对象的属性"></a>添加和获取对象的属性</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hero</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""定义了一个英雄类，可以移动和攻击"""</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""实例方法"""</span></span><br><span class="line">        print(<span class="string">"正在前往事发地点..."</span>)</span><br><span class="line"><span class="comment"># 实例化了一个英雄对象</span></span><br><span class="line"></span><br><span class="line">hero = Hero()</span><br><span class="line"><span class="comment"># 给对象添加属性，以及对应的属性值</span></span><br><span class="line">hero.name = <span class="string">"德玛西亚"</span> <span class="comment"># 姓名</span></span><br><span class="line">hero.hp = <span class="number">2600</span> <span class="comment"># 生 命 值</span></span><br><span class="line"><span class="comment"># 通过.成员选择运算符，获取对象的属性值</span></span><br><span class="line">print(<span class="string">"英雄 %s 的生命值 :%d"</span> % (hero.name, hero.hp))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过.成员选择运算符，获取对象的实例方法</span></span><br><span class="line">hero.move()</span><br></pre></td></tr></table></figure>

<pre><code>英雄 德玛西亚 的生命值 :2600
正在前往事发地点...</code></pre><h3 id="通过self获取对象属性"><a href="#通过self获取对象属性" class="headerlink" title="通过self获取对象属性"></a>通过self获取对象属性</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""定义了一个英雄类，可以移动和攻击"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""实例方法"""</span></span><br><span class="line">        print(<span class="string">"正在前往事发地点..."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""在类的实例方法中，通过self获取该对象的属性"""</span></span><br><span class="line">        print(<span class="string">"英雄 %s 的生命值 :%d"</span> % (self.name, self.hp))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化了一个英雄对象</span></span><br><span class="line"> hero = Hero()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给对象添加属性，以及对应的属性值</span></span><br><span class="line">hero.name = <span class="string">"德玛西亚"</span> <span class="comment"># 姓名</span></span><br><span class="line">hero.hp = <span class="number">2600</span> <span class="comment"># 生 命 值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过.成员选择运算符，获取对象的实例方法</span></span><br><span class="line"></span><br><span class="line">hero.info() <span class="comment"># 只需要调用实例方法info()，即可获取英雄的属性</span></span><br><span class="line">hero.move()</span><br></pre></td></tr></table></figure>

<pre><code>英雄 德玛西亚 的生命值 :2600
正在前往事发地点...</code></pre><h3 id="init魔法方法"><a href="#init魔法方法" class="headerlink" title="init魔法方法"></a>init魔法方法</h3><h4 id="init方法"><a href="#init方法" class="headerlink" title="init方法"></a>init方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Hero(object):</span><br><span class="line">    &quot;&quot;&quot;定义了一个英雄类，可以移动和攻击&quot;&quot;&quot;</span><br><span class="line">#Python 的类里提供的，两个下划线开始，两个下划线结束的方法，就是魔法方法， init ()就是一个魔法方法， 通常用来做属性初始化 或 赋值 操作。</span><br><span class="line"></span><br><span class="line"># 如果类面没有写__init__方法，Python会自动创建，但是不执行任何操作，</span><br><span class="line"></span><br><span class="line"># 如果为了能够在完成自己想要的功能，可以自己定义__init__方法，</span><br><span class="line"></span><br><span class="line"># 所以一个类里无论自己是否编写 __init__方法 一定有__init__方法。</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        &quot;&quot;&quot; 方法，用来做变量初始化 或 赋值 操作，在类实例化对象的时候，会被自动调用&quot;&quot;&quot; </span><br><span class="line">        self.name &#x3D; &quot;hero&quot; # 姓 名</span><br><span class="line">        self.hp &#x3D; 2600 # 生命值</span><br><span class="line">    def move(self):</span><br><span class="line">        &quot;&quot;&quot;实例方法&quot;&quot;&quot;</span><br><span class="line">        print(&quot;正在前往事发地点...&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 实例化了一个英雄对象，并自动调用 init ()方法</span><br><span class="line">hero &#x3D; Hero()</span><br><span class="line"></span><br><span class="line"># 通过.成员选择运算符，获取对象的实例方法</span><br><span class="line">hero.info() # 只需要调用实例方法info()，即可获取英雄的属性</span><br><span class="line">hero.move()</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ul>
<li>_<em>init_</em>()方法，在创建一个对象时默认被调用，不需要手动调用</li>
<li>_<em>init_</em>(self)中的self参数，不需要开发者传递，python解释器会自动把当前的对象引用传递过去。</li>
</ul>
<h4 id="有参数的init（）方法"><a href="#有参数的init（）方法" class="headerlink" title="有参数的init（）方法"></a>有参数的init（）方法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hero</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""定义了一个英雄类，可以移动和攻击"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, hp)</span>:</span></span><br><span class="line">        <span class="string">""" init () 方法，用来做变量初始化 或 赋值操作"""</span></span><br><span class="line"><span class="comment"># 英雄名</span></span><br><span class="line">        self.name = name</span><br><span class="line"><span class="comment"># 生命值：</span></span><br><span class="line">        self.hp = hp</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""实例方法"""</span></span><br><span class="line">        print(<span class="string">"%s 正在前往事发地点..."</span> % self.name)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"英雄 %s 的生命值 :%d"</span> % (self.name, self.hp))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#实例化英雄对象时，参数会传递到对象的 init()方法里</span></span><br><span class="line">blind = Hero(<span class="string">'瞎哥'</span>,<span class="number">2600</span>) </span><br><span class="line">gailun = Hero(<span class="string">"盖伦"</span>,<span class="number">4200</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#print(gailun)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#print(blind)</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 不同对象的属性值的单独保存</span></span><br><span class="line">print(id(blind.name)) </span><br><span class="line">print(id(gailun.name))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同一个类的不同对象，实例方法共享</span></span><br><span class="line">print(id(blind.move())) </span><br><span class="line">print(id(gailun.move()))</span><br></pre></td></tr></table></figure>

<pre><code>87554072
87555744
瞎哥 正在前往事发地点...
2004853904
盖伦 正在前往事发地点...
2004853904</code></pre><p><strong>注意：</strong></p>
<ul>
<li>通过一个类，可以创建多个对象，就好比 通过一个模具创建多个实体一样</li>
<li>_<em>init_</em>(self)中，默认有1个参数名字为self，如果在创建对象时传递了2个实参，那么init (self)中出了self作为第一个形参外还需要2个形参，例如 init (self,x,y)</li>
<li>在类内部获取 属性 和 实例方法，通过self获取；</li>
<li>在类外部获取 属性 和 实例方法，通过对象名获取。</li>
<li>如果一个类有多个对象，每个对象的属性是各自保存的，都有各自独立的地址；</li>
<li>但是实例方法是所有对象共享的，只占用一份内存空间。类会通过self来判断是哪个对象调用了实例方法。</li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul>
<li>在程序中，<strong>继承</strong>描述的是多个类之间的所属关系。</li>
<li>如果一个类A里面的属性和方法可以复用，则可以通过继承的方式，<strong>传递</strong>到类B里。 </li>
<li>那么类A就是<strong>基类</strong>，也叫做<strong>父类</strong>；类B就是<strong>派生类</strong>，也叫做<strong>子类</strong>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 父 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.num = <span class="number">10</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_num</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.num + <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span> </span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">b = B()</span><br><span class="line">print(b.num) </span><br><span class="line">b.print_num()</span><br></pre></td></tr></table></figure>

<pre><code>10
20</code></pre><h3 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h3><p>子类只能继承一个父类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义一个Person类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="comment"># 属 性</span></span><br><span class="line">        self.name = <span class="string">"女娲"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 实例方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_person</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">" &lt;%s&gt; 造了一个人..."</span> % self.name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义Teacher类，继承了 Person，则Teacher是子类，Person是父类。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span><span class="params">(Person)</span>:</span></span><br><span class="line"><span class="comment"># 子类可以继承父类所有的属性和方法，哪怕子类没有自己的属性和方法，也可以使用父类的属性和方法。</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">panda = Teacher() </span><br><span class="line">    <span class="comment"># 创建子类实例对象</span></span><br><span class="line">print(panda.name) </span><br><span class="line">    <span class="comment"># 子类对象可以直接使用父类的属性</span></span><br><span class="line">panda.make_person() </span><br><span class="line">    <span class="comment"># 子类对象可以直接使用父类的方法</span></span><br></pre></td></tr></table></figure>

<pre><code>女娲
 &lt;女娲&gt; 造了一个人...</code></pre><p><strong>总结</strong></p>
<ul>
<li>虽然子类没有定义 init 方法初始化属性，也没有定义实例方法，但是父类有。所以只要创建子类的对象，就默认执行了那个继承过来的 init 方法</li>
<li>子类在继承的时候，在定义类时，小括号()中为父类的名字</li>
<li>父类的<strong>属性、方法</strong>，会被继承给子类</li>
</ul>
<h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>子类继承多个父类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Women</span><span class="params">(object)</span>:</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.name = <span class="string">"女娲"</span> <span class="comment"># 实例变量，属性</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_person</span><span class="params">(self)</span>:</span>          <span class="comment"># 实例方法，方法</span></span><br><span class="line">        print(<span class="string">" &lt;%s&gt; 造了一个人..."</span> % self.name)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"移动.."</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.name = <span class="string">"亚当"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_person</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"&lt;%s&gt; 造了一个人..."</span> % self.name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"跑.."</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(Women, Man)</span>:</span> <span class="comment"># 多继承，继承了多个父类</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">ls = Person() </span><br><span class="line">print(ls.name) </span><br><span class="line">ls.make_person()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子类的魔法属性 mro 决定了属性和方法的查找顺序</span></span><br><span class="line">print(Person. mro)</span><br></pre></td></tr></table></figure>

<pre><code>女娲
 &lt;女娲&gt; 造了一个人...
&lt;built-in method mro of type object at 0x0000000004376698&gt;</code></pre><p><strong>结论：</strong></p>
<ul>
<li><p>多继承可以继承多个父类，也继承了所有父类的属性和方法</p>
</li>
<li><p><strong>注意：</strong>如果多个父类中有同名的 属性和方法，则默认使用第一个父类的属性和方法（根据类的魔法属性mro 的顺序来查找）</p>
</li>
<li><p>多个父类中，不重名的属性和方法，不会有任何影响。</p>
</li>
</ul>
<h3 id="重写父类方法"><a href="#重写父类方法" class="headerlink" title="重写父类方法"></a>重写父类方法</h3><p>子类继承父类，父类的方法满足不了子类的需要可以对父类的方法进行重写</p>
<p>*<em>重写的特点: *</em></p>
<ol>
<li>继承关系，</li>
<li>方法名相同</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"跑起来了"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span> </span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为父类的方法满足不了子类的需要，对其进行重写</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"%s跑起来了"</span> % self.name)</span><br><span class="line"></span><br><span class="line">stu = Student(<span class="string">"王五"</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用方法的时候先从本类去找，如果本来没有再去父类去找，会遵循mro的特点</span></span><br><span class="line"></span><br><span class="line">stu.run()</span><br></pre></td></tr></table></figure>

<pre><code>王五跑起来了</code></pre><h3 id="属性方法"><a href="#属性方法" class="headerlink" title="属性方法"></a>属性方法</h3><h4 id="类属性和实例属性"><a href="#类属性和实例属性" class="headerlink" title="类属性和实例属性"></a>类属性和实例属性</h4><p><strong>类属性</strong>就是类对象所拥有的属性，它被所有类对象的实例对象所共有，在内存中只存在一个副本，这个和C++中类的静态成员变量有点类似。对于公有的类属性，在类外可以通过类对象和实例对象访问</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span><span class="params">(object)</span>:</span></span><br><span class="line">    name = <span class="string">'Tom'</span><span class="comment"># 公有的类属性</span></span><br><span class="line">    __age = <span class="number">12</span><span class="comment"># 私有的类属性</span></span><br><span class="line"></span><br><span class="line">p = People() </span><br><span class="line">print(p.name)	<span class="comment"># 正 确</span></span><br><span class="line">print(People.name)	<span class="comment"># 正 确</span></span><br><span class="line"><span class="comment"># print(p.__age)	# 错误，不能在类外通过实例对象访问私有的类属性</span></span><br><span class="line"><span class="comment"># print(People.__age) # 错误，不能在类外通过类对象访问私有的类属性实例属性(对象属性)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span><span class="params">(object)</span>:</span></span><br><span class="line">    address = <span class="string">'山东'</span>	<span class="comment"># 类属性</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.name = <span class="string">'xiaowang'</span>	<span class="comment"># 实例属性</span></span><br><span class="line">        self.age = <span class="number">20</span>	<span class="comment"># 实例属性</span></span><br><span class="line"></span><br><span class="line">p = People()</span><br><span class="line">p.age = <span class="number">12</span>	<span class="comment"># 实例属性</span></span><br><span class="line">print(p.address)	<span class="comment"># 正 确</span></span><br><span class="line">print(p.name)		<span class="comment"># 正 确</span></span><br><span class="line">print(p.age)	<span class="comment"># 正 确</span></span><br><span class="line">print(People.address)	<span class="comment"># 正 确</span></span><br><span class="line"><span class="comment">#print(People.name)		# 错 误</span></span><br><span class="line"><span class="comment">#print(People.age)	# 错 误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#通过实例(对象)去修改类属性</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span><span class="params">(object)</span>:</span></span><br><span class="line">    country = <span class="string">'china'</span> <span class="comment">#类属性</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">print(People.country) </span><br><span class="line">p = People() </span><br><span class="line">print(p.country) </span><br><span class="line"></span><br><span class="line">p.country = <span class="string">'japan'</span></span><br><span class="line">print(p.country)	<span class="comment"># 实例属性会屏蔽掉同名的类属性</span></span><br><span class="line">print(People.country)</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> p.country <span class="comment"># 删除实例属性</span></span><br><span class="line">print(p.country)</span><br></pre></td></tr></table></figure>

<pre><code>Tom
Tom
山东
xiaowang
12
山东
china
china
japan
china
china</code></pre><p><strong>总结</strong><br>如果需要在类外修改类属性，必须通过类对象去引用然后进行修改。如果通过实例对象去引用，会产生一个同名的实例属性，这种方式修改的是实例属性，不会影响到类属性，并且之后如果通过实例对象去引用该名称的属性，实例属性会强制屏蔽掉类属性，即引用的是实例属性，除非删除了该实例属性。</p>
<h4 id="静态方法和类方法"><a href="#静态方法和类方法" class="headerlink" title="静态方法和类方法"></a>静态方法和类方法</h4><p><strong>1.类方法</strong></p>
<p>是类对象所拥有的方法，需要用修饰器@classmethod来标识其为类方法，对于类方法，第一个参数必须是类对象，  一般以cls作为第一个参数（当然可以用其他名称的变量作为其第一个参数，但是大部分人都习惯以’cls’作为第一个参数的名字，就最好用’cls’了），能够通过实例对象和类对象去访问。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span><span class="params">(object)</span>:</span> </span><br><span class="line">    country = <span class="string">'china'</span></span><br><span class="line"><span class="comment">#类方法，用classmethod来进行修饰</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_country</span><span class="params">(cls)</span>:</span> </span><br><span class="line">        <span class="keyword">return</span> cls.country</span><br><span class="line"></span><br><span class="line">p = People()</span><br><span class="line">print(p.get_country())	<span class="comment">#可以用过实例对象引用print(People.get_country())	#可以通过类对象引用类方法还有一个用途就是可以对类属性进行修改：</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span><span class="params">(object)</span>:</span> </span><br><span class="line">    country = <span class="string">'china'</span></span><br><span class="line"><span class="comment">#类方法，用classmethod来进行修饰</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_country</span><span class="params">(cls)</span>:</span> </span><br><span class="line">        <span class="keyword">return</span> cls.country</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_country</span><span class="params">(cls,country)</span>:</span> </span><br><span class="line">        cls.country = country</span><br><span class="line"></span><br><span class="line">p = People()</span><br><span class="line">print(p.get_country())	<span class="comment">#可以用过实例对象访问print(People.get_country())	#可以通过类访问</span></span><br><span class="line"></span><br><span class="line">p.set_country(<span class="string">'japan'</span>)</span><br><span class="line"></span><br><span class="line">print(p.get_country()) </span><br><span class="line">print(People.get_country())</span><br><span class="line"><span class="comment">#结果显示在用类方法对类属性修改之后，通过类对象和实例对象访问都发生了改变</span></span><br></pre></td></tr></table></figure>

<pre><code>china
china
japan
japan</code></pre><p><strong>2. 静态方法</strong></p>
<p>需要通过修饰器@staticmethod来进行修饰，静态方法不需要多定义参数，可以通过对象和类来访问。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span><span class="params">(object)</span>:</span> </span><br><span class="line">    country = <span class="string">'china'</span></span><br><span class="line"><span class="meta">    @staticmethod #静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_country</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> People.country</span><br><span class="line"></span><br><span class="line">p = People()</span><br><span class="line"><span class="comment"># 通过对象访问静态方法</span></span><br><span class="line">p.get_country()</span><br><span class="line"><span class="comment"># 通过类访问静态方法</span></span><br><span class="line">print(People.get_country())</span><br></pre></td></tr></table></figure>

<pre><code>china</code></pre><p><strong>总结</strong><br>从类方法和实例方法以及静态方法的定义形式就可以看出来，类方法的第一个参数是类对象cls，那么通过cls引用的   必定是类对象的属性和方法；  实例方法的第一个参数是实例对象self，那么通过self引用的可能是类属性、也有可能是实例属性（这个需要具体分析），不过在存在相同名称的类属性和实例属性的情况下，实例属性优先级更高。  静态方法中不需要额外定义参数，因此在静态方法中引用类属性的话，必须通过类实例对象来引用</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ul>
<li>多态, 不同的子类对象调用相同的父类方法，产生不同的执行结果，可以增加代码的外部调用灵活度</li>
<li>多态以继承和重写父类方法为前提</li>
<li>多态是调用方法的技巧，不会影响到类的内部设计</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span><span class="params">(object)</span>:</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Animal is running...'</span>) </span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Dog is running...'</span>) </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Cat is running...'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_twice</span><span class="params">(animal)</span>:</span> </span><br><span class="line">    animal.run() </span><br><span class="line">    animal.run()</span><br><span class="line"></span><br><span class="line">dog = Dog() </span><br><span class="line">cat = Cat()</span><br><span class="line"></span><br><span class="line">run_twice(dog) </span><br><span class="line">run_twice(cat)</span><br></pre></td></tr></table></figure>

<pre><code>Dog is running...
Dog is running...
Cat is running...
Cat is running...</code></pre>]]></content>
      <categories>
        <category>data analytics</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>6. python包的使用及读写</title>
    <url>/2020/01/20/6.%20python%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E8%AF%BB%E5%86%99/</url>
    <content><![CDATA[<h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><p>一旦出错，还要一级一级上报，直到某个函数可以处理该错误（比如，给用户输出一个错误信息）。所以高级语言通常都内置了一套try…except…finally…的错误处理机制，Python也不例外。  让我们用一个例子来看看try的机制：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(<span class="string">'try...'</span>)</span><br><span class="line">    r = <span class="number">10</span> / <span class="number">0</span></span><br><span class="line">    print(<span class="string">'result:'</span>, r)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e: </span><br><span class="line">    print(<span class="string">'except:'</span>, e)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    print(<span class="string">'finally...'</span>) </span><br><span class="line">print(<span class="string">'END'</span>)</span><br></pre></td></tr></table></figure>

<pre><code>try...
except: division by zero
finally...
END</code></pre><p>当我们认为某些代码可能会出错时，就可以用try来运行这段代码，如果执行出错，则后续代码不会继续执行，而是  直接跳转至错误处理代码，即except语句块，执行完except后，如果有finally语句块，则执行finally语句块，至此，执行完毕。</p>
<a id="more"></a>

<p>上面的代码在计算10 / 0时会产生一个除法运算错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try...</span><br><span class="line">except: division by zero finally...</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p>从输出可以看到，当错误发生时，后续语句print(‘result:’, r)不会被执行，except由于捕获到ZeroDivisionError，因此被执行。最后，finally语句被执行。然后，程序继续按照流程往下走。</p>
<p>如果把除数0改成2，则执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try...</span><br><span class="line">result: 5 </span><br><span class="line">finally... </span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p>由于没有错误发生，所以except语句块不会被执行，但是finally如果有，则一定会被执行（可以没有finally语句）。</p>
<p>你还可以猜测，错误应该有很多种类，如果发生了不同类型的错误，应该由不同的except语句块处理。没错，可以 有多个except来捕获不同类型的错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    print(&#39;try...&#39;) </span><br><span class="line">    r &#x3D; 10 &#x2F; int(&#39;a&#39;)</span><br><span class="line">    print(&#39;result:&#39;, r) </span><br><span class="line">except ValueError as e:</span><br><span class="line">    print(&#39;ValueError:&#39;, e) </span><br><span class="line">except ZeroDivisionError as e:</span><br><span class="line">    print(&#39;ZeroDivisionError:&#39;, e) </span><br><span class="line">finally:</span><br><span class="line">    print(&#39;finally...&#39;) </span><br><span class="line">print(&#39;END&#39;)</span><br></pre></td></tr></table></figure>

<p>int()函数可能会抛出ValueError，所以我们用一个except捕获ValueError，用另一个except捕获ZeroDivisionError。</p>
<p>此外，如果没有错误发生，可以在except语句块后面加一个else，当没有错误发生时，会自动执行else语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    print(&#39;try...&#39;) </span><br><span class="line">    r &#x3D; 10 &#x2F; int(&#39;2&#39;)</span><br><span class="line">    print(&#39;result:&#39;, r) </span><br><span class="line">except ValueError as e:</span><br><span class="line">    print(&#39;ValueError:&#39;, e) </span><br><span class="line">except ZeroDivisionError as e:</span><br><span class="line">    print(&#39;ZeroDivisionError:&#39;, e) </span><br><span class="line">else:</span><br><span class="line">    print(&#39;no error!&#39;) </span><br><span class="line">finally:</span><br><span class="line">    print(&#39;finally...&#39;) </span><br><span class="line">print(&#39;END&#39;)</span><br></pre></td></tr></table></figure>

<p>Python的错误其实也是class，所有的错误类型都继承自BaseException，所以在使用except时需要注意的是，  它不但捕获该类型的错误，还把其子类也“一网打尽”。比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    foo()</span><br><span class="line">except ValueError as e: </span><br><span class="line">    print(&#39;ValueError&#39;)</span><br><span class="line">except UnicodeError as e: </span><br><span class="line">    print(&#39;UnicodeError&#39;)</span><br></pre></td></tr></table></figure>

<p>第二个except永远也捕获不到UnicodeError，因为UnicodeError是ValueError的子类，如果有，也被第一个except给捕获了。</p>
<p>Python所有的错误都是从BaseException类派生的，<a href="https://docs.python.org/3/library/exceptions.html#exception-hierarchy" target="_blank" rel="noopener">常见的错误类型和继承关系</a></p>
<p>使用try…except捕获错误还有一个巨大的好处，就是可以跨越多层调用，比如函数main()调用foo()，foo() 调用bar()，结果bar()出错了，这时，只要main()捕获到了，就可以处理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def foo(s):</span><br><span class="line">    return 10 &#x2F; int(s)</span><br><span class="line"></span><br><span class="line">def bar(s):</span><br><span class="line">    return foo(s) * 2</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    try:</span><br><span class="line">        bar(&#39;0&#39;)</span><br><span class="line">    except Exception as e: </span><br><span class="line">        print(&#39;Error:&#39;, e)</span><br><span class="line">    finally:</span><br><span class="line">        print(&#39;finally...&#39;)</span><br></pre></td></tr></table></figure>

<p>也就是说，不需要在每个可能出错的地方去捕获错误，只要在合适的层次去捕获错误就可以了。这样一来，就大大减少了写try…except…finally的麻烦。</p>
<p><strong>python所有的标准异常类：</strong></p>
<table>
<thead>
<tr>
<th>异常名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>BaseException</td>
<td>所有异常的基类</td>
</tr>
<tr>
<td>SystemExit</td>
<td>解释器请求退出</td>
</tr>
<tr>
<td>KeyboardInterrupt</td>
<td>用户中断执行(通常是输入^C)</td>
</tr>
<tr>
<td>Exception</td>
<td>常规错误的基类</td>
</tr>
<tr>
<td>StopIteration</td>
<td>迭代器没有更多的值</td>
</tr>
<tr>
<td>GeneratorExit</td>
<td>生成器(generator)发生异常来通知退出</td>
</tr>
<tr>
<td>SystemExit</td>
<td>Python 解释器请求退出</td>
</tr>
<tr>
<td>StandardError</td>
<td>所有的内建标准异常的基类</td>
</tr>
<tr>
<td>ArithmeticError</td>
<td>所有数值计算错误的基类</td>
</tr>
<tr>
<td>FloatingPointError</td>
<td>浮点计算错误</td>
</tr>
<tr>
<td>OverflowError</td>
<td>数值运算超出最大限制</td>
</tr>
<tr>
<td>ZeroDivisionError</td>
<td>除(或取模)零 (所有数据类型)</td>
</tr>
<tr>
<td>AssertionError</td>
<td>断言语句失败</td>
</tr>
<tr>
<td>AttributeError</td>
<td>对象没有这个属性</td>
</tr>
<tr>
<td>EOFError</td>
<td>没有内建输入,到达EOF 标记</td>
</tr>
<tr>
<td>EnvironmentError</td>
<td>操作系统错误的基类</td>
</tr>
<tr>
<td>IOError</td>
<td>输入/输出操作失败</td>
</tr>
<tr>
<td>OSError</td>
<td>操作系统错误</td>
</tr>
<tr>
<td>WindowsError</td>
<td>系统调用失败</td>
</tr>
<tr>
<td>ImportError</td>
<td>导入模块/对象失败</td>
</tr>
<tr>
<td>KeyboardInterrupt</td>
<td>用户中断执行(通常是输入^C)</td>
</tr>
<tr>
<td>LookupError</td>
<td>无效数据查询的基类</td>
</tr>
<tr>
<td>IndexError</td>
<td>序列中没有没有此索引(index)</td>
</tr>
<tr>
<td>KeyError</td>
<td>映射中没有这个键</td>
</tr>
<tr>
<td>MemoryError</td>
<td>内存溢出错误(对于Python 解释器不是致命的)</td>
</tr>
<tr>
<td>NameError</td>
<td>未声明/初始化对象 (没有属性)</td>
</tr>
<tr>
<td>UnboundLocalError</td>
<td>访问未初始化的本地变量</td>
</tr>
<tr>
<td>ReferenceError</td>
<td>弱引用(Weak  reference)试图访问已经垃圾回收了的对象</td>
</tr>
<tr>
<td>RuntimeError</td>
<td>一般的运行时错误</td>
</tr>
<tr>
<td>NotImplementedError</td>
<td>尚未实现的方法</td>
</tr>
<tr>
<td>SyntaxError</td>
<td>Python 语法错误</td>
</tr>
<tr>
<td>IndentationError</td>
<td>缩进错误</td>
</tr>
<tr>
<td>TabError</td>
<td>Tab 和空格混用</td>
</tr>
<tr>
<td>SystemError</td>
<td>一般的解释器系统错误</td>
</tr>
<tr>
<td>TypeError</td>
<td>对类型无效的操作</td>
</tr>
<tr>
<td>ValueError</td>
<td>传入无效的参数</td>
</tr>
<tr>
<td>UnicodeError</td>
<td>Unicode 相关的错误</td>
</tr>
<tr>
<td>UnicodeDecodeError</td>
<td>Unicode 解码时的错误</td>
</tr>
<tr>
<td>UnicodeEncodeError</td>
<td>Unicode 编码时错误</td>
</tr>
<tr>
<td>UnicodeTranslateError</td>
<td>Unicode 转换时错误</td>
</tr>
<tr>
<td>Warning</td>
<td>警告的基类</td>
</tr>
<tr>
<td>DeprecationWarning</td>
<td>关于被弃用的特征的警告</td>
</tr>
<tr>
<td>FutureWarning</td>
<td>关于构造将来语义会有改变的警告</td>
</tr>
<tr>
<td>OverflowWarning</td>
<td>旧的关于自动提升为长整型(long)的警告</td>
</tr>
<tr>
<td>PendingDeprecationWarning</td>
<td>关于特性将会被废弃的警告</td>
</tr>
<tr>
<td>RuntimeWarning</td>
<td>可疑的运行时行为(runtime  behavior)的警告</td>
</tr>
<tr>
<td>SyntaxWarning</td>
<td>可疑的语法的警告</td>
</tr>
<tr>
<td>UserWarning</td>
<td>用户代码生成的警告</td>
</tr>
</tbody></table>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>模块：通俗理解一个.py文件就是一个模块，模块是管理功能代码的。</p>
<p>内置模块：就是python自己内部自带的不需要我们去下载的模块， 比如：time, random等。</p>
<h3 id="自定义模块的使用"><a href="#自定义模块的使用" class="headerlink" title="自定义模块的使用"></a>自定义模块的使用</h3><p><strong>注意：</strong>自定义模块名字和变量名的定义很类似，都是由字母、数字、下划线组成，但是不能以数字开头，否则无法导入该模块。</p>
<h4 id="创建名为first-module的自定义模块"><a href="#创建名为first-module的自定义模块" class="headerlink" title="创建名为first_module的自定义模块"></a>创建名为first_module的自定义模块</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__all__= [<span class="string">"g_num"</span>, <span class="string">"show"</span>]</span><br><span class="line"><span class="comment"># 指定 all 表示 from 模块名 import * 只能使用指定的功能代码，而不是所有的功能代码</span></span><br><span class="line"><span class="comment"># 定义全局变量</span></span><br><span class="line">g_num = <span class="number">10</span></span><br><span class="line"><span class="comment"># 定义函数 </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"我是一个函数"</span>)</span><br><span class="line"><span class="comment"># 定义类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init</span> <span class="params">(self, name, age)</span>:</span> </span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_msg</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.name, self.age)</span><br><span class="line"><span class="comment"># 解决导入的模块中方法没有调用就会执行</span></span><br><span class="line"><span class="keyword">if</span> __name__== <span class="string">'__main__'</span>: </span><br><span class="line">    show()</span><br></pre></td></tr></table></figure>

<pre><code>我是一个函数</code></pre><h4 id="使用自定义的模块"><a href="#使用自定义的模块" class="headerlink" title="使用自定义的模块"></a>使用自定义的模块</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 导入模块</span><br><span class="line">import first_module</span><br><span class="line"># 使用模块中的功能代码</span><br><span class="line">print(first_module.g_num) first_module.show()</span><br><span class="line">stu &#x3D; first_module.Student(&quot;李四&quot;, 20)</span><br><span class="line">stu.show_msg()</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>使用 name 查看模块名，执行哪个文件，哪个文件中的<strong>name</strong>输出<strong>main</strong> , 其他导入模块中的<strong>name</strong>结果就是模块名字。</p>
<p>模块导入的注意点：</p>
<ol>
<li>自定义的模块名不要和系统的模块名重名，</li>
<li>导入的功能代码不要在当前模块定义否则使用不了导入模块的功能代码</li>
</ol>
<h2 id="包的介绍"><a href="#包的介绍" class="headerlink" title="包的介绍"></a>包的介绍</h2><p><strong>包：</strong>通俗理解包就是一个文件夹，只不过文件夹里面有一个init.py文件，包是管理模块的， 模块是管理功能代码的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -----import导入包里面的模块----</span><br><span class="line">import first_package.first</span><br><span class="line"></span><br><span class="line">#-----import导入包里面的模块设置别名----</span><br><span class="line">import first_package.first as one</span><br><span class="line"></span><br><span class="line">#----from导入包名 import 模块名----</span><br><span class="line">from first_package import second</span><br><span class="line"></span><br><span class="line">#--- from 包名.模块名 import 功能代码----</span><br><span class="line">from first_package.first import show	# 需要保证当前模块没有导入模块的功能代码</span><br><span class="line"># --- from 包名 import *, 默认不会导入包里面的所有模块，需要在init文件里面使用   all 	去指定导入的模块</span><br><span class="line">from first_package import *</span><br><span class="line"></span><br><span class="line">__init__文件写法</span><br><span class="line"># 如果外界使用from 包名 import * 不会导入包里面的所有模块，需要使用 all 指定</span><br><span class="line">     all 	&#x3D; [&quot;first&quot;, &quot;second&quot;]</span><br><span class="line"># 从当前包导入对应的模块</span><br><span class="line">from . import first from . import second</span><br></pre></td></tr></table></figure>

<h2 id="文件基础操作"><a href="#文件基础操作" class="headerlink" title="文件基础操作"></a>文件基础操作</h2><h3 id="文件简介"><a href="#文件简介" class="headerlink" title="文件简介"></a>文件简介</h3><p>文件包括文本文件和二进制文件（声音，图像，视频) 从存储方式来说，文件在磁盘上的存储方式都是二进制形式， 所以，文本文件其实也应该算二进制文件。先从他们的区别来说，虽然都是二进制文件，但是二进制代表的意思不一   样。打个比方，一个人，我们可以叫他的大名，以叫他的小名，但其实都是代表这个人。二进制读写是将内存里面的数据直接读写入文本中，而文本呢，则是将数据先转换成了字符串，再写入到文本中。</p>
<h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><p>要以读文件的模式打开一个文件对象，使用Python内置的open()函数，传入文件名和标示符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f &#x3D; open(&#39;&#x2F;Users&#x2F;michael&#x2F;test.txt&#39;, &#39;r&#39;)</span><br></pre></td></tr></table></figure>

<p>标示符’r’表示读，这样，我们就成功地打开了一个文件。</p>
<p>如果文件不存在，open()函数就会抛出一个IOError的错误，并且给出错误码和详细的信息告诉你文件不存在：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f=open(<span class="string">'/Users/michael/notfound.txt'</span>, <span class="string">'r'</span>)</span><br></pre></td></tr></table></figure>


<pre><code>---------------------------------------------------------------------------

FileNotFoundError                         Traceback (most recent call last)

&lt;ipython-input-115-56fe20145a26&gt; in &lt;module&gt;()
----&gt; 1 f=open(&apos;/Users/michael/notfound.txt&apos;, &apos;r&apos;)


FileNotFoundError: [Errno 2] No such file or directory: &apos;/Users/michael/notfound.txt&apos;</code></pre><p>如果文件打开成功，接下来，调用read()方法可以一次读取文件的全部内容，Python把内容读到内存，用一个str 对象表示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f.read() &#39;Hello, world!&#39;</span><br></pre></td></tr></table></figure>

<p><strong>最后一步</strong>是调用close()方法关闭文件。文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操  作系统同一时间能打开的文件数量也是有限的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<p>由于文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用try … finally来实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    f &#x3D; open(&#39;&#x2F;path&#x2F;to&#x2F;file&#39;, &#39;r&#39;) </span><br><span class="line">    print(f.read())</span><br><span class="line">finally:</span><br><span class="line">    if f:</span><br><span class="line">        f.close()</span><br></pre></td></tr></table></figure>

<p>但是每次都这么写实在太繁琐，所以，Python引入了with语句来自动帮我们调用close()方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with open(&#39;&#x2F;path&#x2F;to&#x2F;file&#39;, &#39;r&#39;) as f:</span><br><span class="line">    print(f.read())</span><br></pre></td></tr></table></figure>

<p>这和前面的try … finally是一样的，但是代码更佳简洁，并且不必调用f.close()方法。</p>
<p>调用read()会一次性读取文件的全部内容，如果文件有10G，内存就爆了，所以，要保险起见，可以反复调用read(size)方法，每次最多读取size个字节的内容。另外，调用readline()可以每次读取一行内容，调用readlines()一次读取所有内容并按行返回list。因此，要根据需要决定怎么调用。</p>
<p>如果<strong>文件很小</strong>，read()一次性读取最方便；如果不能确定文件大小，反复调用read(size)比较保险；如果是配置文件，调用readlines()<strong>最方便</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for line in f.readlines():</span><br><span class="line">    print(line.strip()) # 把末尾的&#39;\n&#39;删掉</span><br></pre></td></tr></table></figure>

<h3 id="文件的打开方式"><a href="#文件的打开方式" class="headerlink" title="文件的打开方式"></a>文件的打开方式</h3><table>
<thead>
<tr>
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</td>
</tr>
<tr>
<td>rb</td>
<td>以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。</td>
</tr>
<tr>
<td>r+</td>
<td>打开一个文件用于读写。文件指针将会放在文件的开头。</td>
</tr>
<tr>
<td>rb+</td>
<td>以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。</td>
</tr>
<tr>
<td>w</td>
<td>打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该 文件不存在，创建新文件。</td>
</tr>
<tr>
<td>wb</td>
<td>以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td>
</tr>
<tr>
<td>w+</td>
<td>打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td>
</tr>
<tr>
<td>wb+</td>
<td>以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td>
</tr>
<tr>
<td>a</td>
<td>打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入 到已有内容之后。如果该文件不存在，创建新文件进行写入。</td>
</tr>
<tr>
<td>ab</td>
<td>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td>
</tr>
<tr>
<td>a+</td>
<td>打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</td>
</tr>
<tr>
<td>ab+</td>
<td>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</td>
</tr>
</tbody></table>
<h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>要读取非UTF-8编码的文本文件，需要给open()函数传入encoding参数，例如，读取GBK编码的文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> f &#x3D; open(&#39;&#x2F;Users&#x2F;michael&#x2F;gbk.txt&#39;, &#39;r&#39;, encoding&#x3D;&#39;gbk&#39;)</span><br><span class="line"> f.read()</span><br><span class="line">&#39;测试&#39;</span><br></pre></td></tr></table></figure>

<p>遇到有些编码不规范的文件，你可能会遇到UnicodeDecodeError，因为在文本文件中可能夹杂了一些非法编码的   字符。遇到这种情况，open()函数还接收一个errors参数，表示如果遇到编码错误后如何处理。最简单的方式是直接忽略：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f &#x3D; open(&#39;&#x2F;Users&#x2F;michael&#x2F;gbk.txt&#39;, &#39;r&#39;, encoding&#x3D;&#39;gbk&#39;, errors&#x3D;&#39;ignore&#39;)</span><br></pre></td></tr></table></figure>

<h4 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h4><p>写文件和读文件是一样的，唯一区别是调用open()函数时，传入标识符’w’或者’wb’表示写文本文件或写二进制文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f &#x3D; open(&#39;&#x2F;Users&#x2F;michael&#x2F;test.txt&#39;, &#39;w&#39;)</span><br><span class="line">f.write(&#39;Hello, world!&#39;)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<p>你可以反复调用write()来写入文件，但是务必要调用f.close()来关闭文件。当我们写文件时，操作系统往往不  会立刻把数据写入磁盘，而是放到内存缓存起来，空闲的时候再慢慢写入。只有调用close()方法时，操作系统才保证把没有写入的数据全部写入磁盘。忘记调用close()的后果是数据可能只写了一部分到磁盘，剩下的丢失了。</p>
<p>所以，还是用with语句来得保险：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with open(&#39;&#x2F;Users&#x2F;michael&#x2F;test.txt&#39;, &#39;w&#39;) as f: f.write(&#39;Hello, world!&#39;)</span><br></pre></td></tr></table></figure>

<p>要写入特定编码的文本文件，请给open()函数传入encoding参数，将字符串自动转换成指定编码。</p>
<p>注意：以’w’模式写入文件时，如果文件已存在，会直接覆盖（相当于删掉后新写入一个文件）。如果我们希望追加到文件末尾怎么办？可以传入’a’以追加（append）模式写入。</p>
]]></content>
      <categories>
        <category>data analytics</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>6. 排列与组合</title>
    <url>/2020/01/20/6.%20%E6%8E%92%E5%88%97%E4%B8%8E%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><p>若有n个独立对象性行排名，则排名方式共计$n!$（n的阶乘）种。</p>
<h2 id="圆形排位"><a href="#圆形排位" class="headerlink" title="圆形排位"></a>圆形排位</h2><blockquote>
<p>例：若让四匹马围一个圈，求出所有可能排位方式的数目。<strong>关键在于吧其中一匹马的位置固定下来</strong>，计算其余3匹马的排位方式。</p>
</blockquote>
<p>如果有n个对象进行圆形排位，可能的排位数据为$(n-1)!$</p>
<blockquote>
<p>$0!$等于1，可以理解为“0个对象只有一种排列方式”</p>
</blockquote>
<h2 id="按类型排位"><a href="#按类型排位" class="headerlink" title="按类型排位"></a>按类型排位</h2><p>若为n个对象排位，其中，第一类对象为k个，第二类对象为j个，第三类对象为m个，……则排位方式的数目计算为：</p>
<p>$$\frac{n!}{j!k!m!…}$$</p>
<p>利用总排位方式数据（$n!$）除以每一类类似对象的排列组合方式数目。</p>
<h2 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h2><p>从一个较大的（n个）对象群体中取出一定数目（r个）对象进行排序，并得出排序方式总数目。</p>
<p>$^nP_r=\frac{n!}{(n-r)!}$ </p>
<ul>
<li>n为对象总数</li>
<li>$^nP_n$为要计算的对象数目</li>
</ul>
<h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>从n个对象中选取r个对象的选取方式的数目，不考虑所选对象的确切顺序。</p>
<p>$$^nC_r=\frac{n!}{r!(n-r)!}$$</p>
<blockquote>
<ul>
<li>$^nC_r$数字越大，位置越高</li>
<li>另一种表示方式$\dbinom{n}{r}$</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>data analytics</category>
      </categories>
      <tags>
        <tag>《深入浅出统计学》</tag>
      </tags>
  </entry>
  <entry>
    <title>4. excel常见的函数</title>
    <url>/2020/01/20/4.%20excel%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="了解函数"><a href="#了解函数" class="headerlink" title="了解函数"></a>了解函数</h2><p><img src="/2020/01/20/4.%20excel%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%BD%E6%95%B0/clipimage048.gif" alt="img"> </p>
<a id="more"></a>

<h2 id="求平均值"><a href="#求平均值" class="headerlink" title="求平均值"></a>求平均值</h2><p><img src="/2020/01/20/4.%20excel%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%BD%E6%95%B0/clipimage050.jpg" alt="img"></p>
<h2 id="IF语句"><a href="#IF语句" class="headerlink" title="IF语句"></a>IF语句</h2><p><img src="/2020/01/20/4.%20excel%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%BD%E6%95%B0/clipimage052.jpg" alt="clipimage052"></p>
<h2 id="VLOOKUP函数"><a href="#VLOOKUP函数" class="headerlink" title="VLOOKUP函数"></a>VLOOKUP函数</h2><p><img src="/2020/01/20/4.%20excel%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%BD%E6%95%B0/clipimage054.jpg" alt></p>
<h2 id="函数错误修复"><a href="#函数错误修复" class="headerlink" title="函数错误修复"></a>函数错误修复</h2><p><img src="/2020/01/20/4.%20excel%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%BD%E6%95%B0/clipimage056.jpg" alt="clipimage056"></p>
<p><img src="/2020/01/20/4.%20excel%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%BD%E6%95%B0/clipimage058.jpg" alt="img"></p>
<p><img src="/2020/01/20/4.%20excel%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%BD%E6%95%B0/clipimage060.jpg" alt="img"> </p>
<h2 id="OFFSET函数"><a href="#OFFSET函数" class="headerlink" title="OFFSET函数"></a>OFFSET函数</h2><p>offset（基准单元格，行位移，列位移，行高，列宽）</p>
<p><img src="/2020/01/20/4.%20excel%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%BD%E6%95%B0/15755973577389e7f2f6ab37144f8a768b8c68ef65c72.png" alt></p>
]]></content>
      <categories>
        <category>data analytics</category>
      </categories>
      <tags>
        <tag>excel</tag>
      </tags>
  </entry>
  <entry>
    <title>4. 概率计算</title>
    <url>/2020/01/20/4.%20%E6%A6%82%E7%8E%87%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<h2 id="概率"><a href="#概率" class="headerlink" title="概率"></a>概率</h2><p><strong>定义</strong></p>
<p>量度某事发生几率的一种数量指标。你可以用概率衡量发生某件事的可能性</p>
<p><strong>求解</strong></p>
<p>$概率=\frac{发生事件可能数目}{所有可能结果的数目}$  即  $P(A)=\frac{n(A)}{n(S)}$</p>
<ol>
<li>S被称为概率空间,或称样本空间,是表示所有可能结果的一种简便表示法。可能发生的事件都是S的子集。</li>
<li>概率只是对事件发生可能性的一种表达,概率并非担保。</li>
</ol>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>事件就是人们能指出其发生可能性的任何事情</p>
<a id="more"></a>

<h3 id="事件的分类："><a href="#事件的分类：" class="headerlink" title="事件的分类："></a>事件的分类：</h3><p><img src="/2020/01/20/4.%20%E6%A6%82%E7%8E%87%E8%AE%A1%E7%AE%97/image20191210145338876.png" alt="image-20191210145338876"></p>
<blockquote>
<h3 id="维恩图"><a href="#维恩图" class="headerlink" title="维恩图"></a>维恩图</h3><p>画一个方框代表样本空间S,然后画几个圆圈代表各个相关事件, 这种图称为维恩图。</p>
</blockquote>
<h4 id="对立事件"><a href="#对立事件" class="headerlink" title="对立事件"></a>对立事件</h4><p>“A不发生”事件有一种简便表示方法一一A。A被称为A的对立事件。<br>$P(A)+P(A’)=1$<br><img src="/2020/01/20/4.%20%E6%A6%82%E7%8E%87%E8%AE%A1%E7%AE%97/clipimage004.gif" alt="img "></p>
<h4 id="互斥事件"><a href="#互斥事件" class="headerlink" title="互斥事件"></a>互斥事件</h4><ul>
<li>如果两个事件是互斥事件,则只有其中ー个事件会发生。<br><img src="/2020/01/20/4.%20%E6%A6%82%E7%8E%87%E8%AE%A1%E7%AE%97/clipimage006.gif" alt="img"></li>
</ul>
<h4 id="相交事件"><a href="#相交事件" class="headerlink" title="相交事件"></a>相交事件</h4><p>交集带来的问题<br>    * 如果两个事件相交, 则这两个事件有可能同时发生。<br> <img src="/2020/01/20/4.%20%E6%A6%82%E7%8E%87%E8%AE%A1%E7%AE%97/clipimage008.gif" alt="img"></p>
<blockquote>
<p><strong>例</strong><br>停球结果为黑色或偶数为相关事件。不能相加<br><img src="/2020/01/20/4.%20%E6%A6%82%E7%8E%87%E8%AE%A1%E7%AE%97/clipimage010.gif" alt="img"><br>当将两个概率相加时,我们将停球结果为“黑色兼偶数”的概率算了两次。<br><img src="/2020/01/20/4.%20%E6%A6%82%E7%8E%87%E8%AE%A1%E7%AE%97/clipimage012.gif" alt="img"></p>
</blockquote>
<blockquote>
<h3 id="交集与并集的表示"><a href="#交集与并集的表示" class="headerlink" title="交集与并集的表示"></a>交集与并集的表示</h3><ul>
<li>A与B的交集，$A\bigcap B$，理解为“与”，表示不同事件的共同要素。</li>
<li>A与B的并集，$A\bigcup B$，理解为“或”，表示A与B的所有要素</li>
<li>若$P(A\bigcup B)=1$,A与B<strong>穷举</strong><br><img src="/2020/01/20/4.%20%E6%A6%82%E7%8E%87%E8%AE%A1%E7%AE%97/image20191210151325703.png" alt="image-20191210151325703"></li>
</ul>
</blockquote>
<h2 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h2><p>以另一个事件的发生为条件的某个事件的发生概率,我们就用“|”符号表示“已知条件”,于是,“以事件B 为已知条件的事件A的概率”就可以简写为:</p>
<p>$P(A|B)$</p>
<p>在已知B已经发生的条件下A的概率</p>
<p><img src="/2020/01/20/4.%20%E6%A6%82%E7%8E%87%E8%AE%A1%E7%AE%97/image20191210152846859.png" alt="image-20191210152846859"></p>
<p>现在要用一种通用方法来计算$P(A|B)$。我们感兴趣的是A和B 同时发生的次数与B发生的所有次数相除的结果。观察维恩图, 得到:</p>
<p>$P(A|B)=\frac{P(A\bigcap B)}{P(B)}$</p>
<p>变化得到：$P(A\bigcap B)= P(A|B) * P(B)$</p>
<p>$P(A\bigcap B)$同样也是$P(B\bigcap A)$,即可得：</p>
<p>$P(B\bigcap A)= P(B|A) * P(A)$</p>
<h2 id="概率树"><a href="#概率树" class="headerlink" title="概率树"></a>概率树</h2><p><img src="/2020/01/20/4.%20%E6%A6%82%E7%8E%87%E8%AE%A1%E7%AE%97/image20191210153717011.png" alt="image-20191210153717011"></p>
<p><strong>利用概率树计算条件概率</strong></p>
<p><img src="/2020/01/20/4.%20%E6%A6%82%E7%8E%87%E8%AE%A1%E7%AE%97/image20191210153743870.png" alt="image-20191210153743870"></p>
<h3 id="概率树计算概率步骤"><a href="#概率树计算概率步骤" class="headerlink" title="概率树计算概率步骤"></a>概率树计算概率步骤</h3><ol>
<li>分出计算概率的层级<br>如：$P(A|B)$则在第一级中涵盖B，第二级中涵盖A</li>
<li>填写已知部分概率</li>
<li>检验<br>每一级分支的概率总和为1，$P(A)=1-P(A’)$</li>
<li>记住公式<br>$P(A|B)=\frac{P(A\bigcap B )}{P(B)}$</li>
</ol>
<h2 id="运用（利用已知概率，求新的概率）"><a href="#运用（利用已知概率，求新的概率）" class="headerlink" title="运用（利用已知概率，求新的概率）"></a>运用（利用已知概率，求新的概率）</h2><p><img src="/2020/01/20/4.%20%E6%A6%82%E7%8E%87%E8%AE%A1%E7%AE%97/image20191210155316206.png" alt="image-20191210155316206"></p>
<p>已知$P(偶|黑)$,算$P(黑|偶)$**</p>
<p>$P(黑|偶)=\frac{P(黑\bigcap偶)}{P(偶)}$</p>
<ol>
<li><p>求$P(黑\bigcap偶)$</p>
<p>$P(黑\bigcap偶)=P(黑)*P(偶|黑)$</p>
<p>$P(黑|偶)=\frac{P(黑)*P(偶|黑)}{P(偶)}$</p>
</li>
<li><p>求$P(偶)$<br>小球停在偶数球位上的情况包括:球位既是黑色又是偶数,或者球位既是红色又是偶数。这两种情况就是小球停在偶数球位上的方式。<br><img src="/2020/01/20/4.%20%E6%A6%82%E7%8E%87%E8%AE%A1%E7%AE%97/image20191210155703107.png" alt="image-20191210155703107"></p>
</li>
<li><p>求$P(黑|偶)$</p>
<p>$P(黑|偶)=\frac{P(黑\bigcap偶)}{P(偶)}$<br>$=\frac{P(黑)<em>P(偶|黑)}{P(黑)</em>P(偶|黑)+P(红)*P(偶|红)}$</p>
</li>
</ol>
<h2 id="贝叶斯定理"><a href="#贝叶斯定理" class="headerlink" title="贝叶斯定理"></a>贝叶斯定理</h2><p><strong>利用已有的概率, 求出要的概率</strong></p>
<p>已知$P(A)$,且已知$P(B｜A)$和$P(B｜A’)$，求出$P(A | B)$</p>
<p>$P(A|B)=\frac{P(A\bigcap B)}{P(B)}$</p>
<p>$P(A|B)=\frac{P(A)<em>P(B|A)}{P(A)</em>P(B|A)+P(A’)*P(B|A’)}$</p>
<p><strong>这就是所谓的贝叶斯定理。</strong></p>
<p><img src="/2020/01/20/4.%20%E6%A6%82%E7%8E%87%E8%AE%A1%E7%AE%97/image20191210160422999.png" alt="image-20191210160422999"></p>
<h2 id="条件概率下事件分类"><a href="#条件概率下事件分类" class="headerlink" title="条件概率下事件分类"></a>条件概率下事件分类</h2><h3 id="相关事件"><a href="#相关事件" class="headerlink" title="相关事件"></a>相关事件</h3><p>如果用通用术语表达就是:如果    $P(AIB)$与$P(A)$不等,则我们说事件A与事件B是相关事件一这等于说事件A与事件B 的概率相互影响。</p>
<h3 id="独立事件"><a href="#独立事件" class="headerlink" title="独立事件"></a>独立事件</h3><p> 如果事件A和事件B相互独立,则事件A的概率不受事件B的影响, 换句话说,对于独立事件来说:<br>$P(A｜B)= P(A)$<br><img src="/2020/01/20/4.%20%E6%A6%82%E7%8E%87%E8%AE%A1%E7%AE%97/clipimage0021575965131650.gif" alt="img"></p>
<h3 id="独立事件概率计算"><a href="#独立事件概率计算" class="headerlink" title="独立事件概率计算"></a>独立事件概率计算</h3><p>$P(A｜B)= \frac{P(A\bigcap B)}{P(B)}$</p>
<ul>
<li>如果A和B是独立事件,则$P(AIB)$与$P(A)$相同。即对于独立事件来说:</li>
</ul>
<p>$P(A∩B)=P(A)*P(B)$</p>
<ul>
<li>即,如果两个事件相互独立,则通过将两个事件各自的概率相乘,可以算出同时发生这两件事的概率。</li>
</ul>
]]></content>
      <categories>
        <category>data analytics</category>
      </categories>
      <tags>
        <tag>《深入浅出统计学》</tag>
      </tags>
  </entry>
  <entry>
    <title>5. 离散概率分布的运用</title>
    <url>/2020/01/20/5.%20%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E7%9A%84%E8%BF%90%E7%94%A8/</url>
    <content><![CDATA[<p>利用概率预测长期结果，量度预测结果的确定性。</p>
<h2 id="随机变量"><a href="#随机变量" class="headerlink" title="随机变量"></a>随机变量</h2><p>一个可以等于一系列数值的变量</p>
<h2 id="概率分布"><a href="#概率分布" class="headerlink" title="概率分布"></a>概率分布</h2><p>随机变量的概率分布，即每一个<strong>随机变量</strong>所对应的概率的集合。</p>
<ul>
<li>随机变量用大写字母表示，如X或者Y</li>
<li>变量能采用的特定数值，用小写字母表示，如x或y</li>
</ul>
<p>$P（X=x）$表示变量X取特定数值x的概率。</p>
<a id="more"></a>

<p><img src="/2020/01/20/5.%20%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E7%9A%84%E8%BF%90%E7%94%A8/image-20191211113723410.png" alt="image-20191211113723410"></p>
<p>这个变量具有<strong>离散性</strong>，变量只能取确定数值。</p>
<blockquote>
<p> <strong>概率分布的作用</strong>利用概率分布确定预期结果。</p>
</blockquote>
<h2 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h2><ul>
<li>类似均值，用于描述概率分布。</li>
</ul>
<p>求解：将每个数值乘数值发生的概率，将所有乘积求和。</p>
<p>$E（X）=\sum xP(X=x)$</p>
<h2 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h2><ul>
<li>结果的分散性<br>期望指出一个变量的典型值或平均值，并不提供数值分散性的任何信息。利用方差来度量这种分散性。</li>
</ul>
<p>$Var(X)=E(X-\mu)^2$  计算类比期望的计算，可以得到：</p>
<p>$E(X-\mu)^2=\sum (x-\mu)^2P(X=x)$</p>
<ul>
<li>取每个数x，求出$（x-\mu）^2$,所得结果乘发生概率</li>
<li>将乘积相加</li>
</ul>
<p>$Var(X)$量度收益的变化范围。</p>
<h2 id="标准差"><a href="#标准差" class="headerlink" title="标准差"></a>标准差</h2><p>$\sigma = \sqrt{Var(X)}$</p>
<h2 id="概率分布计算"><a href="#概率分布计算" class="headerlink" title="概率分布计算"></a>概率分布计算</h2><h3 id="线性变化"><a href="#线性变化" class="headerlink" title="线性变化"></a>线性变化</h3><p>X（旧随机变量）与Y（新随机变量）存在线性关系，$Y=aX+b$</p>
<ul>
<li>$E(Y)=a E(X)+b$</li>
<li>$Var(Y)=a^2Var(X)$</li>
</ul>
<h3 id="独立观测值"><a href="#独立观测值" class="headerlink" title="独立观测值"></a>独立观测值</h3><p>赌博机中，每一局称为事件，每一局的结果称为观测值，每个观测值具有相同的期望和方差</p>
<p>​     $X_1$   第一局的观测值</p>
<p>​    $X_2$   第二局的观测值</p>
<p>​    $X_1,X_2$具有相同的概率分布</p>
<p>结果应该为：</p>
<ul>
<li><p>$E(X_1+X_2+X_3+…+X_n)=nE(X)$</p>
</li>
<li><p>$Var(X_1+X_2+X_3+…+X_n)=nVar(X)$</p>
</li>
</ul>
<blockquote>
<p>$X_1+X_2$表示两个观测值，2X表示一个观测值，可能数值翻倍，二者为<strong>两个概念</strong></p>
</blockquote>
<h2 id="随机变量加减计算"><a href="#随机变量加减计算" class="headerlink" title="随机变量加减计算"></a>随机变量加减计算</h2><blockquote>
<p> X，Y相互独立</p>
</blockquote>
<ul>
<li><p>加法</p>
<ul>
<li><p>$E(X)+E(Y)=E(X+Y)$</p>
</li>
<li><p>$E(X+Y)=E(X)+E(Y)$</p>
</li>
<li><p>$Var(X+Y)=Var(X)+Var(Y)$</p>
<p><img src="/2020/01/20/5.%20%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E7%9A%84%E8%BF%90%E7%94%A8/image-20191211141631239.png" alt="image-20191211141631239"></p>
</li>
</ul>
</li>
<li><p>减法</p>
<ul>
<li><p>$E(X-Y)=E(X)-E(Y)$</p>
</li>
<li><p><strong>$Var(X-Y)=Var(X)+Var(Y)$</strong></p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>若将两个随机变量相减，方差要相加</strong></p>
</blockquote>
<ul>
<li><p>线性变化相加</p>
<ul>
<li><p>$E(aX+bY)=aE(X)+bE(Y)$</p>
</li>
<li><p>$Var(aX+bY)=a^2Var(X)+b^2Var(Y)$</p>
</li>
</ul>
</li>
<li><p>线性变化相加</p>
<ul>
<li><p>$E(aX-bY)=aE(X)-bE(Y)$</p>
</li>
<li><p>$Var(aX-bY)=a^2Var(X)+b^2Var(Y)$</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>data analytics</category>
      </categories>
      <tags>
        <tag>《深入浅出统计学》</tag>
      </tags>
  </entry>
  <entry>
    <title>9. 再谈正态分布的运用</title>
    <url>/2020/01/20/9.%20%E5%86%8D%E8%B0%88%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83%E7%9A%84%E8%BF%90%E7%94%A8/</url>
    <content><![CDATA[<h2 id="正态分布计算"><a href="#正态分布计算" class="headerlink" title="正态分布计算"></a>正态分布计算</h2><h3 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h3><blockquote>
<p><strong>离散概率分布</strong>：</p>
<p>$E(X+Y)=E(X)+E(Y)$</p>
<p>$Var(X+Y)=Var(X)+Var(Y)$</p>
</blockquote>
<p><strong>已知 $X$<del>$N(\mu_x,\sigma_x^2)$ 且  $Y$</del>$N(\mu_y,\sigma_y^2)，$</strong>则==X+Y~$N(\mu,\sigma^2)$==</p>
<p>其中 $\mu=\mu_x+\mu_y$  ，$\sigma^2=\sigma_x^2+\sigma_y^2$</p>
<p><img src="/2020/01/20/9.%20%E5%86%8D%E8%B0%88%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83%E7%9A%84%E8%BF%90%E7%94%A8/image-20200108104627553.png" alt="image-20200108104627553"></p>
<p>变量相加后，变异性（$\sigma$ ）增加，图形变扁，总面积仍小于1</p>
<h3 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h3><p>减法同加法相同</p>
<h3 id="线性变化"><a href="#线性变化" class="headerlink" title="线性变化"></a>线性变化</h3><p>==线性变化描述了数据的基本变化==</p>
<p>$aX+b$~$N(a\mu+b,a^2\sigma^2)$</p>
<h3 id="独立观测结果"><a href="#独立观测结果" class="headerlink" title="独立观测结果"></a>独立观测结果</h3><a id="more"></a>

<p>==独立观察结果描述你有多少数值==</p>
<p>$X_1+X_2+…+X_n$~$N(n\mu,n\sigma^2)$</p>
<blockquote>
<p><strong>注</strong>：</p>
<p>若一位成年人的体重分布为X~$N(180,625)$,计算4位成年人的综合体重概率分布</p>
<ul>
<li><p>线性变化<br>若使用4X，实际描述的是一位成年人体重放大4倍后的效果</p>
</li>
<li><p>独立观测</p>
<p>$X_1+X_2+X_3+X_4$</p>
<p>$X_1$,$X_2$,$X_3$,$X_4$是X的独立观察结果</p>
</li>
</ul>
</blockquote>
<h2 id="二项分布近似替代"><a href="#二项分布近似替代" class="headerlink" title="二项分布近似替代"></a>二项分布近似替代</h2><h3 id="替代条件"><a href="#替代条件" class="headerlink" title="替代条件"></a>替代条件</h3><p><strong>一般情况，当np和nq双双大于5时(n为次数，p为成功概率，q=1-p)，可以用正态分布近似替代二项分布。</strong></p>
<p><img src="/2020/01/20/9.%20%E5%86%8D%E8%B0%88%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83%E7%9A%84%E8%BF%90%E7%94%A8/image-20200108112501939.png" alt="image-20200108112501939"></p>
<h3 id="替代场景"><a href="#替代场景" class="headerlink" title="替代场景"></a>替代场景</h3><p><strong>求解均值和方差</strong></p>
<p>直接从二项分布的发哦均值与方差方便计算概率：</p>
<p>$\mu=np$</p>
<p>$\sigma^2=npq$</p>
<p><img src="/2020/01/20/9.%20%E5%86%8D%E8%B0%88%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83%E7%9A%84%E8%BF%90%E7%94%A8/image-20200108113637333.png" alt="image-20200108113637333"></p>
<blockquote>
<p>部分近似条件可能为np&gt;10,nq&gt;10</p>
</blockquote>
<h3 id="误差修正"><a href="#误差修正" class="headerlink" title="误差修正"></a>误差修正</h3><ul>
<li>二项分布 P(X&lt;6)</li>
</ul>
<p><img src="/2020/01/20/9.%20%E5%86%8D%E8%B0%88%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83%E7%9A%84%E8%BF%90%E7%94%A8/image-20200108114446054.png" alt="image-20200108114446054"></p>
<ul>
<li>正态分布 P(X&lt;6)</li>
</ul>
<p><img src="/2020/01/20/9.%20%E5%86%8D%E8%B0%88%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83%E7%9A%84%E8%BF%90%E7%94%A8/image-20200108114517904.png" alt="image-20200108114517904"></p>
<ul>
<li>两者存在误差</li>
</ul>
<p><img src="/2020/01/20/9.%20%E5%86%8D%E8%B0%88%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83%E7%9A%84%E8%BF%90%E7%94%A8/image-20200108114553609.png" alt="image-20200108114553609"></p>
<p><strong>误差原因:</strong>离散数值为6,转化连续标度,考虑所有取整后等于6的数,即要考虑从5.5-6.5的数字范围.</p>
<p>计算P(X&lt;6)应该计算P(X&lt;5.5),这种调整称为<strong>连续性修正</strong></p>
<table>
<thead>
<tr>
<th>所求二项分布</th>
<th>连续性修正后</th>
</tr>
</thead>
<tbody><tr>
<td>P(X≤a)</td>
<td>P(X&lt;a+0.5)</td>
</tr>
<tr>
<td>P(X≥a)</td>
<td>P(X&gt;a-0.5)</td>
</tr>
<tr>
<td>P(a≤X≤b)</td>
<td>P(a-0.5&lt;X&lt;b+0.5)</td>
</tr>
</tbody></table>
<h2 id="泊松分布近似替代"><a href="#泊松分布近似替代" class="headerlink" title="泊松分布近似替代"></a>泊松分布近似替代</h2><p><img src="/2020/01/20/9.%20%E5%86%8D%E8%B0%88%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83%E7%9A%84%E8%BF%90%E7%94%A8/image-20200108115833603.png" alt="image-20200108115833603"></p>
<p>$X$~$Po(\lambda )$</p>
<ul>
<li>当$\lambda$&gt;15,可以用X~$N(\lambda,\lambda)$ 近似替代</li>
</ul>
<p><strong>如果用正态分布近似替代泊松分布,为保证结果正确,需要进行==连续性修正==</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2020/01/20/9.%20%E5%86%8D%E8%B0%88%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83%E7%9A%84%E8%BF%90%E7%94%A8/image-20200108120215036.png" alt="image-20200108120215036"></p>
]]></content>
      <categories>
        <category>data analytics</category>
      </categories>
      <tags>
        <tag>《深入浅出统计学》</tag>
      </tags>
  </entry>
  <entry>
    <title>Python速查</title>
    <url>/2020/01/20/Python%20%E9%80%9F%E6%9F%A5/</url>
    <content><![CDATA[<h2 id="常规"><a href="#常规" class="headerlink" title="常规"></a>常规</h2><ul>
<li>Python 对大小写敏感</li>
<li>Python 的索引从 0 开始</li>
<li>Python 使用空白符（制表符或空格）来缩进代码，而不是使用花括号</li>
</ul>
<h3 id="获取帮助"><a href="#获取帮助" class="headerlink" title="获取帮助"></a>获取帮助</h3><ul>
<li>获取主页帮助：<code>help()</code></li>
<li>获取函数帮助：<code>help(str.replace)</code></li>
<li>获取模块帮助：<code>help(re)</code></li>
</ul>
<a id="more"></a>

<h3 id="模块-库"><a href="#模块-库" class="headerlink" title="模块(库)"></a>模块(库)</h3><p>Python的模块只是一个简单地以 <code>.py</code> 为后缀的文件。</p>
<ul>
<li>列出模块内容：<code>dir(module1)</code></li>
<li>导入模块：<code>import module</code></li>
<li>调用模块中的函数：<code>module1.func1()</code></li>
</ul>
<blockquote>
<p><strong>注</strong>：<code>import</code>语句会创建一个新的命名空间(namespace)，并且在该命名空间内执行<code>.py</code>文件中的所有语句。如果你想把模块内容导入到当前命名空间，请使用<code>from module1 import *</code>语句。</p>
</blockquote>
<h2 id="数值类类型"><a href="#数值类类型" class="headerlink" title="数值类类型"></a>数值类类型</h2><p>查看变量的数据类型：<code>type(variable)</code></p>
<h3 id="六种经常使用的数据类型"><a href="#六种经常使用的数据类型" class="headerlink" title="六种经常使用的数据类型"></a>六种经常使用的数据类型</h3><ol>
<li><p><strong>int/long</strong>：过大的 <code>int</code> 类型会被自动转化为 <code>long</code> 类型</p>
</li>
<li><p><strong>float</strong>：64 位，Python 中没有 <code>double</code> 类型</p>
</li>
<li><p><strong>bool</strong>：真或假</p>
</li>
<li><p><strong>str</strong>：在 Python 2 中默认以 ASCII 编码，而在 Python 3 中默认以 Unicode 编码</p>
<ul>
<li><p>字符串可置于单/双/三引号中</p>
</li>
<li><p>字符串是字符的序列，因此可以像处理其他序列一样处理字符串</p>
</li>
<li><p>特殊字符可通过 <code>\</code> 或者前缀 <code>r</code> 实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">r'this\f?ff'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串可通过多种方式格式化：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">template = <span class="string">'%.2f %s haha $%d'</span>;</span><br><span class="line">str1 = template % (<span class="number">4.88</span>, <span class="string">'hola'</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>NoneType(None)</strong>：Python “null”值（<code>None</code>对象<strong>只</strong>存在一个实例）</p>
<ul>
<li><p><code>None</code>不是一个保留关键字，而是<code>NoneType</code>的一个唯一实例</p>
</li>
<li><p><code>None</code>通常是可选函数参数的默认值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(a, b, c=None)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>None</code>的常见用法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> variable <span class="keyword">is</span> <span class="literal">None</span> :</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>datetime</strong>：Python内置的<code>datetime</code>模块提供了<code>datetime</code>、<code>data</code>以及<code>time</code>类型。</p>
<ul>
<li><code>datetime</code>组合了存储于<code>date</code>和<code>time</code>中的信息<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从字符串中创建 datetime</span></span><br><span class="line">dt1 = datetime.strptime(<span class="string">'20091031'</span>, <span class="string">'%Y%m%d'</span>)</span><br><span class="line"><span class="comment"># 获取 date 对象</span></span><br><span class="line">dt1.date()</span><br><span class="line"><span class="comment"># 获取 time 对象</span></span><br><span class="line">dt1.time()</span><br><span class="line"><span class="comment"># 将 datetime 格式化为字符串</span></span><br><span class="line">dt1.strftime(<span class="string">'%m/%d/%Y%H:%M'</span>)</span><br><span class="line"><span class="comment"># 更改字段值</span></span><br><span class="line">dt2 = dt1.replace(minute=<span class="number">0</span>, second=<span class="number">30</span>)</span><br><span class="line"><span class="comment"># 做差, diff 是一个 datetime.timedelta 对象</span></span><br><span class="line">diff = dt1 - dt2</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>注</strong>：</p>
<ul>
<li><code>str</code>、<code>bool</code>、<code>int</code>和<code>float</code>同时也是显式类型转换函数。</li>
<li>除字符串和元组外，Python 中的绝大多数对象都是可变的。</li>
</ul>
</blockquote>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><blockquote>
<p><strong>注</strong>：所有的“非只读(non-Get)”函数调用，比如下面例子中的<code>list1.sort()</code>，除非特别声明，都是原地操作(不会创建新的对象)。</p>
</blockquote>
<h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>元组是 Python 中任何类型的对象的一个一维、固定长度、<strong>不可变</strong>的序列。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建元组</span></span><br><span class="line">tup1 = <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span></span><br><span class="line">tup1 = (<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)</span><br><span class="line"><span class="comment"># 创建嵌套元组</span></span><br><span class="line">tup1 = (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>), (<span class="number">7</span>, <span class="number">8</span>)</span><br><span class="line"><span class="comment"># 将序列或迭代器转化为元组</span></span><br><span class="line">tuple([<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>])</span><br><span class="line"><span class="comment"># 连接元组</span></span><br><span class="line">tup1 + tup2</span><br><span class="line"><span class="comment"># 解包元组</span></span><br><span class="line">a, b, c = tup1</span><br></pre></td></tr></table></figure>

<p><strong>元组应用</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 交换两个变量的值</span></span><br><span class="line">a, b = b, a</span><br></pre></td></tr></table></figure>

<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>列表是 Python 中任何类型的对象的一个一维、非固定长度、<strong>可变</strong>（比如内容可以被修改）的序列。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建列表</span></span><br><span class="line">list1 = [<span class="number">1</span>, <span class="string">'a'</span>, <span class="number">3</span>]</span><br><span class="line">list1 = list(tup1)</span><br><span class="line"><span class="comment"># 连接列表</span></span><br><span class="line">list1 + list2</span><br><span class="line">list1.extend(list2)</span><br><span class="line"><span class="comment"># 追加到列表的末尾</span></span><br><span class="line">list1.append(<span class="string">'b'</span>)</span><br><span class="line"><span class="comment"># 插入指定位置</span></span><br><span class="line">list1.insert(PosIndex, <span class="string">'a'</span>)</span><br><span class="line"><span class="comment"># 反向插入，即弹出给定位置的值/删除</span></span><br><span class="line">ValueAtIdx = list1.pop(PosIndex)</span><br><span class="line"><span class="comment"># 移除列表中的第一个值, a 必须是列表中第一个值</span></span><br><span class="line">list1.remove(<span class="string">'a'</span>)</span><br><span class="line"><span class="comment"># 检查成员</span></span><br><span class="line">3 in list1 =&gt; True or False</span><br><span class="line"><span class="comment"># 对列表进行排序</span></span><br><span class="line">list1.sort()</span><br><span class="line"><span class="comment"># 按特定方式排序</span></span><br><span class="line">list1.sort(key=len) <span class="comment"># 按长度排序</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>使用 + 连接列表会有比较大的开支，因为这个过程中会创建一个新的列表，然后复制对象。因此，使用<code>extend()</code>是更明智的选择。</li>
<li><code>insert</code>和<code>append</code>相比会有更大的开支（时间/空间）。</li>
<li>在列表中检查是否包含一个值会比在字典和集合中慢很多，因为前者需要进行线性扫描，而后者是基于哈希表的，所以只需要花费常数时间。</li>
</ul>
</blockquote>
<h4 id="内置的bisect模块"><a href="#内置的bisect模块" class="headerlink" title="内置的bisect模块"></a>内置的<code>bisect</code>模块</h4><ul>
<li>对一个排序好的列表进行二分查找或插入</li>
<li><code>bisect.bisect</code>找到元素在列表中的位置，<code>bisect.insort</code>将元素插入到相应位置。</li>
<li>用法：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line">list1 = list(range(<span class="number">10</span>))</span><br><span class="line"><span class="comment">#找到 5 在 list1 中的位置，从 1 开始，因此 position = index + 1</span></span><br><span class="line">bisect.bisect(list1, <span class="number">5</span>)</span><br><span class="line"><span class="comment">#将 3.5 插入 list1 中合适位置</span></span><br><span class="line">bisect.insort(list1, <span class="number">3.5</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p><strong>注</strong>：<code>bisect</code> 模块中的函数并不会去检查列表是否排序好，因为这会花费很多时间。所以，对未排序好的列表使用这些函数也不会报错，但可能会返回不正确的结果。</p>
</blockquote>
<h3 id="针对序列类型的切片"><a href="#针对序列类型的切片" class="headerlink" title="针对序列类型的切片"></a>针对序列类型的切片</h3><blockquote>
<p>序列类型包括<code>str</code>、<code>array</code>、<code>tuple</code>、<code>list</code>等。</p>
</blockquote>
<p>用法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1[start:stop]</span><br><span class="line"><span class="comment"># 如果使用 step</span></span><br><span class="line">list1[start:stop:step]</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注</strong>：</p>
<ul>
<li>切片结果包含 <code>start</code> 索引，但不包含 <code>stop</code> 索引</li>
<li><code>start/stop</code> 索引可以省略，如果省略，则默认为序列从开始到结束，如 <code>list1 == list1[:]</code> 。</li>
</ul>
</blockquote>
<p><code>step</code> 的应用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 取出奇数位置的元素</span></span><br><span class="line">list1[::<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 反转字符串</span></span><br><span class="line">str1[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<h3 id="字典（哈希表）"><a href="#字典（哈希表）" class="headerlink" title="字典（哈希表）"></a>字典（哈希表）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建字典</span></span><br><span class="line">dict1 = &#123;<span class="string">'key1'</span>: <span class="string">'value1'</span>, <span class="number">2</span>: [<span class="number">3</span>, <span class="number">2</span>]&#125;</span><br><span class="line"><span class="comment"># 从序列创建字典</span></span><br><span class="line">dict(zip(KeyList, ValueList))</span><br><span class="line"><span class="comment"># 获取/设置/插入元素</span></span><br><span class="line">dict1[<span class="string">'key1'</span>]</span><br><span class="line">dict1[<span class="string">'key1'</span>] = <span class="string">'NewValue'</span></span><br><span class="line"><span class="comment"># get 提供默认值</span></span><br><span class="line">dict1.get(<span class="string">'key1'</span>, DefaultValue)</span><br><span class="line"><span class="comment"># 检查键是否存在</span></span><br><span class="line"><span class="string">'key1'</span> <span class="keyword">in</span> dict1</span><br><span class="line"><span class="comment"># 获取键列表</span></span><br><span class="line">dict1.keys()</span><br><span class="line"><span class="comment"># 获取值列表</span></span><br><span class="line">dict1.values()</span><br><span class="line"><span class="comment"># 更新值</span></span><br><span class="line">dict1.update(dict2)  <span class="comment"># dict1 的值被 dict2 替换</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>如果键不存在，则会出现 <code>KeyError Exception</code> 。</li>
<li>当键不存在时，如果 <code>get()</code>不提供默认值则会返回 <code>None</code> 。</li>
<li>以相同的顺序返回键列表和值列表，但顺序不是特定的，也就是说极大可能非排序。</li>
</ul>
</blockquote>
<h4 id="有效字典键类型"><a href="#有效字典键类型" class="headerlink" title="有效字典键类型"></a>有效字典键类型</h4><ul>
<li>键必须是不可变的，比如标量类型(<code>int</code>、<code>float</code>、<code>string</code>)或者元组（元组中的所有对象也必须是不可变的）。</li>
<li>这儿涉及的技术术语是“可哈希(hashability)”。可以用函数<code>hash()</code>来检查一个对象是否是可哈希的，比如 <code>hash(&#39;This is a string&#39;)</code>会返回一个哈希值，而<code>hash([1,2])</code>则会报错（不可哈希）。</li>
</ul>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><ul>
<li><p>一个集合是一些<strong>无序</strong>且唯一的元素的聚集；</p>
</li>
<li><p>你可以把它看成只有键的字典；</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建集合</span></span><br><span class="line">set([<span class="number">3</span>, <span class="number">6</span>, <span class="number">3</span>])</span><br><span class="line">&#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="comment"># 子集测试</span></span><br><span class="line">set1.issubset(set2)</span><br><span class="line"><span class="comment"># 超集测试</span></span><br><span class="line">set1.issuperset(set2)</span><br><span class="line"><span class="comment"># 测试两个集合中的元素是否完全相同</span></span><br><span class="line">set1 == set2</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>集合操作</strong></p>
<ul>
<li>并（或）：<code>set1 | set2</code></li>
<li>交（与）：<code>set1 &amp; set2</code></li>
<li>差：<code>set1 - set2</code></li>
<li>对称差（异或）：<code>set1 ^ set2</code></li>
</ul>
</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>Python 的函数参数传递是通过<strong>引用传递</strong>。</p>
<ul>
<li><p>基本形式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(posArg1, keywordArg1=<span class="number">1</span>, ..)</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注</strong>：</p>
<ul>
<li>关键字参数必须跟在位置参数的后面；</li>
<li>默认情况下，Python 不会“延迟求值”，表达式的值会立刻求出来。</li>
</ul>
</blockquote>
</li>
<li><p>函数调用机制</p>
<ol>
<li>所有函数均位于模块内部作用域。见“模块”部分。</li>
<li>在调用函数时，参数被打包成一个元组和一个字典，函数接收一个元组<code>args</code>和一个字典<code>kwargs</code>，然后在函数内部解包。</li>
</ol>
</li>
<li><p>“函数是对象”的常见用法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(ops = [str.strip, user_define_func, ..], ..)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> function <span class="keyword">in</span> ops:</span><br><span class="line">        value = function(value)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li>如果函数直到结束都没有<code>return</code>语句，则返回<code>None</code>。</li>
<li>如果有多个返回值则通过<strong>一个</strong>元组来实现。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> (value1, value2)</span><br><span class="line">value1, value2 = func1(..)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="匿名函数（又称-LAMBDA-函数）"><a href="#匿名函数（又称-LAMBDA-函数）" class="headerlink" title="匿名函数（又称 LAMBDA 函数）"></a>匿名函数（又称 LAMBDA 函数）</h3><ul>
<li>什么是匿名函数？</li>
</ul>
<p>匿名函数是一个只包含一条语句的简单函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lambda</span> x : x * <span class="number">2</span></span><br><span class="line"><span class="comment"># def func1(x) : return x * 2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>匿名函数的应用：“柯里化(curring)”，即利用已存在函数的部分参数来派生新的函数。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ma60 = <span class="keyword">lambda</span> x : pd.rolling_mean(x, <span class="number">60</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="一些有用的函数（针对数据结构）"><a href="#一些有用的函数（针对数据结构）" class="headerlink" title="一些有用的函数（针对数据结构）"></a>一些有用的函数（针对数据结构）</h3><ol>
<li><p><strong>Enumerate</strong> 返回一个序列<code>(i, value)</code>元组，<code>i</code> 是当前 <code>item</code> 的索引。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i, value <span class="keyword">in</span> enumerate(collection):</span><br></pre></td></tr></table></figure>

<ul>
<li>应用：创建一个序列中值与其在序列中的位置的字典映射（假设每一个值都是唯一的）。</li>
</ul>
</li>
<li><p><strong>Sorted</strong> 可以从任意序列中返回一个排序好的序列。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">sorted([2, 1, 3]) =&gt; [1, 2, 3]</span><br></pre></td></tr></table></figure>

<ul>
<li>应用：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sorted(set('abc bcd')) =&gt; [' ', 'a', 'b', 'c', 'd']</span><br><span class="line"><span class="comment"># 返回一个字符串排序后无重复的字母序列</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>Zip</strong> 函数可以把许多列表、元组或其他序列的元素配对起来创建一系列的元组。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">zip(seq1, seq2) =&gt; [('seq1_1', 'seq2_1'), (..), ..]</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>zip()</code>可以接收任意数量的序列作为参数，但是产生的元素的数目取决于最短的序列。</p>
</li>
<li><p>应用：多个序列同时迭代：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i, (a, b) <span class="keyword">in</span> enumerate(zip(seq1, seq2)):</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>unzip</code>：另一种思考方式是把一些行转化为一些列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">seq1, seq2 = unzip(zipOutput)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>Reversed</strong> 将一个序列的元素以逆序迭代。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list(reversed(range(<span class="number">10</span>)))</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>reversed()</code> 会返回一个迭代器，<code>list()</code> 使之成为一个列表。</p>
</blockquote>
</li>
</ol>
<h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><ol>
<li><p>用于 <code>if-else</code> 条件中的操作符：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">var1 <span class="keyword">is</span> var2  <span class="comment"># 检查两个变量是否是相同的对象</span></span><br><span class="line"></span><br><span class="line">var1 <span class="keyword">is</span> <span class="keyword">not</span> var2  <span class="comment"># 检查两个变量是否是不同的对象</span></span><br><span class="line"></span><br><span class="line">var1 == var2  <span class="comment"># 检查两个变量的值是否相等</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注</strong>：Python 中使用 <code>and</code>、<code>or</code>、<code>not</code> 来组合条件，而不是使用 <code>&amp;&amp;</code>、<code>||</code>、<code>!</code> 。</p>
</blockquote>
</li>
<li><p><code>for</code>循环的常见用法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> iterator:  <span class="comment"># 可迭代对象（list、tuple）或迭代器</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> a, b, c <span class="keyword">in</span> iterator:  <span class="comment"># 如果元素是可以解包的序列</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>pass</code>：无操作语句，在不需要进行任何操作的块中使用。</p>
</li>
<li><p>三元表达式，又称简洁的 <code>if-else</code>，基本形式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">value = true-expr <span class="keyword">if</span> condition <span class="keyword">else</span> false-expr</span><br></pre></td></tr></table></figure>
</li>
<li><p>Python 中没有 <code>switch/case</code> 语句，请使用 <code>if/elif</code>。</p>
</li>
</ol>
<h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><ol>
<li><p><strong>对象</strong>是 Python 中所有类型的根。</p>
</li>
<li><p>万物（数字、字符串、函数、类、模块等）皆为对象，每个对象均有一个“类型(type)”。对象变量是一个指向变量在内存中位置的指针。</p>
</li>
<li><p>所有对象均会被<strong>引用计数</strong>。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">sys.getrefcount(5) =&gt; x</span><br><span class="line">a = <span class="number">5</span>, b = a</span><br><span class="line"><span class="comment"># 上式会在等号的右边创建一个对象的引用，因此 a 和 b 均指向 5</span></span><br><span class="line">sys.getrefcount(<span class="number">5</span>)</span><br><span class="line">=&gt; x + 2</span><br><span class="line">del(a); sys.getrefcount(5) =&gt; x + 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>类的基本形式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># 'self' 等价于 Java/C++ 中的 'this'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">memberFunc1</span><span class="params">(self, arg1)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">classFunc2</span><span class="params">(arg1)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">obj1 = MyObject(<span class="string">'name1'</span>)</span><br><span class="line">obj1.memberFunc1(<span class="string">'a'</span>)</span><br><span class="line">MyObject.classFunc2(<span class="string">'b'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>有用的交互式工具：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dir(variable1)  <span class="comment"># 列出对象的所有可用方法</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="常见字符串操作"><a href="#常见字符串操作" class="headerlink" title="常见字符串操作"></a>常见字符串操作</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过分隔符连接列表/元组</span></span><br><span class="line">', '.join([ 'v1', 'v2', 'v3']) =&gt; 'v1, v2, v3'</span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式化字符串</span></span><br><span class="line">string1 = <span class="string">'My name is &#123;0&#125;　&#123;name&#125;'</span></span><br><span class="line">newString1 = string1.format(<span class="string">'Sean'</span>, name =　<span class="string">'Chen'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分裂字符串</span></span><br><span class="line">sep = <span class="string">'-'</span>;</span><br><span class="line">stringList1 =　string1.split(sep)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取子串</span></span><br><span class="line">start = <span class="number">1</span>;</span><br><span class="line">string1[start:<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 补 '0' 向右对齐字符串</span></span><br><span class="line">month = <span class="string">'5'</span>;</span><br><span class="line">month.zfill(2) =&gt; '05'</span><br><span class="line">month = <span class="string">'12'</span>;</span><br><span class="line">month.zfill(2) =&gt; '12'</span><br><span class="line">month.zfill(3) =&gt; '012'</span><br></pre></td></tr></table></figure>

<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><ol>
<li><p>基本形式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="keyword">print</span> e</span><br><span class="line"><span class="keyword">except</span> (TypeError, AnotherError):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="keyword">pass</span>  <span class="comment"># 清理，比如 close db;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>手动引发异常：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">raise</span> AssertionError  <span class="comment"># 断言失败</span></span><br><span class="line"><span class="keyword">raise</span> SystemExit</span><br><span class="line"><span class="comment"># 请求程序退出</span></span><br><span class="line"><span class="keyword">raise</span> RuntimeError(<span class="string">'错误信息 :..'</span>)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="列表、字典以及元组的推导表达式"><a href="#列表、字典以及元组的推导表达式" class="headerlink" title="列表、字典以及元组的推导表达式"></a>列表、字典以及元组的推导表达式</h2><p>使代码更加易读易写的语法糖。</p>
<ol>
<li><p><strong>列表推导</strong></p>
<ul>
<li>用一个简练的表达式，通过筛选一个数据集并且转换经过筛选的元素的方式来简明地生成新列表。</li>
<li>基本形式：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[expr <span class="keyword">for</span> val <span class="keyword">in</span> collection <span class="keyword">if</span> condition]</span><br></pre></td></tr></table></figure>
等价于<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> val <span class="keyword">in</span> collection:</span><br><span class="line">    <span class="keyword">if</span> condition:</span><br><span class="line">        result.append(expr)</span><br></pre></td></tr></table></figure>
可以省略过滤条件，只留下表达式。</li>
</ul>
</li>
<li><p><strong>字典推导</strong></p>
<ul>
<li>基本形式：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;key-expr : value-expr <span class="keyword">for</span> value <span class="keyword">in</span> collection <span class="keyword">if</span> condition&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>集合推导</strong></p>
<ul>
<li>基本形式：和列表推导一样，不过是用 <code>()</code> 而不是 <code>[]</code> 。</li>
</ul>
</li>
<li><p><strong>嵌套列表</strong></p>
<ul>
<li>基本形式：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[expr <span class="keyword">for</span> val <span class="keyword">in</span> collection <span class="keyword">for</span> innerVal <span class="keyword">in</span> val <span class="keyword">if</span> condition]</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>Python自带<code>unittest</code>模块，可供我们编写单元测试。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br></pre></td></tr></table></figure>

<p>我们可以编写继承于<code>unittest.TestCase</code>测试类的子类，并在子类中编写具体的测试函数。测试函数命必须以<code>test_</code>开头，否则不会被识别为测试函数，进而不会在运行单元测试时被运行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestSubclass</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_func</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.assertEqual(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="comment"># 可以通过msg关键字参数提供测试失败时的提示消息</span></span><br><span class="line">        self.assertEqual(<span class="number">0</span>, <span class="number">0</span>, msg=<span class="string">'modified message'</span>)</span><br><span class="line">        self.assertGreater(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">        self.assertIn(<span class="number">0</span>, [<span class="number">0</span>])</span><br><span class="line">        self.assertTrue(<span class="literal">True</span>)</span><br><span class="line">        <span class="comment"># 测试是否会抛出异常</span></span><br><span class="line">        <span class="keyword">with</span> self.assertRaises(KeyError):</span><br><span class="line">            _ = dict()[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 被@unittest.skip装饰器装饰的测试类或测试函数会被跳过</span></span><br><span class="line"><span class="meta">    @unittest.skip(reason='just skip')</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_skip</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'I shall never be tested'</span>)</span><br></pre></td></tr></table></figure>

<p>另外，<code>unittest.TestCase</code>中还有两个特殊的成员函数，他们分别会在调用每一个测试函数的前后运行。在测试前连接数据库并在测试完成后断开连接是一种常见的使用场景。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="comment"># To do: connect to the database</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tearDown</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="comment"># To do: release the connection</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_database</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="comment"># To do: test the database</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>测试类编写完毕后，可以通过添加以下代码来将当前文件当成正常的Python脚本使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  unittest.main()</span><br></pre></td></tr></table></figure>
<h1 id="Python数据科学速查表"><a href="#Python数据科学速查表" class="headerlink" title="Python数据科学速查表"></a>Python数据科学速查表</h1><p> <a href="附件\Python数据科学速查表.pdf">Python数据科学速查表</a> </p>
]]></content>
      <categories>
        <category>data analytics</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>8. 正太分布的运用</title>
    <url>/2020/01/20/8.%20%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83%E7%9A%84%E8%BF%90%E7%94%A8/</url>
    <content><![CDATA[<h2 id="离散与连续数据"><a href="#离散与连续数据" class="headerlink" title="离散与连续数据"></a>离散与连续数据</h2><p><strong>离散数据</strong>：</p>
<ul>
<li>数据由==单独数值==组成，每个数有相应概率</li>
<li>为数值型数据，只取确切值</li>
<li>往往以某种方式技术</li>
</ul>
<p><strong>连续数据</strong>：</p>
<ul>
<li>包含一个数据范围，数值可无穷无尽</li>
<li>通过测量得到，结果取决于测量精度</li>
</ul>
<a id="more"></a>
<h2 id="概率密度函数"><a href="#概率密度函数" class="headerlink" title="概率密度函数"></a>概率密度函数</h2><blockquote>
<p>连续数据概率分布：</p>
<ul>
<li>特定精度水平</li>
<li>数值范围的概率</li>
</ul>
</blockquote>
<h3 id="概率密度函数-1"><a href="#概率密度函数-1" class="headerlink" title="概率密度函数"></a>概率密度函数</h3><ul>
<li><p><strong>描述连续随机变量的概率分布</strong></p>
</li>
<li><p>求出一个数据范围内某各连续变量的概率</p>
</li>
</ul>
<p><img src="/2020/01/20/8.%20%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83%E7%9A%84%E8%BF%90%E7%94%A8/image-20200108093904546-1578448220082.png" alt="image-20200108093904546"></p>
<h3 id="概率计算"><a href="#概率计算" class="headerlink" title="概率计算"></a>概率计算</h3><p><strong>连续随机变量的概率用面积来表示</strong></p>
<p><img src="/2020/01/20/8.%20%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83%E7%9A%84%E8%BF%90%E7%94%A8/image-20200108094221742-1578448220083.png" alt="image-20200108094221742"></p>
<blockquote>
<p>对于任何概率分布，总概率必须等于1，即面积必须等于1。</p>
<p>==处理连续数据，计算的是一个数值范围的概率。==</p>
</blockquote>
<h2 id="正态分布"><a href="#正态分布" class="headerlink" title="正态分布"></a>正态分布</h2><p>连续数据的理想模型</p>
<ul>
<li><p>钟形曲线，曲线对称，中央部位的概率密度最大。 </p>
</li>
<li><p>越是偏离均值 ， 概率密度减小。 </p>
</li>
<li><p>均值和中位数均位于中央 ， 具有最大概率密度。</p>
</li>
</ul>
<p>==通过参数$\mu$和$\sigma ^2$进行定义。 $\mu$指出曲线的中央位置， $\sigma$指出分散性。==</p>
<p><img src="/2020/01/20/8.%20%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83%E7%9A%84%E8%BF%90%E7%94%A8/image-20200108095726653.png" alt="image-20200108095726653"></p>
<blockquote>
<ul>
<li>$\sigma^2$越大，正态分布越扁平</li>
<li>概率密度无限接近于但不等于0</li>
</ul>
</blockquote>
<h3 id="正态概率计算"><a href="#正态概率计算" class="headerlink" title="正态概率计算"></a>正态概率计算</h3><ul>
<li>求介于a和b之间的概率（借助概率表）</li>
</ul>
<p><img src="/2020/01/20/8.%20%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83%E7%9A%84%E8%BF%90%E7%94%A8/image-20200108100104983.png" alt="image-20200108100104983"></p>
<ol>
<li><p>确定概率分布与范围</p>
<ul>
<li>计算均值,标准差</li>
<li>需要求出那一部分概率</li>
</ul>
</li>
<li><p>标准化$N(0,1)$</p>
<ul>
<li>移动均值</li>
</ul>
<p><img src="/2020/01/20/8.%20%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83%E7%9A%84%E8%BF%90%E7%94%A8/image-20200108101731843.png" alt="image-20200108101731843"></p>
<ul>
<li>收窄</li>
</ul>
<p><img src="/2020/01/20/8.%20%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83%E7%9A%84%E8%BF%90%E7%94%A8/image-20200108101806797.png" alt="image-20200108101806797"></p>
<blockquote>
<p><strong>概率表仅给出N(0,1)分布的概率</strong>，需要进行标准化</p>
</blockquote>
</li>
</ol>
<p>$$Z=\frac{X-\mu}{\sigma}$$ <strong>（即CH3中的标准分）</strong></p>
<p>X：求的概率变量</p>
<p>$\mu$ :X的均值</p>
<p>$\sigma$:X的标准差</p>
<ol start="3">
<li>查找概率</li>
</ol>
<p><img src="/2020/01/20/8.%20%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83%E7%9A%84%E8%BF%90%E7%94%A8/image-20200108102633264.png" alt="image-20200108102633264"></p>
<blockquote>
<p><strong>注</strong>：概率分布表查找的为$P(Z&lt;z)$的概率<br><img src="/2020/01/20/8.%20%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83%E7%9A%84%E8%BF%90%E7%94%A8/image-20200108102806152.png" alt="image-20200108102806152"></p>
</blockquote>
<p><strong>若已知（两组）概率，求均值，方差。可以列出方程组求解。</strong></p>
]]></content>
      <categories>
        <category>data analytics</category>
      </categories>
      <tags>
        <tag>《深入浅出统计学》</tag>
      </tags>
  </entry>
  <entry>
    <title>7. 几何分布，二项分布及泊松分布</title>
    <url>/2020/01/20/7.%20%E5%87%A0%E4%BD%95%E5%88%86%E5%B8%83%EF%BC%8C%E4%BA%8C%E9%A1%B9%E5%88%86%E5%B8%83%E5%8F%8A%E6%B3%8A%E6%9D%BE%E5%88%86%E5%B8%83/</url>
    <content><![CDATA[<p>特殊的概率分布，固定的模式，方便计算概率，期望，方差</p>
<h2 id="几何分布"><a href="#几何分布" class="headerlink" title="几何分布"></a>几何分布</h2><blockquote>
<ul>
<li><p>$P(X=x)$表示x能取概率分布的任何值</p>
</li>
<li><p>$P(X=r)$表示x等于特定值r</p>
</li>
<li><p>即x可以取任何值，包括固定值r</p>
</li>
</ul>
</blockquote>
<h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><p>$P(X=r)=q^{r-1}p$</p>
<ul>
<li>p代表成功的概率</li>
<li>q代表失败的概率，q=1-p</li>
</ul>
<p><strong>表示</strong>取得第r次首次成功所需要进行的试验次数的概率</p>
<h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><ul>
<li>一系列相互独立试验</li>
<li>均有成功，失败的可能，且单次概率相同</li>
<li>求得<strong>为取得第一次成功所需要进行多少次试验</strong>（用变量X表示）<a id="more"></a>

</li>
</ul>
<h3 id="图像特点"><a href="#图像特点" class="headerlink" title="图像特点"></a>图像特点</h3><p><img src="/2020/01/20/7.%20%E5%87%A0%E4%BD%95%E5%88%86%E5%B8%83%EF%BC%8C%E4%BA%8C%E9%A1%B9%E5%88%86%E5%B8%83%E5%8F%8A%E6%B3%8A%E6%9D%BE%E5%88%86%E5%B8%83/image-20191219143908430.png" alt="image-20191219143908430"></p>
<ul>
<li>当r=1时，P（X=r）达到最大值，随着r的增加，P（X=r）逐渐减少</li>
<li>任何几何分布的众数都是1，因为1时，具有的概率最大</li>
<li>第一次尝试，可能性最大</li>
</ul>
<h3 id="不等式几何分布"><a href="#不等式几何分布" class="headerlink" title="不等式几何分布"></a>不等式几何分布</h3><p>$$P(X&gt;r)=q^r$$</p>
<ul>
<li>X表示为取得第一次成功所需要进行多少次试验</li>
<li>r表示试验进行的次数</li>
</ul>
<p>$$P(X≤r)=1-q^r$$</p>
<ul>
<li>表示为了取得一次成功需要尝试r次或r次的以下概率</li>
<li>$P(X≤r)+P(X&gt;r)=1$</li>
</ul>
<p>如果一个变量X的概率符合几何分布，单次成功的概率为p，写作</p>
<p>$X$~$Geo(p)$</p>
<h3 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h3><p>X~$Geo(0.2)$时，E(X)可以通过$\sum xP(X=x)$进行计算：</p>
<p><img src="/2020/01/20/7.%20%E5%87%A0%E4%BD%95%E5%88%86%E5%B8%83%EF%BC%8C%E4%BA%8C%E9%A1%B9%E5%88%86%E5%B8%83%E5%8F%8A%E6%B3%8A%E6%9D%BE%E5%88%86%E5%B8%83/image-20191219151744306.png" alt="image-20191219151744306"></p>
<p>$\sum xP(X=x)$图</p>
<p><img src="/2020/01/20/7.%20%E5%87%A0%E4%BD%95%E5%88%86%E5%B8%83%EF%BC%8C%E4%BA%8C%E9%A1%B9%E5%88%86%E5%B8%83%E5%8F%8A%E6%B3%8A%E6%9D%BE%E5%88%86%E5%B8%83/image-20191219152414904.png" alt="image-20191219152414904"></p>
<p>$E(X)=\frac{1}{p}$</p>
<p>期望等于1除以成功概率</p>
<h3 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h3><p>X~$Geo(0.2)$时，E(X)可以通过$x^2 P(X=x)$进行计算：</p>
<p><img src="/2020/01/20/7.%20%E5%87%A0%E4%BD%95%E5%88%86%E5%B8%83%EF%BC%8C%E4%BA%8C%E9%A1%B9%E5%88%86%E5%B8%83%E5%8F%8A%E6%B3%8A%E6%9D%BE%E5%88%86%E5%B8%83/image-20191219152807044.png" alt="image-20191219152807044"></p>
<p>$x^2 P(X=x)$图</p>
<p><img src="/2020/01/20/7.%20%E5%87%A0%E4%BD%95%E5%88%86%E5%B8%83%EF%BC%8C%E4%BA%8C%E9%A1%B9%E5%88%86%E5%B8%83%E5%8F%8A%E6%B3%8A%E6%9D%BE%E5%88%86%E5%B8%83/image-20191219152822776.png" alt="image-20191219152822776"></p>
<p>$Var(X)=E(X^2)-E^2(X)=x^2 P(X=x)-E^2(X)$,得到方差分布图</p>
<p><img src="/2020/01/20/7.%20%E5%87%A0%E4%BD%95%E5%88%86%E5%B8%83%EF%BC%8C%E4%BA%8C%E9%A1%B9%E5%88%86%E5%B8%83%E5%8F%8A%E6%B3%8A%E6%9D%BE%E5%88%86%E5%B8%83/image-20191219153245765.png" alt="image-20191219153245765"></p>
<p>如果X~$Gep(p)$，则$Var(X)=\frac{q}{p^2}$</p>
<h2 id="二项式分布"><a href="#二项式分布" class="headerlink" title="二项式分布"></a>二项式分布</h2><h3 id="公式-1"><a href="#公式-1" class="headerlink" title="公式"></a>公式</h3><p>$P(X=r)=^nC_r<em>p^r</em>q^{n-r}$</p>
<p>其中$^nC_r=\frac{n!}{r!(n-r)!}$</p>
<blockquote>
<p>每道题答对的概率是p</p>
<p>答错的概率是q=1-p</p>
</blockquote>
<h3 id="条件-1"><a href="#条件-1" class="headerlink" title="条件"></a>条件</h3><ul>
<li>独立试验</li>
<li>均有成功，失败的可能，且单次概率相同</li>
<li><strong>试验次数有限</strong></li>
</ul>
<p>p是没一次试验的成功概率，n是试验次数。写作：X~$B(n,p)$</p>
<h3 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h3><p><img src="/2020/01/20/7.%20%E5%87%A0%E4%BD%95%E5%88%86%E5%B8%83%EF%BC%8C%E4%BA%8C%E9%A1%B9%E5%88%86%E5%B8%83%E5%8F%8A%E6%B3%8A%E6%9D%BE%E5%88%86%E5%B8%83/image-20191219155524567.png" alt="image-20191219155524567"></p>
<h3 id="期望-1"><a href="#期望-1" class="headerlink" title="期望"></a>期望</h3><p>$E(X)=np$</p>
<h3 id="方差-1"><a href="#方差-1" class="headerlink" title="方差"></a>方差</h3><p>$Var(X)=npq$</p>
<h2 id="泊松分布"><a href="#泊松分布" class="headerlink" title="泊松分布"></a>泊松分布</h2><h3 id="条件-2"><a href="#条件-2" class="headerlink" title="条件"></a>条件</h3><ul>
<li>单独时间在给定区间（时间或者空间）内随机、独立地发生</li>
<li>已知改区间的时间平均发生次数（发生率）通常用$\lambda$(lambda)表示</li>
</ul>
<p>每个区间内平均发生$\lambda$次，或者说发生率为$\lambda$，写作X~$Po(\lambda)$</p>
<h3 id="公式-2"><a href="#公式-2" class="headerlink" title="公式"></a>公式</h3><p>$P(X=r)=\frac{e^{-\lambda}\lambda ^r}{r!}$</p>
<ul>
<li>$e$是数学的常数，一般为2.718</li>
</ul>
<h3 id="期望-2"><a href="#期望-2" class="headerlink" title="期望"></a>期望</h3><p>$E(X)=\lambda$</p>
<h3 id="方差-2"><a href="#方差-2" class="headerlink" title="方差"></a>方差</h3><p>$Var(X)=\lambda$</p>
<h3 id="图形"><a href="#图形" class="headerlink" title="图形"></a>图形</h3><p><img src="/2020/01/20/7.%20%E5%87%A0%E4%BD%95%E5%88%86%E5%B8%83%EF%BC%8C%E4%BA%8C%E9%A1%B9%E5%88%86%E5%B8%83%E5%8F%8A%E6%B3%8A%E6%9D%BE%E5%88%86%E5%B8%83/image-20191219161311269.png" alt="image-20191219161311269"></p>
<ul>
<li>$\lambda $值小，分布向右</li>
<li>$\lambda $值大，分布逐渐变得对称</li>
<li>$\lambda $值为整数，众数为$\lambda $和$\lambda -1$</li>
</ul>
<h3 id="x-y泊松分布"><a href="#x-y泊松分布" class="headerlink" title="x+y泊松分布"></a>x+y泊松分布</h3><p>如果X和Y是独立随机变量，则：</p>
<p>$P(X+Y)=P(X)+P(Y)$</p>
<p>$E(X+Y)=E(X)+E(Y)$</p>
<p>即如果X~ $Po(\lambda_x)$且Y~ $Po(\lambda_y)$，则：</p>
<p>X+Y~ $Po(\lambda_x+\lambda_y)$</p>
<p>如果X和Y都复合泊松分布，则X+Y也符合泊松分布</p>
<h3 id="使用二项式分布替代"><a href="#使用二项式分布替代" class="headerlink" title="使用二项式分布替代"></a>使用二项式分布替代</h3><blockquote>
<p>当n很大且p很小时，可以用X<del>$Po(np)$ 近似代替X</del>$B(n,p)$.</p>
</blockquote>
<p><img src="/2020/01/20/7.%20%E5%87%A0%E4%BD%95%E5%88%86%E5%B8%83%EF%BC%8C%E4%BA%8C%E9%A1%B9%E5%88%86%E5%B8%83%E5%8F%8A%E6%B3%8A%E6%9D%BE%E5%88%86%E5%B8%83/image-20191219163735633.png" alt="image-20191219163735633"></p>
]]></content>
      <categories>
        <category>data analytics</category>
      </categories>
      <tags>
        <tag>《深入浅出统计学》</tag>
      </tags>
  </entry>
</search>
