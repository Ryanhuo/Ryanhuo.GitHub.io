<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="Shortcut Icon" href="asset/css/huo.ico" type="image/x-icon">
    <title>
    
  常用库 - Ryanhuo
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="Ryanhuo" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
 
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:ryanhuo.github.io ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }

</script>

  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">主页</a></li>
        
        <li id=""><a target="_self" href="archives.html">目录</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
 <!--<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>-->
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; Ryanhuo</span>
  </a>
</nav>


<section id="header">
  <div class="inner">
    <span class="icon major fa-cloud"></span>
    <img src="asset/img/火.png" alt="logo">
    <h1>Hi, I'm <strong>Ryan</strong><br /></h1>
    <p><a href="ryanhuo.github.io">我的主页</a></p>
    <p>我是黑暗里中大雪纷飞的人哪，<br />
    你再不来，我要下雪来</p>
    <ul class="actions">
      <li><a href="rfile:///Users/ryan/Library/Containers/com.coderforart.MWeb3/Data/Documents/themes/Site/Ryanhuo.GitHub.io/jian-lixing-ming-lei-yanqiu-zh.html" class="button scrolly">About Me</a></li>
    </ul>
  </div>
</section>


<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="_self" href="index.html">主页</a></li>
        
        <li><a target="_self" href="archives.html">目录</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90.html">数据分析</a></li>
        
            <li><a href="ML&DL.html">ML&DL</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15822327223909.html">
                
                  <h1>2. numpy</h1>
                 <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">NumPy介绍</h2>

<p>Numpy（Numerical Python）是一个开源的Python科学计算库，用于快速处理任意维度的数组。<br/>
Numpy支持常见的数组和矩阵操作。对于同样的数值计算任务，使用Numpy比直接使用Python要简洁的多。<br/>
Numpy使用ndarray对象来处理多维数组，该对象是一个快速而灵活的大数据容器。</p>

<h2 id="toc_1">NumPy优点</h2>

<ol>
<li> 快速</li>
<li> 方便</li>
<li><p>科学计算的基础库</p></li>
</ol>

<ul>
<li><p>对于同样的数值计算任务，使用NumPy要比直接编写Python代码便捷得多；</p></li>
<li><p>NumPy中的数组的存储效率和输入输出性能均远远优于Python中等价的基本数据结构，且其能够提升的性能是   与数组中的元素成比例的；</p></li>
<li><p>NumPy的大部分代码都是用C语言写的，其底层算法在设计时就有着优异的性能，这使得NumPy比纯Python代  码高效得多</p></li>
</ul>

<h2 id="toc_2">安装</h2>

<pre><code class="language-text">pip install numpy
</code></pre>

<h2 id="toc_3">与原生list运算效率对比</h2>

<pre><code class="language-python">import random 
import time 
import numpy as np
a = []
for i in range(100000000): 
    a.append(random.random())
t1 = time.time() 
sum1=sum(a) 
t2=time.time()

b=np.array(a) 
t4=time.time() 
sum3=np.sum(b) 
t5=time.time() 

print(t2-t1, t5-t4)
</code></pre>

<pre><code class="language-text">45.5947265625 2.542968988418579
</code></pre>

<h2 id="toc_4">NumPy 的Ndarray 对象</h2>

<p>NumPy 最重要的一个特点是其 N 维数组对象 ndarray，它是一系列同类型数据的集合，以 0 下标为开始进行集合中元素的索引。ndarray 对象是用于存放同类型元素的多维数组。</p>

<h3 id="toc_5">创建一维数组</h3>

<p>多种样式创建一维数组</p>

<h4 id="toc_6">直接传入列表</h4>

<pre><code class="language-python">import numpy as np
list=[1,2,3,4]
Array_1=np.array(list)
print(Array_1,type(Array_1))
</code></pre>

<pre><code class="language-text">[1 2 3 4] &lt;class &#39;numpy.ndarray&#39;&gt;
</code></pre>

<h4 id="toc_7">传入range生成序列</h4>

<pre><code class="language-python">Array_2=np.array(range(1,10))
print(Array_2,type(Array_2))
</code></pre>

<pre><code class="language-text">[1 2 3 4 5 6 7 8 9] &lt;class &#39;numpy.ndarray&#39;&gt;
</code></pre>

<h4 id="toc_8">利用numpy自带的np.arange（）</h4>

<pre><code class="language-python">Array_3=np.arange(1,10)
print(Array_3,type(Array_3))
</code></pre>

<pre><code class="language-text">[1 2 3 4 5 6 7 8 9] &lt;class &#39;numpy.ndarray&#39;&gt;
</code></pre>

<h2 id="toc_9">创建二维数组</h2>

<pre><code class="language-python">list2=[[1,2,3],[4,5,6],[7,8,9]]

t1=np.array(list2)
print(t1,type(t1))
</code></pre>

<pre><code class="language-text">[[1 2 3]
 [4 5 6]
 [7 8 9]] &lt;class &#39;numpy.ndarray&#39;&gt;
</code></pre>

<h3 id="toc_10">常用属性</h3>

<pre><code class="language-python"># 获取数组的维度（与函数的参数相似）
print(t1.ndim)
</code></pre>

<pre><code class="language-text">2
</code></pre>

<pre><code class="language-python">#形状(行，列)
print(t1.shape)
</code></pre>

<pre><code class="language-text">(3, 3)
</code></pre>

<pre><code class="language-python">#元素个数
print(t1.size)
</code></pre>

<pre><code class="language-text">9
</code></pre>

<h3 id="toc_11">调整数组的形状</h3>

<pre><code class="language-python">t2= np.array([[1,2,3],[4,5,6]])
# 修改的是原有的four.shape = (3,2)
print(t2)

# 返回一个新的数组
t2 = t2.reshape(3,2) 
print(t2)

# 将多维变成一维数组
t3= t2.reshape((6,),order=&#39;F&#39;)
# 默认情况下‘C’以行为主的顺序展开，‘F’（Fortran风格）意味着以列的顺序展开

t4 = t2.flatten(order=&#39;F&#39;) 
print(t3)
print(t4)

</code></pre>

<pre><code class="language-text">[[1 2 3]
 [4 5 6]]
[[1 2]
 [3 4]
 [5 6]]
[1 3 5 2 4 6]
[1 3 5 2 4 6]
</code></pre>

<pre><code class="language-python"># 拓展：数组的形状
t = np.arange(24)
print(t) 
print(t.shape)


# 转换成二维
t1 = t.reshape((4,6))
print(t1) 
print(t1.shape)


# 转成三维
t2 = t.reshape((2,3,4)) 
print(t2) 
print(t2.shape)

</code></pre>

<pre><code class="language-text">[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23]
(24,)
[[ 0  1  2  3  4  5]
 [ 6  7  8  9 10 11]
 [12 13 14 15 16 17]
 [18 19 20 21 22 23]]
(4, 6)
[[[ 0  1  2  3]
  [ 4  5  6  7]
  [ 8  9 10 11]]

 [[12 13 14 15]
  [16 17 18 19]
  [20 21 22 23]]]
(2, 3, 4)
</code></pre>

<h3 id="toc_12">将数组转成list</h3>

<pre><code class="language-python">a= np.array([9, 12, 88, 14, 25])
list_a = a.tolist() 
print(list_a) 
print(type(list_a))

</code></pre>

<pre><code class="language-text">[9, 12, 88, 14, 25]
&lt;class &#39;list&#39;&gt;
</code></pre>

<h2 id="toc_13">NumPy的数据类型</h2>

<pre><code class="language-python">f = np.array([1,2,3,4,5], dtype = np.int16)

# 返回数组中每个元素的字节单位长度
print(f.itemsize) # 1 np.int8(一个字节)

</code></pre>

<pre><code class="language-text">2
</code></pre>

<pre><code class="language-python"># 获取数据类型
print(f.dtype)

</code></pre>

<pre><code class="language-text">int16
</code></pre>

<pre><code class="language-python"># 调整数据类型
f1 = f.astype(np.int64) 
print(f1.dtype)

</code></pre>

<pre><code class="language-text">int64
</code></pre>

<pre><code class="language-python"># 拓展随机生成小数
# 使用python语法，保留两位
print(round(random.random(),2))

arr = np.array([random.random() for i in range(10)])
# 取小数点后两位
print(np.round(arr,2))


</code></pre>

<pre><code class="language-text">0.02
[0.29 0.82 0.01 0.23 0.89 0.46 0.44 0.4  0.58 0.17]
</code></pre>

<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>bool</td>
<td>用一个字节存储的布尔类型（True或False）</td>
</tr>
<tr>
<td>inti</td>
<td>由所在平台决定其大小的整数（一般为int32或int64）</td>
</tr>
<tr>
<td>int8</td>
<td>一个字节大小，-128 至 127</td>
</tr>
<tr>
<td>int16</td>
<td>整数，-32768 至 32767</td>
</tr>
<tr>
<td>int32</td>
<td>整数，-2 ** 31 至 2 ** 32 -1</td>
</tr>
<tr>
<td>int64</td>
<td>整数，-2 ** 63 至 2 ** 63 - 1</td>
</tr>
<tr>
<td>uint8</td>
<td>无符号整数，0 至 255</td>
</tr>
<tr>
<td>uint16</td>
<td>无符号整数，0 至 65535</td>
</tr>
<tr>
<td>uint32</td>
<td>无符号整数，0 至 2 ** 32 - 1</td>
</tr>
<tr>
<td>uint64</td>
<td>无符号整数，0 至 2 ** 64 - 1</td>
</tr>
<tr>
<td>float16</td>
<td>半精度浮点数：16位，正负号1位，指数5位，精度10位</td>
</tr>
<tr>
<td>float32</td>
<td>单精度浮点数：32位，正负号1位，指数8位，精度23位</td>
</tr>
<tr>
<td>float64或float</td>
<td>双精度浮点数：64位，正负号1位，指数11位，精度52位</td>
</tr>
<tr>
<td>complex64</td>
<td>复数，分别用两个32位浮点数表示实部和虚部</td>
</tr>
<tr>
<td>complex128或complex</td>
<td>复数，分别用两个64位浮点数表示实部和虚部</td>
</tr>
</tbody>
</table>

<h2 id="toc_14">数组的计算</h2>

<h3 id="toc_15">数组和数的计算</h3>

<p>由于numpy的广播机机制在运算过程中，加减乘除的值被广播到所有的元素上面。</p>

<pre><code class="language-python">t1 = np.arange(24).reshape((6,4)) 
print(t1+2)
print(t1*2) 
print(t1/2)

</code></pre>

<pre><code class="language-text">[[ 2  3  4  5]
 [ 6  7  8  9]
 [10 11 12 13]
 [14 15 16 17]
 [18 19 20 21]
 [22 23 24 25]]
[[ 0  2  4  6]
 [ 8 10 12 14]
 [16 18 20 22]
 [24 26 28 30]
 [32 34 36 38]
 [40 42 44 46]]
[[ 0.   0.5  1.   1.5]
 [ 2.   2.5  3.   3.5]
 [ 4.   4.5  5.   5.5]
 [ 6.   6.5  7.   7.5]
 [ 8.   8.5  9.   9.5]
 [10.  10.5 11.  11.5]]
</code></pre>

<h3 id="toc_16">数组与数组之间的操作</h3>

<p>同种形状的数组(对应位置进行计算操作)</p>

<pre><code class="language-python">t1 = np.arange(24).reshape((6,4))
t2 = np.arange(100,124).reshape((6,4))

print(t1+t2) 
print(t1*t2)

</code></pre>

<pre><code class="language-text">[[100 102 104 106]
 [108 110 112 114]
 [116 118 120 122]
 [124 126 128 130]
 [132 134 136 138]
 [140 142 144 146]]
[[   0  101  204  309]
 [ 416  525  636  749]
 [ 864  981 1100 1221]
 [1344 1469 1596 1725]
 [1856 1989 2124 2261]
 [2400 2541 2684 2829]]
</code></pre>

<p>不种形状的多维数组不能计算</p>

<pre><code class="language-python">t1 = np.arange(24).reshape((4,6)) 
t2 = np.arange(18).reshape((3,6)) 
print(t1)
print(t2) 
print(t1-t2)

</code></pre>

<pre><code class="language-text">[[ 0  1  2  3  4  5]
 [ 6  7  8  9 10 11]
 [12 13 14 15 16 17]
 [18 19 20 21 22 23]]
[[ 0  1  2  3  4  5]
 [ 6  7  8  9 10 11]
 [12 13 14 15 16 17]]




---------------------------------------------------------------------------

ValueError                                Traceback (most recent call last)

&lt;ipython-input-32-8e6819c2b1e3&gt; in &lt;module&gt;()
      3 print(t1)
      4 print(t2)
----&gt; 5 print(t1-t2)



ValueError: operands could not be broadcast together with shapes (4,6) (3,6) 
</code></pre>

<p>行数或者列数相同的一维数组和多维数组可以进行计算： </p>

<p>行形状相同（会与每一行数组的对应位相操作)</p>

<pre><code class="language-python">t1 = np.arange(24).reshape((4,6)) 
t2 = np.arange(0,6)

print(t1-t2)


</code></pre>

<pre><code class="language-text">[[ 0  0  0  0  0  0]
 [ 6  6  6  6  6  6]
 [12 12 12 12 12 12]
 [18 18 18 18 18 18]]
</code></pre>

<p>列形状相同（会与每一个相同维度的数组的对应位相操作)</p>

<pre><code class="language-python">t1 = np.arange(24).reshape((4,6)) 
t2 = np.arange(4).reshape((4,1))

print(t1-t2)


</code></pre>

<pre><code class="language-text">[[ 0  1  2  3  4  5]
 [ 5  6  7  8  9 10]
 [10 11 12 13 14 15]
 [15 16 17 18 19 20]]
</code></pre>

<h2 id="toc_17">数组中的轴</h2>

<ol>
<li><p>什么是轴： 在numpy中可以理解为方向，使用0，1，2数字表示，对于一个一维数组，只有一个0轴， 对于2维数组（shape（2，2))有0轴和1轴， 对于3维数组（shape（2，2，3））有0，1，2轴</p></li>
<li><p>为什么要学习轴：有了轴的概念后，我们计算会更加方便，比如计算一个2维数组的平均值，必须指定是计算哪个方向上面的数字的平均值。</p></li>
</ol>

<p><img src="media/15822327223909/20191127155610-1577075803629.png" alt="20191127155610"/></p>

<p><img src="media/15822327223909/20191127155642-1577075815036.png" alt="20191127155642"/></p>

<pre><code class="language-python">import numpy as np
a = np.array([[1,2,3],[4,5,6]])

print(np.sum(a,axis=0)) # [5 7 9]

print(np.sum(a,axis = 1)) # [ 6 15]

print(np.sum(a))# 计算所有的值的和


</code></pre>

<pre><code class="language-text">[5 7 9]
[ 6 15]
21
</code></pre>

<pre><code class="language-python">#三维的数据
a = np.arange(27).reshape((3,3,3))
print(a)

</code></pre>

<pre><code class="language-text">[[[ 0  1  2]
  [ 3  4  5]
  [ 6  7  8]]

 [[ 9 10 11]
  [12 13 14]
  [15 16 17]]

 [[18 19 20]
  [21 22 23]
  [24 25 26]]]
</code></pre>

<pre><code class="language-python">b = np.sum(a, axis=0)
print(b)


</code></pre>

<pre><code class="language-text">[[27 30 33]
 [36 39 42]
 [45 48 51]]
</code></pre>

<pre><code class="language-python">c = np.sum(a, axis=1)
print(c)

</code></pre>

<pre><code class="language-text">[[ 9 12 15]
 [36 39 42]
 [63 66 69]]
</code></pre>

<pre><code class="language-python">c = np.sum(a, axis=2)
print(c)

</code></pre>

<pre><code class="language-text">[[ 3 12 21]
 [30 39 48]
 [57 66 75]]
</code></pre>

<p><strong>总结：</strong>在计算的时候可以想象成是每一个坐标轴，分别计算这个轴上面的每一个刻度上的值，或者在二维数组中记住0表示列1表示行.</p>

<h2 id="toc_18">数组的索引和切片</h2>

<p>一维数组的操作方法</p>

<pre><code class="language-python">import numpy as np

a = np.arange(10)
# 冒号分隔切片参数 start:stop:step 来进行切片操作

print(a[2:7:2])# 从索引 2 开始到索引 7 停止，间隔为 2

# 如果只放置一个参数，如 [2]，将返回与该索引相对应的单个元素
print(a[2],a)

# 如果为 [2:]，表示从该索引开始以后的所有项都将被提取
print(a[2:])


</code></pre>

<pre><code class="language-text">[2 4 6]
2 [0 1 2 3 4 5 6 7 8 9]
[2 3 4 5 6 7 8 9]
</code></pre>

<p>多维数组的操作方法</p>

<pre><code class="language-python">import numpy as np
t1 = np.arange(24).reshape(4,6) 
print(t1)
print(&#39;*&#39;*20)
print(t1[1]) # 取一行(一行代表是一条数据，索引也是从0开始的) 
print(t1[1,:]) # 取一行

print(t1[1:])# 取连续的多行
print(t1[1:3,:])# 取连续的多行

print(t1[[0,2,3]])# 取不连续的多行
print(t1[[0,2,3],:])# 取不连续的多行

print(t1[:,1])# 取一列
print(t1[:,1:])# 连续的多列
print(t1[:,[0,2,3]])# 取不连续的多列
print(t1[2,3])# # 取某一个值,三行四列
print(t1[[0,1,1],[0,1,3]])# 取多个不连续的值，[[行，行。。。],[列，列。。。]]

</code></pre>

<pre><code class="language-text">[[ 0  1  2  3  4  5]
 [ 6  7  8  9 10 11]
 [12 13 14 15 16 17]
 [18 19 20 21 22 23]]
********************
[ 6  7  8  9 10 11]
[ 6  7  8  9 10 11]
[[ 6  7  8  9 10 11]
 [12 13 14 15 16 17]
 [18 19 20 21 22 23]]
[[ 6  7  8  9 10 11]
 [12 13 14 15 16 17]]
[[ 0  1  2  3  4  5]
 [12 13 14 15 16 17]
 [18 19 20 21 22 23]]
[[ 0  1  2  3  4  5]
 [12 13 14 15 16 17]
 [18 19 20 21 22 23]]
[ 1  7 13 19]
[[ 1  2  3  4  5]
 [ 7  8  9 10 11]
 [13 14 15 16 17]
 [19 20 21 22 23]]
[[ 0  2  3]
 [ 6  8  9]
 [12 14 15]
 [18 20 21]]
15
[0 7 9]
</code></pre>

<h2 id="toc_19">组中的数值修改</h2>

<pre><code class="language-python">t = np.arange(24).reshape(4,6)

# 修改某一行的值
t[1,:]=0

# 修改某一列的值
t[:,1]=0

# 修改连续多行
t[1:3,:]=0

# 修改连续多列
t[:,1:4]=0

# 修改多行多列，取第二行到第四行，第三列到第五列
t[1:4,2:5]=0

# 修改多个不相邻的点
t[[0,1],[0,3]]=0

# 可以根据条件修改，比如讲小于10的值改掉
t[t&lt;10]=0

# 使用逻辑判断
# np.logical_and    &amp; 
# np.logical_or |
# np.logical_not        ~ 

t[(t&gt;2)&amp;(t&lt;6)]=0    # 与
t[(t&lt;2)|(t&gt;6)]=0    # 或
t[~(t&gt;6)]=0 # 非
print(t)

# 拓 展
# 三目运算（ np.where(condition, x, y)满足条件(condition)，输出x，不满足输出y。)）
# score = np.array([[80,88],[82,81],[75,81]])
# result = np.where(score&gt;80,True,False) 
# print(result)

</code></pre>

<pre><code class="language-text">[[0 0 0 0 0 0]
 [0 0 0 0 0 0]
 [0 0 0 0 0 0]
 [0 0 0 0 0 0]]
</code></pre>

<h2 id="toc_20">数组的添加、删除和去重</h2>

<h3 id="toc_21">数组的添加</h3>

<ol>
<li>numpy.append 函数在数组的末尾添加值。 追加操作会分配整个数组，并把原来的数组复制到新数组中。 此外，输入数组的维度必须匹配否则将生成ValueError。</li>
</ol>

<p><strong>参数说明：</strong></p>

<ul>
<li>arr：输入数组</li>
<li>values：要向arr添加的值，需要和arr形状相同（除了要添加的轴）</li>
<li>axis：默认为 None。当axis无定义时，是横向加成，返回总是为一维数组！当axis有定义的时候，分别为0和1的时候。当</li>
<li>axis有定义的时候，分别为0和1的时候（列数要相同）。当axis为1时，数组是加在右边（行数要相同）。</li>
</ul>

<pre><code class="language-python">a = np.array([[1,2,3],[4,5,6]])

print (&#39;第一个数组：&#39;)
print (a)
print (&#39;\n&#39;)

print (&#39; 向 数 组 添 加 元 素 ：&#39;) 
print (np.append(a, [7,8,9])) 
print (&#39;\n&#39;)

print (&#39;沿轴 0 添加元素：&#39;)
print (np.append(a, [[7,8,9]],axis = 0)) 
print (&#39;\n&#39;)

print (&#39;沿轴 1 添加元素：&#39;)
print (np.append(a, [[5,5,5],[7,8,9]],axis = 1))


</code></pre>

<pre><code class="language-text">第一个数组：
[[1 2 3]
 [4 5 6]]
</code></pre>

<p>​<br/><br/>
​     向 数 组 添 加 元 素 ：<br/>
​    [1 2 3 4 5 6 7 8 9]</p>

<p>​<br/><br/>
​    沿轴 0 添加元素：<br/>
​    [[1 2 3]<br/>
​     [4 5 6]<br/>
​     [7 8 9]]</p>

<p>​<br/><br/>
​    沿轴 1 添加元素：<br/>
​    [[1 2 3 5 5 5]<br/>
​     [4 5 6 7 8 9]]</p>

<ol>
<li><p>numpy.insert 函数在给定索引之前，沿给定轴在输入数组中插入值。</p>
<p>如果值的类型转换为要插入，则它与输入数组不同。 插入没有原地的，函数会返回一个新数组。 此外，如果未提供轴，则输入数组会被展开。</p></li>
</ol>

<pre><code class="language-python">a = np.array([[1,2],[3,4],[5,6]])

print (&#39;第一个数组：&#39;) 
print (a)
print (&#39;\n&#39;)

print (&#39;未传递 Axis 参数。 在插入之前输入数组会被展开。&#39;) 
print (np.insert(a,3,[11,12]))
print (&#39;\n&#39;)
print (&#39;传递了 Axis 参数。 会广播值数组来配输入数组。&#39;)

print (&#39;沿轴  0 广播：&#39;)
print (np.insert(a,1,[11],axis = 0)) 
print (&#39;\n&#39;)

print (&#39;沿轴  1 广播：&#39;)
print (np.insert(a,1,11,axis = 1))


</code></pre>

<pre><code class="language-text">第一个数组：
[[1 2]
 [3 4]
 [5 6]]
</code></pre>

<p>​<br/><br/>
​    未传递 Axis 参数。 在插入之前输入数组会被展开。<br/>
​    [ 1  2  3 11 12  4  5  6]</p>

<p>​<br/><br/>
​    传递了 Axis 参数。 会广播值数组来配输入数组。<br/>
​    沿轴  0 广播：<br/>
​    [[ 1  2]<br/>
​     [11 11]<br/>
​     [ 3  4]<br/>
​     [ 5  6]]</p>

<p>​<br/><br/>
​    沿轴  1 广播：<br/>
​    [[ 1 11  2]<br/>
​     [ 3 11  4]<br/>
​     [ 5 11  6]]</p>

<h3 id="toc_22">数组中的删除</h3>

<p>numpy.delete 函数返回从输入数组中删除指定子数组的新数组。 与 insert() 函数的情况一样，如果未提供轴参数， 则输入数组将展开。</p>

<p><strong>参数说明：</strong></p>

<ul>
<li><p>arr： 输入数组  </p></li>
<li><p>obj：可以被切片，整数或者整数数组，表明要从输入数组删除的子数组</p></li>
<li><p>axis：沿着它删除给定子数组的轴，如果未提供，则输入数组会被展开</p></li>
</ul>

<pre><code class="language-python">a = np.arange(12).reshape(3,4)
print (&#39;第一个数组：&#39;)
print (a)
print (&#39;\n&#39;)

print (&#39;未传递 Axis 参数。 在删除之前输入数组会被展开。&#39;) 
print (np.delete(a,5))
print (&#39;\n&#39;)

print (&#39;删除每一行中的第二列：&#39;)
print (np.delete(a,1,axis = 1)) 
print (&#39;\n&#39;)


</code></pre>

<pre><code class="language-text">第一个数组：
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
</code></pre>

<p>​<br/><br/>
​    未传递 Axis 参数。 在删除之前输入数组会被展开。<br/>
​    [ 0  1  2  3  4  6  7  8  9 10 11]</p>

<p>​<br/><br/>
​    删除每一行中的第二列：<br/>
​    [[ 0  2  3]<br/>
​     [ 4  6  7]<br/>
​     [ 8 10 11]]</p>

<p>​<br/><br/>
​    </p>

<h3 id="toc_23">数组去重</h3>

<p>numpy.unique 函数用于去除数组中的重复元素。</p>

<ul>
<li>arr：输入数组 ，如果不是一维数组则会展开                         * return_index：如果为true，返回新列表元素在旧列表中的位置（下标），并以列表形式储</li>
<li>return_inverse：如果为true，返回旧列表元素在新列表中的位置（下标），并以列表形式储</li>
<li>return_counts：如果为true，返回去重数组中的元素在原数组中的出现次数</li>
</ul>

<pre><code class="language-python">a = np.array([5,2,6,2,7,5,6,8,2,9])
print (&#39;第一个数组：&#39;) 
print (a)
print (&#39;\n&#39;)

print (&#39;第一个数组的去重值：&#39;) 
u = np.unique(a)
print (u)
print (&#39;\n&#39;)


print (&#39;去重数组的索引数组：&#39;)
u,indices = np.unique(a, return_index = True) 
print (indices)
print (&#39;\n&#39;)

print (&#39;我们可以看到每个和原数组下标对应的数值：&#39;) 
print (a)
print (&#39;\n&#39;)

print (&#39;去重数组的下标：&#39;)
u,indices = np.unique(a,return_inverse = True) 
print (u)
print (indices) 
print (&#39;\n&#39;)

print (&#39;返回去重元素的重复数量：&#39;)
u,indices = np.unique(a,return_counts = True) # print (u)
print (indices)

</code></pre>

<pre><code class="language-text">第一个数组：
[5 2 6 2 7 5 6 8 2 9]
</code></pre>

<p>​<br/><br/>
​    第一个数组的去重值：<br/>
​    [2 5 6 7 8 9]</p>

<p>​<br/><br/>
​    去重数组的索引数组：<br/>
​    [1 0 2 4 7 9]</p>

<p>​<br/><br/>
​    我们可以看到每个和原数组下标对应的数值：<br/>
​    [5 2 6 2 7 5 6 8 2 9]</p>

<p>​<br/><br/>
​    去重数组的下标：<br/>
​    [2 5 6 7 8 9]<br/>
​    [1 0 2 0 3 1 2 4 0 5]</p>

<p>​<br/><br/>
​    返回去重元素的重复数量：<br/>
​    [3 2 2 1 1 1]</p>

<h2 id="toc_24">numpy的计算</h2>

<pre><code class="language-python">score = np.array([[80,88],[82,81],[75,81]])
print(score)

</code></pre>

<pre><code class="language-text">[[80 88]
 [82 81]
 [75 81]]
</code></pre>

<h3 id="toc_25">获取所有数据最大值</h3>

<pre><code class="language-python">print(np.max(score))

</code></pre>

<pre><code class="language-text">88
</code></pre>

<h3 id="toc_26">获取某个轴上的数据最大值</h3>

<pre><code class="language-python">print(np.max(score,axis=0))

</code></pre>

<pre><code class="language-text">[82 88]
</code></pre>

<h3 id="toc_27">获取最小值</h3>

<pre><code class="language-python">print(np.min(score))

</code></pre>

<pre><code class="language-text">75
</code></pre>

<h3 id="toc_28">获取某个轴上最小值</h3>

<pre><code class="language-python">print(np.min(score,axis=0))

</code></pre>

<pre><code class="language-text">[75 81]
</code></pre>

<h3 id="toc_29">数据的比较</h3>

<pre><code class="language-python">t1=[1,2,3,4,5,6,7,8]
print(t1)

</code></pre>

<pre><code class="language-text">[1, 2, 3, 4, 5, 6, 7, 8]
</code></pre>

<pre><code class="language-python">print(np.maximum(t1,0)) # 第一个参数中的每一个数与第二个参数比较返回大的

</code></pre>

<pre><code class="language-text">[1 2 3 4 5 6 7 8]
</code></pre>

<pre><code class="language-python">print(np.minimum(t1,0))# 第一个参数中的每一个数与第二个参数比较返回小的

</code></pre>

<pre><code class="language-text">[0 0 0 0 0 0 0 0]
</code></pre>

<pre><code class="language-python"># 接受的两个参数，也可以大小一致;第二个参数只是一个单独的值时，其实是用到了维度的广播机制
print(np.maximum(t1,[2,4,6,8,9,1,3,5]))

</code></pre>

<pre><code class="language-text">[2 4 6 8 9 6 7 8]
</code></pre>

<h3 id="toc_30">求平均值</h3>

<pre><code class="language-python">print(np.mean(t1))# 获取所有数据的平均值

</code></pre>

<pre><code class="language-text">4.5
</code></pre>

<pre><code class="language-python">print(np.mean(score,axis=0))

</code></pre>

<pre><code class="language-text">[79.         83.33333333]
</code></pre>

<h3 id="toc_31">求前缀和</h3>

<pre><code class="language-python">arr = np.array([[1,2,3], [4,5,6]]) 
print(arr)
print(&#39;*&#39;*20)
print(&#39;&#39;&#39;
[1, 2, 3]------&gt;    |  1   |  2   |  3  |
[4, 5, 6]------&gt;    |5=1+4 |7=2+5 |9=3+6| &#39;&#39;&#39;)
print(&#39;*&#39;*20)
print(arr.cumsum(0))

</code></pre>

<pre><code class="language-text">[[1 2 3]
 [4 5 6]]
********************

[1, 2, 3]------&gt;    |  1   |  2   |  3  |
[4, 5, 6]------&gt;    |5=1+4 |7=2+5 |9=3+6| 
********************
[[1 2 3]
 [5 7 9]]
</code></pre>

<pre><code class="language-python">print(&#39;&#39;&#39;
[1, 2, 3]------&gt;    |1  |2+1    |3+2+1  |
[4, 5, 6]------&gt;    |4  |4+5    |4+5+6  | &#39;&#39;&#39;)
print(&#39;*&#39;*20)
print(arr.cumsum(1)) 

</code></pre>

<pre><code class="language-text">[1, 2, 3]------&gt;    |1  |2+1    |3+2+1  |
[4, 5, 6]------&gt;    |4  |4+5    |4+5+6  | 
********************
[[ 1  3  6]
 [ 4  9 15]]
</code></pre>

<h3 id="toc_32">求最小索引值</h3>

<pre><code class="language-python">print(np.argmin(score,axis=0))

</code></pre>

<pre><code class="language-text">[2 1]
</code></pre>

<h3 id="toc_33">求每一列的标准差</h3>

<p>标准差是一组数据平均值分散程度的一种度量。一个较大的标准差，代表大部分数值和其平均值之间差异较大；</p>

<p>一个较小的标准差，代表这些数据较接近平均值反应出数据的波动稳定情况，越大表示波动越大，越不稳定。</p>

<pre><code class="language-python">print(np.std(score,axis=0))

</code></pre>

<pre><code class="language-text">[2.94392029 3.29983165]
</code></pre>

<h3 id="toc_34">极 值</h3>

<pre><code class="language-python">np.ptp(score,axis=None)# 就是最大值和最小值的差

</code></pre>

<pre><code class="language-text">13
</code></pre>

<h3 id="toc_35">拓展</h3>

<ul>
<li>方差var</li>
<li>协方差cov</li>
<li>计算平均值 average</li>
<li>计算中位数 median</li>
</ul>

<h2 id="toc_36">通用函数</h2>

<table>
<thead>
<tr>
<th>函数</th>
<th>介绍</th>
</tr>
</thead>

<tbody>
<tr>
<td>numpy.sqrt(array)</td>
<td>平方根函数</td>
</tr>
<tr>
<td>numpy.exp(array)</td>
<td>e<sup>array[i]的数组</sup></td>
</tr>
<tr>
<td>numpy.abs/fabs(array)</td>
<td>计算绝对值</td>
</tr>
<tr>
<td>numpy.square(array)</td>
<td>计算各元素的平方 等于array**2</td>
</tr>
<tr>
<td>numpy.log/log10/log2(array)</td>
<td>计算各元素的各种对数</td>
</tr>
<tr>
<td>numpy.sign(array)</td>
<td>计算各元素正负号</td>
</tr>
<tr>
<td>numpy.isnan(array)</td>
<td>计算各元素是否为NaN</td>
</tr>
<tr>
<td>numpy.isinf(array)</td>
<td>计算各元素是否为NaN</td>
</tr>
<tr>
<td>numpy.cos/cosh/sin/sinh/tan/tanh(array)</td>
<td>三角函数</td>
</tr>
<tr>
<td>numpy.modf(array)</td>
<td>将array中值得整数和小数分离，作两个数组返回</td>
</tr>
<tr>
<td>numpy.ceil(array)</td>
<td>向上取整,也就是取比这个数大的整数</td>
</tr>
<tr>
<td>numpy.floor(array)</td>
<td>向下取整,也就是取比这个数小的整数</td>
</tr>
<tr>
<td>numpy.rint(array)</td>
<td>四舍五入</td>
</tr>
<tr>
<td>numpy.trunc(array)</td>
<td>向0取整</td>
</tr>
<tr>
<td>numpy.cos(array)</td>
<td>正弦值</td>
</tr>
<tr>
<td>numpy.sin(array)</td>
<td>余弦值</td>
</tr>
<tr>
<td>numpy.tan(array)</td>
<td>正切值</td>
</tr>
<tr>
<td>numpy.add(array1,array2)</td>
<td>元素级加法</td>
</tr>
<tr>
<td>numpy.subtract(array1,array2)</td>
<td>元素级减法</td>
</tr>
<tr>
<td>numpy.multiply(array1,array2)</td>
<td>元素级乘法</td>
</tr>
<tr>
<td>numpy.divide(array1,array2)</td>
<td>元素级除法 array1./array2</td>
</tr>
<tr>
<td>numpy.power(array1,array2)</td>
<td>元素级指数 array1.<sup>array2</sup></td>
</tr>
<tr>
<td>numpy.maximum/minimum(array1,aray2)</td>
<td>元素级最大值</td>
</tr>
<tr>
<td>numpy.fmax/fmin(array1,array2)</td>
<td>元素级最大值，忽略NaN</td>
</tr>
<tr>
<td>numpy.mod(array1,array2)</td>
<td>元素级求模</td>
</tr>
<tr>
<td>numpy.copysign(array1,array2)</td>
<td>将第二个数组中值得符号复制给第一个数组中值</td>
</tr>
<tr>
<td>numpy.greater/greater_equal/less/less_equal/equal/not_equal  (array1,array2)</td>
<td>元素级比较运算，产生布尔数组</td>
</tr>
<tr>
<td>numpy.logical_end/logical_or/logic_xor(array1,array2)</td>
<td>元素级的真值逻辑运算</td>
</tr>
</tbody>
</table>

<h2 id="toc_37">数组的拼接</h2>

<p>有的时候我们需要将两个数据加起来一起研究分析，我们就可以将其进行拼接然后分析</p>

<h3 id="toc_38">根据轴连接的数组序列</h3>

<pre><code class="language-python">a = np.array([[1,2],[3,4]])
b = np.array([[5,6],[7,8]])

#要求a,b两个数组的维度相同
print (&#39;沿轴 0 连接两个数组：&#39;)
print (np.concatenate((a,b),axis= 0))
print (&#39;\n&#39;)
print (&#39;沿轴 1 连接两个数组：&#39;)
print (np.concatenate((a,b),axis = 1))

</code></pre>

<pre><code class="language-text">沿轴 0 连接两个数组：
[[1 2]
 [3 4]
 [5 6]
 [7 8]]
</code></pre>

<p>​<br/><br/>
​    沿轴 1 连接两个数组：<br/>
​    [[1 2 5 6]<br/>
​     [3 4 7 8]]</p>

<h3 id="toc_39">根据轴进行堆叠</h3>

<pre><code class="language-python">print (&#39;沿轴 0 连接两个数组：&#39;)
print (np.stack((a,b),axis= 0))
print (&#39;\n&#39;)
print (&#39;沿轴 1 连接两个数组：&#39;)
print (np.stack((a,b),axis = 1))

</code></pre>

<pre><code class="language-text">沿轴 0 连接两个数组：
[[[1 2]
  [3 4]]

 [[5 6]
  [7 8]]]
</code></pre>

<p>​<br/><br/>
​    沿轴 1 连接两个数组：<br/>
​    [[[1 2]<br/>
​      [5 6]]<br/>
​<br/><br/>
​     [[3 4]<br/>
​      [7 8]]]</p>

<h3 id="toc_40">矩阵垂直拼接</h3>

<pre><code class="language-python">v1 = [[0,1,2,3,4,5],
    [6,7,8,9,10,11]] 

v2 = [[12,13,14,15,16,17],
    [18,19,20,21,22,23]] 

result = np.vstack((v1,v2)) 
print(result)

</code></pre>

<pre><code class="language-text">[[ 0  1  2  3  4  5]
 [ 6  7  8  9 10 11]
 [12 13 14 15 16 17]
 [18 19 20 21 22 23]]
</code></pre>

<h3 id="toc_41">矩阵水平拼接</h3>

<pre><code class="language-python">result = np.hstack((v1,v2)) 
print(result)

</code></pre>

<pre><code class="language-text">[[ 0  1  2  3  4  5 12 13 14 15 16 17]
 [ 6  7  8  9 10 11 18 19 20 21 22 23]]
</code></pre>

<h2 id="toc_42">数组的分割</h2>

<h3 id="toc_43">将一个数组分割为多个子数组</h3>

<p><strong>参数说明：</strong></p>

<ul>
<li>ary： 被分割的数组<br/></li>
<li>indices_or_sections：果是一个整数，就用该数平均切分，如果是一个数组，为沿轴切分的位置（左开右闭）</li>
<li>axis：沿着哪个维度进行切向，默认为0，横向切分。为1时，纵向切分</li>
</ul>

<pre><code class="language-python">arr = np.arange(9).reshape(3,3)
print (&#39;将数组分为三个大小相等的子数组：&#39;) 
b= np.split(arr,3)
print (b)

</code></pre>

<pre><code class="language-text">将数组分为三个大小相等的子数组：
[array([[0, 1, 2]]), array([[3, 4, 5]]), array([[6, 7, 8]])]
</code></pre>

<h3 id="toc_44">numpy.hsplit 函数用于水平分割数组，通过指定要返回的相同形状的数组数量来拆分原数组。</h3>

<pre><code class="language-python">harr = np.floor(10 * np.random.random((2, 6))) #
print (&#39;原array：&#39;)
print(harr)

print (&#39;拆分后：&#39;)
print(np.hsplit(harr, 3))

</code></pre>

<pre><code class="language-text">原array：
[[6. 9. 3. 6. 1. 1.]
 [8. 3. 1. 7. 4. 5.]]
拆分后：
[array([[6., 9.],
       [8., 3.]]), array([[3., 6.],
       [1., 7.]]), array([[1., 1.],
       [4., 5.]])]
</code></pre>

<h3 id="toc_45">numpy.vsplit</h3>

<p>沿着垂直轴分割</p>

<pre><code class="language-python">a = np.arange(16).reshape(4,4)
print (&#39;第一个数组：&#39;) 
print (a)
print (&#39;\n&#39;)

print (&#39;竖直分割：&#39;)
b = np.vsplit(a,2) 
print (b)

</code></pre>

<pre><code class="language-text">第一个数组：
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]
 [12 13 14 15]]
</code></pre>

<p>​<br/><br/>
​    竖直分割：<br/>
​    [array([[0, 1, 2, 3],<br/>
​           [4, 5, 6, 7]]), array([[ 8,  9, 10, 11],<br/>
​           [12, 13, 14, 15]])]</p>

<h2 id="toc_46">数组中nan和inf</h2>

<p>C 语言中表示最大的正整数值是 0x7FFF FFFF，最小的负整数是 0x8000 0000。<br/>
查阅资料后，发现 inf 表示无穷大，需要使用 float(‘inf’) 函数来转化，那么对应的就有  float(&#39;-inf&#39;) 表示无穷小了。这样你就可以使用任意数来判断和它的关系了。</p>

<p>那什么时候会出现inf呢？ 比如一个数字除以0，Python中会报错，但是numpy中会是一个inf或者-inf</p>

<p>另外还有 nan，这种写法在 pandans 中常见，表示缺失的数据，所以一般用 nan 来表示。任何与其做运算结果都是 nan</p>

<pre><code class="language-python"># 创建一个nan和inf 
a = np.nan 
b = np.inf
print(a,type(a)) 
print(b,type(b))

#--判断数组中为nan的个数
t = np.arange(24,dtype=float).reshape(4,6)

#将三行四列的数改成nan 
t[3,4] = np.nan

#可以使用np.count_nonzero() 来判断非零的个数
print(np.count_nonzero(t))
#并 且  np.nan != np.nan  结果 是TRUE
#所以我们可以使用这两个结合使用判断nan的个数
print(np.count_nonzero(t != t))

#将nan替换为0
t[np.isnan(t)] = 0 
print(t)

</code></pre>

<pre><code class="language-text">nan &lt;class &#39;float&#39;&gt;
inf &lt;class &#39;float&#39;&gt;
23
1
[[ 0.  1.  2.  3.  4.  5.]
 [ 6.  7.  8.  9. 10. 11.]
 [12. 13. 14. 15. 16. 17.]
 [18. 19. 20. 21.  0. 23.]]
</code></pre>

<pre><code class="language-python">#----------练习： 处理数组中nan
t = np.arange(24).reshape(4,6).astype(&#39;float&#39;)
#将数组中的一部分替换nan 
t[1,3:] = np.nan
print(t)
#遍历每一列，然后判断每一列是否有nan 
for i in range(t.shape[1]):
#   #获取当前列数据
    temp_col = t[:,i]
#
#   判断当前列的数据中是否含有nan
    nan_num = np.count_nonzero(temp_col != temp_col)
#
    if nan_num != 0: #条件成立说明含有nan 
    # 将这一列不为nan的数据拿出来
        temp_col_not_nan = temp_col[temp_col==temp_col]
# 将nan替换成这一列的平均值
        temp_col[np.isnan(temp_col)] = np.mean(temp_col_not_nan)
print(t)

</code></pre>

<pre><code class="language-text">[[ 0.  1.  2.  3.  4.  5.]
 [ 6.  7.  8. nan nan nan]
 [12. 13. 14. 15. 16. 17.]
 [18. 19. 20. 21. 22. 23.]]
[[ 0.  1.  2.  3.  4.  5.]
 [ 6.  7.  8. 13. 14. 15.]
 [12. 13. 14. 15. 16. 17.]
 [18. 19. 20. 21. 22. 23.]]
</code></pre>

<h2 id="toc_47">二维数组的转置</h2>

<pre><code class="language-python">#对换数组的维度
a = np.arange(12).reshape(3,4) 
print (&#39;原数组：&#39;)
print (a )
print (&#39;\n&#39;)

print (&#39;对换数组：&#39;)
print (np.transpose(a))

# 与transpose一致
a = np.arange(12).reshape(3,4)

print (&#39;原数组：&#39;) 
print (a)
print (&#39;\n&#39;)

print (&#39;转置数组：&#39;) 
print (a.T)

# 函数用于交换数组的两个轴
t1 = np.arange(24).reshape(4,6)
re = t1.swapaxes(1,0) 
print (&#39; 原 数 组 ：&#39;) 
print (t1)
print (&#39;\n&#39;)

print (&#39;调用 swapaxes 函数后的数组：&#39;) 
print (re)

</code></pre>

<pre><code class="language-text">原数组：
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
</code></pre>

<p>​<br/><br/>
​    对换数组：<br/>
​    [[ 0  4  8]<br/>
​     [ 1  5  9]<br/>
​     [ 2  6 10]<br/>
​     [ 3  7 11]]<br/>
​    原数组：<br/>
​    [[ 0  1  2  3]<br/>
​     [ 4  5  6  7]<br/>
​     [ 8  9 10 11]]</p>

<p>​<br/><br/>
​    转置数组：<br/>
​    [[ 0  4  8]<br/>
​     [ 1  5  9]<br/>
​     [ 2  6 10]<br/>
​     [ 3  7 11]]<br/>
​     原 数 组 ：<br/>
​    [[ 0  1  2  3  4  5]<br/>
​     [ 6  7  8  9 10 11]<br/>
​     [12 13 14 15 16 17]<br/>
​     [18 19 20 21 22 23]]</p>

<p>​    调用 swapaxes 函数后的数组：<br/>
​    [[ 0  6 12 18]<br/>
​     [ 1  7 13 19]<br/>
​     [ 2  8 14 20]<br/>
​     [ 3  9 15 21]<br/>
​     [ 4 10 16 22]<br/>
​     [ 5 11 17 23]]</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/02/21</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%B8%B8%E7%94%A8%E5%BA%93.html'>常用库</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15822327223959.html">
                
                  <h1>1. matplotlib</h1>
                 <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">matplotlib介绍</h2>

<p>Matplotlib是一个Python2D绘图库，它可以在各种平台上以各种硬拷贝格式和交互式环境生成出具有出版品质的图形。 Matplotlib可用于Python脚本，Python和IPython shell，Jupyter笔记本，Web应用程序服务器和四个图形用户界面工具包。</p>

<p>Matplotlib试图让简单的事情变得更简单，让无法实现的事情变得可能实现。 只需几行代码即可生成绘图，直方图， 功率谱，条形图，错误图，散点图等。</p>

<p>为了简单绘图，pyplot模块提供了类似于MATLAB的界面，特别是与IPython结合使用时。 对于高级用户，您可以通过面向对象的界面或MATLAB用户熟悉的一组函数完全控制线条样式，字体属性，轴属性等。</p>

<h2 id="toc_1">matplotlib优点</h2>

<p>可视化是在整个数据挖掘的关键辅助工具，可以清晰的理解数据，从而调整我们的分析方法。</p>

<ul>
<li>能将数据进行可视化,更直观的呈现</li>
<li>使数据更加客观、更具说服力</li>
</ul>

<p>例如下面两个图为数字展示和图形展示：<br/>
<img src="media/15822327223959/2.1.jpg" alt=""/></p>

<h2 id="toc_2">常见图形种类及意义</h2>

<ul>
<li><p>折线图：以折线的上升或下降来表示统计数量的增减变化的统计图</p>
<p><strong>特点：能够显示数据的变化趋势，反映事物的变化情况。(变化)</strong></p></li>
</ul>

<p><img src="media/15822327223959/clip_image007.gif" alt=""/></p>

<ul>
<li><p>散点图：用两组数据构成多个坐标点，考察坐标点的分布,判断两变量之间是否存在某种关联或总结坐标点的分布模式。</p>
<p><strong>特点：判断变量之间是否存在数量关联趋势,展示离群点(分布规律)</strong></p></li>
</ul>

<p><img src="media/15822327223959/20191127101123.png" alt=""/></p>

<ul>
<li>柱状图：排列在工作表的列或行中的数据可以绘制到柱状图中。
<strong>特点：绘制连离散的数据,能够一眼看出各个数据的大小,比较数据之间的差别。(统计/对比)</strong>
<img src="media/15822327223959/20191127101217.png" alt=""/></li>
<li>直方图：由一系列高度不等的纵向条纹或线段表示数据分布的情况。   一般用横轴表示数据范围，纵轴表示分布情况。
<strong>特点：绘制连续性的数据展示一组或者多组数据的分布状况(统计)</strong></li>
</ul>

<p><img src="media/15822327223959/20191127101232.png" alt=""/></p>

<ul>
<li>饼图：用于表示不同分类的占比情况，通过弧度大小来对比各种分类。
<strong>特点：分类数据的占比情况(占比)</strong>
<img src="media/15822327223959/20191127101311.png" alt=""/></li>
</ul>

<h2 id="toc_3">安装</h2>

<pre><code class="language-text">source activate python37 
pip install matplotlib
</code></pre>

<h2 id="toc_4">Matplotlib画图</h2>

<pre><code class="language-python"># 导入模块
import matplotlib.pyplot as plt
# 在jupyter中执行的时候显示图片
%matplotlib inline
# 传入x和y, 通过plot画图
plt.plot([1, 0, 9], [4, 5, 6])
# 在执行程序的时候展示图形
plt.show()
</code></pre>

<p><img src="media/15822327223959/output20.png" alt="png"/></p>

<h2 id="toc_5">matplotlib图像结构的认识</h2>

<p><img src="media/15822327223959/20191127101529.png" alt=""/></p>

<h2 id="toc_6">折线图</h2>

<h3 id="toc_7">折线图的绘制</h3>

<pre><code class="language-python">from matplotlib import pyplot as plt 
x = range(1,8) # x轴的位置
y = [17, 17, 18, 15, 11, 11, 13]
# 传入x和y, 通过plot画折线图
plt.plot(x,y) 
plt.show()
</code></pre>

<p><img src="media/15822327223959/output40.png" alt="png"/></p>

<h3 id="toc_8">折线图的颜色和形状设置</h3>

<pre><code class="language-python">from matplotlib import pyplot as plt 


x = range(1,8) # x轴的位置
y = [17, 17, 18, 15, 11, 11, 13]
# 传入x和y, 通过plot画折线图
plt.plot(x, y, color=&#39;red&#39;,alpha=0.5,linestyle=&#39;--&#39;,linewidth=3) 


&#39;&#39;&#39;
基础属性设置
color=&#39;red&#39; : 折线的颜色
alpha=0.5: 折线的透明度(0-1) 
linestyle=&#39;--&#39; : 折线的样式
linewidth=3 : 折线的宽度
&#39;&#39;&#39;

&#39;&#39;&#39;
线的样式
-   实线(solid)
--  短线(dashed)
-.  短点相间线(dashdot)
：   虚点线(dotted)
&#39;&#39;&#39;
plt.show()
</code></pre>

<p><img src="media/15822327223959/output60.png" alt="png"/></p>

<h3 id="toc_9">折点样式</h3>

<pre><code class="language-python">from matplotlib import pyplot as plt 
x = range(1,8) # x轴的位置
y = [17, 17, 18, 15, 11, 11, 13]
# 传入x和y, 通过plot画折线图
plt.plot(x, y, marker=&#39;o&#39;) 
plt.show()
&#39;&#39;&#39;
折点形状选择:
================    ===============================
 
character   description
================    ===============================
``&#39;-&#39;`` solid line style
``&#39;--&#39;``    dashed line style
``&#39;-.&#39;``    dash-dot line style
``&#39;:&#39;`` dotted line style
``&#39;.&#39;`` point marker
``&#39;,&#39;`` pixel marker
``&#39;o&#39;`` circle marker
``&#39;v&#39;`` triangle_down marker
``&#39;^&#39;`` triangle_up marker
``&#39;&lt;&#39;`` triangle_left marker
``&#39;&gt;&#39;`` triangle_right marker
``&#39;1&#39;`` tri_down marker
``&#39;2&#39;`` tri_up marker
``&#39;3&#39;`` tri_left marker
``&#39;4&#39;`` tri_right marker
``&#39;s&#39;`` square marker
``&#39;p&#39;`` pentagon marker
``&#39;*&#39;`` star marker
``&#39;h&#39;`` hexagon1 marker
``&#39;H&#39;`` hexagon2 marker
``&#39;+&#39;`` plus marker
``&#39;x&#39;`` x marker
``&#39;D&#39;`` diamond marker
``&#39;d&#39;`` thin_diamond marker
``&#39;|&#39;`` vline marker
``&#39;_&#39;`` hline marker
&#39;&#39;&#39;

plt.show()

</code></pre>

<p><img src="media/15822327223959/output80.png" alt="png"/></p>

<h3 id="toc_10">设置图片的大小和保存</h3>

<pre><code class="language-python">from matplotlib import pyplot as plt 
import random

x = range(2,26,2) # x轴的位置
y = [random.randint(15, 30) for i in x]
# 设置图片的大小
&#39;&#39;&#39;
figsize:指定figure的宽和高，单位为英寸；
dpi参数指定绘图对象的分辨率，即每英寸多少个像素，缺省值为80    1英寸等于2.5cm,A4纸是 21*30cm的纸张
&#39;&#39;&#39;
# 根据画布对象
plt.figure(figsize=(20,8),dpi=80)
 
plt.plot(x,y)   # 传入x和y, 通过plot画图
# plt.show()
# 保存(注意： 要放在绘制的下面,并且plt.show()会释放figure资源，如果在显示图像之后保存图片将只能保存空图片。)
plt.savefig(&#39;./t1.png&#39;)
# 图片的格式也可以保存为svg这种矢量图格式，这种矢量图放在网页中放大后不会有锯齿
# plt.savefig(&#39;./t1.svg&#39;)
</code></pre>

<p><img src="media/15822327223959/output100.png" alt="png"/></p>

<h3 id="toc_11">绘制x轴和y轴刻度</h3>

<pre><code class="language-python">from matplotlib import pyplot as plt 
x = range(2,26,2) # x轴的位置
y = [random.randint(15, 30) for i in x] 
plt.figure(figsize=(20,8),dpi=80)

# 设置x轴的刻度
# plt.xticks(x)
# plt.xticks(range(1,25))
# 设置y轴的刻度
# plt.yticks(y)
# plt.yticks(range(min(y),max(y)+1))

# 构造x轴刻度标签
x_ticks_label = [&quot;{}:00&quot;.format(i) for i in x] #rotation = 45 让字旋转45度plt.xticks(x,x_ticks_label,rotation = 45)
# 设置y轴的刻度标签
y_ticks_label = [&quot;{}℃&quot;.format(i) for i in range(min(y),max(y)+1)]
plt.yticks(range(min(y),max(y)+1),y_ticks_label)

# 绘 图
plt.plot(x,y) 
plt.show()
</code></pre>

<p><img src="media/15822327223959/output120.png" alt="png"/></p>

<h3 id="toc_12">设置显示中文</h3>

<pre><code class="language-python"># matplotlib只显示英文,无法显示中文，需要修改matplotlib的默认字体
# 通过matplotlib下的font_manager可以解决
# 两个小时内的每分钟跳动变化
from matplotlib import pyplot as plt 
import matplotlib
import random


x = range(0,120)
y = [random.randint(10,30) for i in range(120)]
plt.figure(figsize=(20,8),dpi=80) 
plt.plot(x,y)
# 加坐标轴信息
# 在有中文输出的地方，增加一个属性： fontproperties
# plt.xlabel(&#39;时间&#39;,fontproperties = &#39;simHei&#39;,fontsize=20)
&#39;&#39;&#39;
另外一种写法
查看Linux、Mac下支持的字体
终端执行： fc-list
查看支持的中文（冒号前面有空格) fc-list :lang=zh
查看Windows下的字体：“C:\Windows\Fonts”
可以自己下载字体文件（xxx.ttf），然后双击安装即可

# my_font = font_manager.FontProperties(fname=&#39;/System/Library/Fonts/PingFang.ttc&#39;,size=18) 
# plt.ylabel(&quot;天气&quot;,fontproperties=my_font)
&#39;&#39;&#39;



from matplotlib import font_manager
my_font = font_manager.FontProperties(fname=r&quot;C:/Windows/Fonts/msyh.ttc&quot;,size=16)#msyh为微软雅黑

#rotation将字体旋转45度
plt.xlabel(&#39;时间&#39;,rotation=45,fontproperties=my_font)
plt.ylabel(&quot;次数&quot;,fontproperties=my_font)

# 设置标题
plt.title(&#39;每分钟跳动次数&#39;,fontproperties=my_font,color=&#39;green&#39;)

plt.show()
</code></pre>

<p><img src="media/15822327223959/output140.png" alt="png"/></p>

<h3 id="toc_13">一图多线</h3>

<pre><code class="language-python">y1 = [1,0,1,1,2,4,3,4,4,5,6,5,4,3,3,1,1,1,1,1]
y2 = [1,0,3,1,2,2,3,4,3,2,1,2,1,1,1,1,1,1,1,1]
 
x = range(11,31) # # 设置图形
plt.figure(figsize=(20,8),dpi=80) 
&#39;&#39;&#39;
添加图例:label 对线的解释，然后用plt.legend添加到图片上;
添加颜色: color=&#39;red&#39;
线条风格： linestyle=&#39;-&#39;;    - 实线 、 -- 虚线，破折线、 -. 点划线、 : 点虚线，虚线、 &#39;&#39; 留空或空格线条粗细： linewidth = 5
透明度：    alpha=0.5
&#39;&#39;&#39;
plt.plot(x,y1,color=&#39;red&#39;,label=&#39;自己&#39;)
plt.plot(x,y2,color=&#39;blue&#39;,label=&#39;同事&#39;)
# 设置x轴刻度
xtick_labels = [&#39;{}岁&#39;.format(i) for i in x]
my_font = font_manager.FontProperties(fname=r&quot;C:/Windows/Fonts/msyh.ttc&quot;,size=16) 
plt.xticks(x,xtick_labels,fontproperties=my_font,rotation=45)
# 绘制网格（网格也是可以设置线的样式)
#alpha=0.4 设置透明度
plt.grid(alpha=0.4)

# 添加图例(注意：只有在这里需要添加prop参数是显示中文，其他的都用fontproperties)
# 设置位置loc : upper left、 lower left、 center left、 upper center
plt.legend(prop=my_font,loc=&#39;upper right&#39;)

#展示
plt.show()

</code></pre>

<p><img src="media/15822327223959/output160.png" alt="png"/></p>

<h3 id="toc_14">拓展（一图多个坐标系子图）</h3>

<pre><code class="language-python">import matplotlib.pyplot as plt 
import numpy as np

x = np.arange(1, 100)
#划分子图
fig,axes=plt.subplots(2,2)
ax1=axes[0,0]
ax2=axes[0,1] 
ax3=axes[1,0] 
ax4=axes[1,1]

fig=plt.figure(figsize=(20,10),dpi=80)
# 作 图 1 
ax1.plot(x, x)
#作图2
ax2.plot(x, -x)
#作图3
ax3.plot(x, x ** 2)
# ax3.grid(color=&#39;r&#39;, linestyle=&#39;--&#39;, linewidth=1,alpha=0.3)
#作图4
ax4.plot(x, np.log(x)) 
plt.show()
</code></pre>

<p><img src="media/15822327223959/output180.png" alt="png"/></p>

<pre><code class="language-text">&lt;Figure size 1600x800 with 0 Axes&gt;
</code></pre>

<pre><code class="language-python"># add_subplot方法 给figure新增子图
import numpy as np
import matplotlib.pyplot as plt 
x = np.arange(0,100)
#新建figure对象
fig=plt.figure(figsize=(20,10),dpi=80)
# 新 建 子 图 1 
ax1=fig.add_subplot(2,2,1)
ax1.plot(x, x)
# 新 建 子 图 2 
ax3=fig.add_subplot(2,2,2)
ax3.plot(x, x ** 2)
ax3.grid(color=&#39;r&#39;, linestyle=&#39;--&#39;, linewidth=1,alpha=0.3)
# 新 建 子 图 3 
ax4=fig.add_subplot(2,2,3)
ax4.plot(x, np.log(x)) 
plt.show()
</code></pre>

<pre><code class="language-text">E:\anaconda\lib\site-packages\ipykernel_launcher.py:16: RuntimeWarning: divide by zero encountered in log
  app.launch_new_instance()
</code></pre>

<p><img src="media/15822327223959/output191.png" alt="png"/></p>

<h2 id="toc_15">绘制散点图</h2>

<p><strong>题干</strong>:3月份每天最高气温</p>

<p>a = [11,17,16,11,12,11,12,6,6,7,8,9,12,15,14,17,18,21,16,17,20,14,15,15,15,19,21,22,22,22,23] </p>

<pre><code class="language-python">from matplotlib import pyplot as plt 
from matplotlib import font_manager
y = [11,17,16,11,12,11,12,6,6,7,8,9,12,15,14,17,18,21,16,17,20,14,15,15,15,19,21,22,22,22,23]
x = range(1,32)#3月份31天

# 设置图形大小
plt.figure(figsize=(20,8),dpi=80)

# 使用scatter绘制散点图
plt.scatter(x,y,label= &#39;3月份&#39;)

# 调整x轴的刻度
my_font = font_manager.FontProperties(fname=r&quot;C:/Windows/Fonts/msyh.ttc&quot;,size=10)

_xticks_labels = [&#39;3 月 {} 日 &#39;.format(i) for i in x] 
plt.xticks(x[::3],_xticks_labels[::3],fontproperties=my_font,rotation=45)
plt.xlabel(&#39;日期&#39;,fontproperties=my_font)
plt.ylabel(&#39;温度&#39;,fontproperties=my_font)
# 图 例
plt.legend(prop=my_font) 
plt.show()
</code></pre>

<p><img src="media/15822327223959/output210.png" alt="png"/></p>

<h2 id="toc_16">绘制条形图</h2>

<p>假设你获取到了2019年内地电影票房前20的电影（列表a)和电影票房数据（列表b)，请展示该数据</p>

<p>a = [&#39;流浪地球&#39;,&#39;疯狂的外星人&#39;,&#39;飞驰人生&#39;,&#39;大黄蜂&#39;,&#39;熊出没·原始时代&#39;,&#39;新喜剧之王&#39;]</p>

<p>b = [&#39;38.13&#39;,&#39;19.85&#39;,&#39;14.89&#39;,&#39;11.36&#39;,&#39;6.47&#39;,&#39;5.93&#39;] </p>

<pre><code class="language-python">from matplotlib import pyplot as plt 
from matplotlib import font_manager

my_font = font_manager.FontProperties(fname=r&quot;C:/Windows/Fonts/msyh.ttc&quot;,size=10) 

a = [&#39;流浪地球&#39;,&#39;疯狂的外星人&#39;,&#39;飞驰人生&#39;,&#39;大黄蜂&#39;,&#39;熊出没·原始时代&#39;,&#39;新喜剧之王&#39;]
b = [38.13,19.85,14.89,11.36,6.47,5.93]

plt.figure(figsize=(20,8),dpi=80)#确定图形大小
 
# 绘制条形图的方法
&#39;&#39;&#39;
width=0.3   条形的宽度
&#39;&#39;&#39;
rects = plt.bar(range(len(a)),b,width=0.3,color=&#39;g&#39;) 
plt.xticks(range(len(a)),a,fontproperties=my_font,rotation=45)
# 在条形图上加标注(水平居中) 
for rect in rects:
    height = rect.get_height()
    
plt.text(rect.get_x() + rect.get_width() / 2, height+0.3, str(height),ha=&quot;center&quot;) 
plt.show()

</code></pre>

<p><img src="media/15822327223959/output230.png" alt="png"/></p>

<h2 id="toc_17">直方图</h2>

<p>现有250部电影的时长，希望统计出这些电影时长的分布状态(比如时长为100分钟到120分钟电影的数量，出现的频率)等信息，你应该如何呈现这些数据？</p>

<pre><code class="language-python">from matplotlib import pyplot as plt 
from matplotlib import font_manager
# 1）准备数据
time = [131,98,125,131,124,139,131, 117, 128, 108, 135, 138, 131, 102, 107, 114,
119,128,121,142,127,130,124, 101, 110, 116, 117, 110, 128, 128, 115,99,
136,126,134,95,138,117,111,78, 132, 124, 113, 150, 110, 117,86,95, 144,
105, 126, 130,126, 130, 126, 116, 123, 106, 112, 138, 123,86, 101,99, 136,123,
117,119,105,137, 123, 128, 125, 104, 109, 134, 125, 127,105, 120,107,129, 116,
108,132,103,136, 118, 102, 120, 114,105, 115, 132, 145, 119, 121,112,139, 125,
138,109,132,134,156, 106, 117, 127, 144, 139, 139, 119, 140,83,110,102,123,
107,143,115,136, 118, 139, 123, 112, 118, 125, 109, 119, 133,112,114,122, 109,
106,123,116,131,127, 115, 118, 112, 135,115,146,137,116,103,144,83,123,
111,110,111,100,154,136, 100, 118, 119, 133,134,106,129,126,110,111,109,
141,120, 117, 106, 149, 122, 122, 110, 118, 127, 121, 114, 125, 126,114, 140, 103,
130,141, 117, 106, 114, 121, 114, 133, 137,92,121,112,146,97,137, 105,98,
117,112,81,97, 139, 113,134, 106, 144, 110, 137,137,111,104,117, 100, 111,
101,110,105, 129, 137, 112, 120, 113, 133, 112,83,94,146,133,101,131, 116,
111,84, 137, 115, 122, 106, 144, 109, 123, 116, 111,111, 133, 150]

my_font = font_manager.FontProperties(fname=r&quot;C:/Windows/Fonts/msyh.ttc&quot;,size=10)  
# 2）创建画布
plt.figure(figsize=(20, 8), dpi=100) 

# 3）绘制直方图
# 设置组距
distance = 2
# 计算组数
group_num = int((max(time) - min(time)) / distance)
# 绘制直方图
plt.hist(time, bins=group_num)

# 修改x轴刻度显示
plt.xticks(range(min(time), max(time))[::2])

# 添加网格显示
plt.grid(linestyle=&quot;--&quot;, alpha=0.5)

# 添加x, y轴描述信息
plt.xlabel(&quot;电影时长大小&quot;,fontproperties=my_font)
plt.ylabel(&quot;电影的数据量&quot;,fontproperties=my_font)

# 4）显示图像
plt.show()
</code></pre>

<p><img src="media/15822327223959/output250.png" alt="png"/></p>

<h2 id="toc_18">饼状图</h2>

<pre><code class="language-python">import matplotlib.pyplot as plt
import matplotlib
from matplotlib import font_manager
my_font = font_manager.FontProperties(fname=r&quot;C:/Windows/Fonts/msyh.ttc&quot;,size=10)

#正常显示中文的方法
plt.rcParams[&#39;font.sans-serif&#39;]=[&#39;SimHei&#39;]



label_list = [&quot;第一部分&quot;, &quot;第二部分&quot;, &quot;第三部分&quot;]   # 各部分标签
size = [55, 35, 10] # 各部分大小
color = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]    # 各部分颜色
explode = [0, 0.05, 0]  # 各部分突出值
&quot;&quot;&quot;
绘制饼图
explode：设置各部分突出
label:设置各部分标签
labeldistance:设置标签文本距圆心位置，1.1表示1.1倍半径autopct：设置圆里面文本
shadow：设置是否有阴影
startangle：起始角度，默认从0开始逆时针转pctdistance：设置圆内文本距圆心距离
返回值
l_text：圆内部文本，matplotlib.text.Text object
p_text：圆外部文本
&quot;&quot;&quot;
patches, l_text, p_text = plt.pie(size,
                                  explode=explode, 
                                  colors=color, 
                                  labels=label_list, 
                                  labeldistance=1.1, 
                                  autopct=&quot;%1.1f%%&quot;, 
                                  shadow=False, 
                                  startangle=90, 
                                  pctdistance=0.6)


plt.axis(&quot;equal&quot;)   # 设置横轴和纵轴大小相等，这样饼才是圆的
plt.legend() 
plt.show()

</code></pre>

<p><img src="media/15822327223959/output270.png" alt="png"/></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/02/21</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%B8%B8%E7%94%A8%E5%BA%93.html'>常用库</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15822327224092.html">
                
                  <h1>3. pandas</h1>
                 <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">Pandas简介</h2>

<p>Pandas 是基于NumPy 的一种工具，该工具是为了解决数据分析任务而创建的。Pandas 纳入了大量库和一些标准的数据模型，提供了高效地操作大型数据集所需的工具。pandas提供了大量能使我们快速便捷地处理数据的函数和方法。</p>

<h2 id="toc_1">Series对象</h2>

<p>Pandas基于两种数据类型：series与dataframe。</p>

<p>Series是Pandas中最基本的对象，Series类似一种一维数组。事实上，Series 基本上就是基于 NumPy 的数组对象来的。和 NumPy 的数组不同，Series 能为数据自定义标签，也就是索引（index），然后通过索引来访问数组中的数据。</p>

<p>Dataframe是一个二维的表结构。Pandas的dataframe可以存储许多种不同的数据类型，并且每一个坐标轴都有自己的标签。你可以把它想象成一个series的字典项。</p>

<pre><code class="language-python">import pandas as pd
from pandas import Series,DataFrame
import numpy as np
</code></pre>

<h3 id="toc_2">创建series</h3>

<p>index 参数是可省略的，你可以选择不输入这个参数。<br/>
如果不带 index 参数，Pandas 会自动用默认 index 进行索引，类似数组，索引值是 [0, ..., len(data) - 1]</p>

<pre><code class="language-python">sel=Series([1,2,3,4])
print(sel)
</code></pre>

<pre><code class="language-text">0    1
1    2
2    3
3    4
dtype: int64
</code></pre>

<pre><code class="language-python">#通常创建方式
sel=Series([1,2,3,4],index=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])
#sel=Series([1,2,3,4],index=list(&#39;abcd&#39;))
print(sel)
</code></pre>

<pre><code class="language-text">a    1
b    2
c    3
d    4
dtype: int64
</code></pre>

<pre><code class="language-python">print(sel.values) #获取索引值
print(sel.index) #获取检索值
print(sel.iteritems()) #获取索引和值对
</code></pre>

<pre><code class="language-text">[1 2 3 4]
Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;], dtype=&#39;object&#39;)
&lt;zip object at 0x00000000085838C8&gt;
</code></pre>

<h4 id="toc_3">字典转化为Series</h4>

<pre><code class="language-python">dict={&quot;red&quot;:100,&quot;black&quot;:400,&quot;green&quot;:300,&quot;pink&quot;:900}
se3=Series(dict) 
print(se3)
</code></pre>

<pre><code class="language-text">red      100
black    400
green    300
pink     900
dtype: int64
</code></pre>

<h4 id="toc_4">Series数据获取</h4>

<pre><code class="language-python"># Series对象同时支持位置和标签两种方式获取数据
print(&#39;索引下标&#39;,sel[&#39;c&#39;])
print(&#39;位置下标&#39;,sel[2])
</code></pre>

<pre><code class="language-text">索引下标 3
位置下标 3
</code></pre>

<pre><code class="language-python">#获取不连续的数据
print(&#39;索引下标&#39;,sel[[&#39;a&#39;,&#39;c&#39;]])
print(&#39;位置下标&#39;,sel[[1,3]])
</code></pre>

<pre><code class="language-text">索引下标 a    1
c    3
dtype: int64
位置下标 b    2
d    4
dtype: int64
</code></pre>

<pre><code class="language-python">#可以使用切片获取数据
print(&#39;索引下标&#39;,sel[&#39;a&#39;:&#39;c&#39;])
print(&#39;位置下标&#39;,sel[0:3])
</code></pre>

<pre><code class="language-text">索引下标 a    1
b    2
c    3
dtype: int64
位置下标 a    1
b    2
c    3
dtype: int64
</code></pre>

<pre><code class="language-python">#重新赋值索引值
sel.index=[&#39;d&#39;,&#39;f&#39;,&#39;h&#39;,&#39;g&#39;]
print(sel)
</code></pre>

<pre><code class="language-text">d    1
f    2
h    3
g    4
dtype: int64
</code></pre>

<pre><code class="language-python">#ReIndex重新索引,会返回一个新的Series(调用reindex将会重新排序，缺失值则用NaN填补) 
print(sel.reindex([&#39;b&#39;,&#39;a&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;]))
print(sel)

</code></pre>

<pre><code class="language-text">b    NaN
a    NaN
c    NaN
d    1.0
e    NaN
dtype: float64
d    1
f    2
h    3
g    4
dtype: int64
</code></pre>

<pre><code class="language-python">#Drop丢弃指定轴的项
se1=pd.Series(range(10,15)) 
print(se1) 
print(se1.drop([2,3]))

</code></pre>

<pre><code class="language-text">0    10
1    11
2    12
3    13
4    14
dtype: int64
0    10
1    11
4    14
dtype: int64
</code></pre>

<h3 id="toc_5">Series 进行算术运算操作</h3>

<p>对 Series 的算术运算都是基于 index 进行的。</p>

<p>我们可以用加减乘除（+ - * /）这样的运算符对两个 Series 进行运算，</p>

<p>Pandas 将会根据索引 index，对响应的数据进行计算，结果将会以浮点数的形式存储，以避免丢失精度。</p>

<p>如果 Pandas 在两个 Series 里找不到相同的 index，对应的位置就返回一个空值 NaN</p>

<pre><code class="language-python">series1 = pd.Series([1,2,3,4],[&#39;London&#39;,&#39;HongKong&#39;,&#39;Humbai&#39;,&#39;lagos&#39;])
series2 = pd.Series([1,3,6,4],[&#39;London&#39;,&#39;Accra&#39;,&#39;lagos&#39;,&#39;Delhi&#39;])

</code></pre>

<pre><code class="language-python">print(series1+series2)
print(&#39;-&#39;*20)
print(series1+series2)
print(&#39;-&#39;*20)
print(series1*series2)

</code></pre>

<pre><code class="language-text">Accra        NaN
Delhi        NaN
HongKong     NaN
Humbai       NaN
London       2.0
lagos       10.0
dtype: float64
--------------------
Accra        NaN
Delhi        NaN
HongKong     NaN
Humbai       NaN
London       2.0
lagos       10.0
dtype: float64
--------------------
Accra        NaN
Delhi        NaN
HongKong     NaN
Humbai       NaN
London       1.0
lagos       24.0
dtype: float64
</code></pre>

<h4 id="toc_6">series支持numpy数组运算</h4>

<pre><code class="language-python">sel =Series(data = [1,6,3,5], index =[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;]) 
print(sel[sel&gt;3])#布尔数组过滤
print(&#39;-&#39;*20)
print(sel*2)
print(&#39;-&#39;*20)
print(np.square(sel))#直接加入到numpy的数学函数

</code></pre>

<pre><code class="language-text">b    6
d    5
dtype: int64
--------------------
a     2
b    12
c     6
d    10
dtype: int64
--------------------
a     1
b    36
c     9
d    25
dtype: int64
</code></pre>

<h2 id="toc_7">DataFrame</h2>

<p>DataFrame（数据表）是一种 2 维数据结构，数据以表格的形式存储，分成若干行和列。通过 DataFrame，你能很方便地处理数据。常见的操作比如选取、替换行或列的数据，还能重组数据表、修改索引、多重筛选等。我们基本上   可以把 DataFrame 理解成一组采用同样索引的 Series 的集合。调用DataFrame()可以将多种格式的数据转换为<br/>
DataFrame对象，它的的三个参数data、index和columns分别为数据、行索引和列索引。</p>

<h3 id="toc_8">DataFrame的创建</h3>

<pre><code class="language-python">df1 = DataFrame(np.random.randint(0,10,(4,4)),index=[1,2,3,4],columns=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;]) 
print(df1)

</code></pre>

<pre><code class="language-text">   a  b  c  d
1  9  3  7  2
2  8  8  4  3
3  5  5  7  0
4  4  0  7  2
</code></pre>

<h4 id="toc_9">字典创建</h4>

<p>行索引由index决定，列索引由字典的键决定</p>

<pre><code class="language-python">dict={
&#39;Province&#39;: [&#39;Guangdong&#39;, &#39;Beijing&#39;, &#39;Qinghai&#39;, &#39;Fujian&#39;],
&#39;pop&#39;: [1.3, 2.5, 1.1, 0.7],
&#39;year&#39;: [2018, 2018, 2018, 2018]}
df2=pd.DataFrame(dict,index=[1,2,3,4]) 
print(df2)


</code></pre>

<pre><code class="language-text">    Province  pop  year
1  Guangdong  1.3  2018
2    Beijing  2.5  2018
3    Qinghai  1.1  2018
4     Fujian  0.7  2018
</code></pre>

<h4 id="toc_10">使用from_dict</h4>

<pre><code class="language-python">dict2={&#39;a&#39;:[1,2,3],&#39;b&#39;:[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]}
df3=pd.DataFrame.from_dict(dict2)
print(df3)

</code></pre>

<pre><code class="language-text">   a  b
0  1  a
1  2  b
2  3  c
</code></pre>

<pre><code class="language-python">#索引相同的情况下，相同索引的值会相对应，缺少的值会添加NaN 
data = {
    &#39;Name&#39;:pd.Series([&#39;zs&#39;,&#39;ls&#39;,&#39;we&#39;],index=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]),
    &#39;Age&#39;:pd.Series([&#39;10&#39;,&#39;20&#39;,&#39;30&#39;,&#39;40&#39;],index=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;]),
    &#39;country&#39;:pd.Series([&#39;中国&#39;,&#39;日本&#39;,&#39;韩国&#39;],index=[&#39;a&#39;,&#39;c&#39;,&#39;b&#39;])
}

df = pd.DataFrame(data) 
print(df)
# to_dict()方法将DataFrame对象转换为字典
dict = df.to_dict()
print(dict)


</code></pre>

<pre><code class="language-text">  Name Age country
a   zs  10      中国
b   ls  20      韩国
c   we  30      日本
d  NaN  40     NaN
{&#39;Name&#39;: {&#39;a&#39;: &#39;zs&#39;, &#39;b&#39;: &#39;ls&#39;, &#39;c&#39;: &#39;we&#39;, &#39;d&#39;: nan}, &#39;Age&#39;: {&#39;a&#39;: &#39;10&#39;, &#39;b&#39;: &#39;20&#39;, &#39;c&#39;: &#39;30&#39;, &#39;d&#39;: &#39;40&#39;}, &#39;country&#39;: {&#39;a&#39;: &#39;中国&#39;, &#39;b&#39;: &#39;韩国&#39;, &#39;c&#39;: &#39;日本&#39;, &#39;d&#39;: nan}}
</code></pre>

<h3 id="toc_11">DataFrame对象常用属性</h3>

<pre><code class="language-python">import pandas as pd
from pandas import Series,DataFrame
import numpy as np

#数据
df_dict = {
    &#39;name&#39;:[&#39;James&#39;,&#39;Curry&#39;,&#39;Iversion&#39;],
    &#39;age&#39;:[&#39;18&#39;,&#39;20&#39;,&#39;19&#39;],
    &#39;national&#39;:[&#39;us&#39;,&#39;China&#39;,&#39;us&#39;]
}


df=pd.DataFrame(df_dict,index=[0,1,2])

print(df)

</code></pre>

<pre><code class="language-text">       name age national
0     James  18       us
1     Curry  20    China
2  Iversion  19       us
</code></pre>

<pre><code class="language-python">#获取行列数
print(df.shape)

</code></pre>

<pre><code class="language-text">(3, 3)
</code></pre>

<pre><code class="language-python">#获取行索引
print(df.index.tolist())

</code></pre>

<pre><code class="language-text">[0, 1, 2]
</code></pre>

<pre><code class="language-python">#获取列索引
print(df.columns.tolist())

</code></pre>

<pre><code class="language-text">[&#39;name&#39;, &#39;age&#39;, &#39;national&#39;]
</code></pre>

<pre><code class="language-python">#获取数据类型
print(df.dtypes)

</code></pre>

<pre><code class="language-text">name        object
age         object
national    object
dtype: object
</code></pre>

<pre><code class="language-python">#获取数据维度
print(df.ndim)

</code></pre>

<pre><code class="language-text">2
</code></pre>

<pre><code class="language-python">#values属性也会以二维ndarray的形式返回DataFrame的数据
print(df.values)

</code></pre>

<pre><code class="language-text">[[&#39;James&#39; &#39;18&#39; &#39;us&#39;]
 [&#39;Curry&#39; &#39;20&#39; &#39;China&#39;]
 [&#39;Iversion&#39; &#39;19&#39; &#39;us&#39;]]
</code></pre>

<pre><code class="language-python">#展示概况
print(df.info())

</code></pre>

<pre><code class="language-text">&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
Int64Index: 3 entries, 0 to 2
Data columns (total 3 columns):
name        3 non-null object
age         3 non-null object
national    3 non-null object
dtypes: object(3)
memory usage: 96.0+ bytes
None
</code></pre>

<pre><code class="language-python">#显示头两行，默认头五行
print(df.head(2))

</code></pre>

<pre><code class="language-text">    name age national
0  James  18       us
1  Curry  20    China
</code></pre>

<pre><code class="language-python">#显示后几行
print(df.tail(2))

</code></pre>

<pre><code class="language-text">       name age national
1     Curry  20    China
2  Iversion  19       us
</code></pre>

<pre><code class="language-python">#获取DataFrame的列
print(df[&#39;name&#39;])
print(&#39;-&#39;*20)
#因为我们只获取一列，所以返回的就是一个 Series 
print(type(df[&#39;name&#39;]))
print(&#39;-&#39;*20)
# 如果获取多个列，那返回的就是一个 DataFrame 类型：
print(df[[&#39;name&#39;,&#39;age&#39;]])
print(type(df[[&#39;name&#39;,&#39;age&#39;]]))


</code></pre>

<pre><code class="language-text">0       James
1       Curry
2    Iversion
Name: name, dtype: object
--------------------
&lt;class &#39;pandas.core.series.Series&#39;&gt;
--------------------
       name age
0     James  18
1     Curry  20
2  Iversion  19
&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
</code></pre>

<pre><code class="language-python"># 获取一行
print(df[0:1])
print(&#39;-&#39;*20)
# 获取多行
print(df[1:3])
print(&#39;-&#39;*20)
# 取多行里面的某一列（不能进行多行多列的选择）
print(df[1:3][[&#39;name&#39;,&#39;age&#39;]])
# 注意： df[]只能进行行选择，或列选择，不能同时多行多列选择。



</code></pre>

<pre><code class="language-text">    name age national
0  James  18       us
--------------------
       name age national
1     Curry  20    China
2  Iversion  19       us
--------------------
       name age
1     Curry  20
2  Iversion  19
</code></pre>

<pre><code class="language-python">&#39;&#39;&#39;df.loc 通过标签索引行数据
df.iloc 通过位置获取行数据
&#39;&#39;&#39;
# 获取某一行某一列的数据
print(df.loc[0,&#39;name&#39;])
print(&#39;-&#39;*20)

# 一行所有列
print(df.loc[0,:])
print(&#39;-&#39;*20)

# 某一行多列的数据
print(df.loc[0,[&#39;name&#39;,&#39;age&#39;]])
print(&#39;-&#39;*20)

# 选择间隔的多行多列
print(df.loc[[0,2],[&#39;name&#39;,&#39;national&#39;]])
print(&#39;-&#39;*20)

# 选择连续的多行和间隔的多列
print(df.loc[0:2,[&#39;name&#39;,&#39;national&#39;]])
print(&#39;-&#39;*20)

# 取一行
print(df.iloc[1])
print(&#39;-&#39;*20)

# 取连续多行
print(df.iloc[0:2])
print(&#39;-&#39;*20)

# 取间断的多行
print(df.iloc[[0,2],:])
print(&#39;-&#39;*20)

# 取某一列
print(df.iloc[:,1])
print(&#39;-&#39;*20)

# 某一个值
print(df.iloc[1,0])

</code></pre>

<pre><code class="language-text">James
--------------------
name        James
age            18
national       us
Name: 0, dtype: object
--------------------
name    James
age        18
Name: 0, dtype: object
--------------------
       name national
0     James       us
2  Iversion       us
--------------------
       name national
0     James       us
1     Curry    China
2  Iversion       us
--------------------
name        Curry
age            20
national    China
Name: 1, dtype: object
--------------------
    name age national
0  James  18       us
1  Curry  20    China
--------------------
       name age national
0     James  18       us
2  Iversion  19       us
--------------------
0    18
1    20
2    19
Name: age, dtype: object
--------------------
Curry
</code></pre>

<pre><code class="language-python"># 修改值
df.iloc[0,0]=&#39;panda&#39; 
print(df)
print(&#39;-&#39;*40)
# dataframe中的排序方法
df = df.sort_values(by=&#39;age&#39;,ascending=False) 
# ascending=False： 降序排列，默认是升序
print(df)


</code></pre>

<pre><code class="language-text">       name age national
1     panda  20    China
2  Iversion  19       us
0     panda  18       us
----------------------------------------
       name age national
1     panda  20    China
2  Iversion  19       us
0     panda  18       us
</code></pre>

<h3 id="toc_12">dataframe修改index、columns</h3>

<pre><code class="language-python">df1=pd.DataFrame(np.arange(9).reshape(3,3),index=[&#39;bi&#39;,&#39;sh&#39;,&#39;oz&#39;],columns=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;])
print(df1)

</code></pre>

<pre><code class="language-text">    a  b  c
bi  0  1  2
sh  3  4  5
oz  6  7  8
</code></pre>

<pre><code class="language-python">#修改df1的index
df1.index=[&#39;beijing&#39;,&#39;shanghai&#39;,&#39;xiamen&#39;]
print(df1)

</code></pre>

<pre><code class="language-text">          a  b  c
beijing   0  1  2
shanghai  3  4  5
xiamen    6  7  8
</code></pre>

<pre><code class="language-python">#定义map函数（x是原有行列）
def test_map(x):
    return x+&#39;_ABC&#39;
print(df1.rename(index=test_map,columns=test_map))


</code></pre>

<pre><code class="language-text">              a_ABC  b_ABC  c_ABC
beijing_ABC       0      1      2
shanghai_ABC      3      4      5
xiamen_ABC        6      7      8
</code></pre>

<pre><code class="language-python"># 同时，renme可以传入字典，为某个index单独修改名称

df2=df1.rename(index={&#39;beijing&#39;:&#39;bi&#39;},columns={&#39;a&#39;:&#39;aa&#39;})
print(df2)

</code></pre>

<pre><code class="language-text">          aa  b  c
bi         0  1  2
shanghai   3  4  5
xiamen     6  7  8
</code></pre>

<pre><code class="language-python"># 列转化为索引
df3=pd.DataFrame({&#39;X&#39;:range(5),&#39;Y&#39;:range(5),&#39;S&#39;:[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;],&#39;Z&#39;:[1,1,2,2,2]}) 
print(df3)
print(&#39;-&#39;*30)

# 指定一列为索引 (drop=False 指定同时保留作为索引的列) 
result = df3.set_index(&#39;S&#39;,drop=False) 
result.index.name=None
print(result)


</code></pre>

<pre><code class="language-text">   X  Y  S  Z
0  0  0  a  1
1  1  1  b  1
2  2  2  c  2
3  3  3  d  2
4  4  4  e  2
------------------------------
   X  Y  S  Z
a  0  0  a  1
b  1  1  b  1
c  2  2  c  2
d  3  3  d  2
e  4  4  e  2
</code></pre>

<h3 id="toc_13">添加数据</h3>

<pre><code class="language-python"># 增加数据
df1 = pd.DataFrame([[&#39;Snow&#39;,&#39;M&#39;,22],[&#39;Tyrion&#39;,&#39;M&#39;,32],[&#39;Sansa&#39;,&#39;F&#39;,18],[&#39;Arya&#39;,&#39;F&#39;,14]], columns=[&#39;name&#39;,&#39;gender&#39;,&#39;age&#39;])
print(df1)

</code></pre>

<pre><code class="language-text">     name gender  age
0    Snow      M   22
1  Tyrion      M   32
2   Sansa      F   18
3    Arya      F   14
</code></pre>

<pre><code class="language-python">#在数据框最后加上score
df1[&#39;score&#39;]=[80,90,67,78]#与增加数据一样
print(df1)

</code></pre>

<pre><code class="language-text">     name gender  age  score
0    Snow      M   22     80
1  Tyrion      M   32     90
2   Sansa      F   18     67
3    Arya      F   14     78
</code></pre>

<p>在具体某个位置插入一列可以用<strong>insert</strong>的方法</p>

<ul>
<li>语法格式：列表.insert(index, obj)
<ul>
<li>index ---&gt;对象 obj 需要插入的索引位置。</li>
<li>obj ---&gt; 要插入列表中的对象（列名）</li>
</ul></li>
</ul>

<pre><code class="language-python">col_name=df1.columns.tolist()#将数据框中列明全部提取出存在列表里
col_name.insert(2,&#39;city&#39;) #在列索引为2的位置后面插入列名为city的列
#没有值，所有列为NaN
df1=df1.reindex(columns=col_name)# DataFrame.reindex() 对原行/列索引重新构建索引值
print(df1)

</code></pre>

<pre><code class="language-text">     name gender  city  age  score
0    Snow      M   NaN   22     80
1  Tyrion      M   NaN   32     90
2   Sansa      F   NaN   18     67
3    Arya      F   NaN   14     78
</code></pre>

<pre><code class="language-python">df1[&#39;city&#39;]=[&#39;北京&#39;,&#39;上海&#39;,&#39;广东&#39;,&#39;厦门&#39;]
print(df1)

</code></pre>

<pre><code class="language-text">     name gender city  age  score
0    Snow      M   北京   22     80
1  Tyrion      M   上海   32     90
2   Sansa      F   广东   18     67
3    Arya      F   厦门   14     78
</code></pre>

<h4 id="toc_14">df中的insert,插入一列</h4>

<p>df.insert(iloc,column,value)</p>

<ul>
<li>iloc:要插入的位置</li>
<li>colunm:列名</li>
<li>value:值</li>
</ul>

<pre><code class="language-python">df1.insert(2,&#39;score2&#39;,[79,43,67,89])
print(df1)

</code></pre>

<pre><code class="language-text">     name gender  score2 city  age  score
0    Snow      M      79   北京   22     80
1  Tyrion      M      43   上海   32     90
2   Sansa      F      67   广东   18     67
3    Arya      F      89   厦门   14     78
</code></pre>

<pre><code class="language-python"># 插入行
row=[&#39;Ryan&#39;,&#39;M&#39;,&#39;100&#39;,&#39;厦门&#39;,&#39;18&#39;,&#39;100&#39;]
df1.loc[3]=row
print(df1)

</code></pre>

<pre><code class="language-text">     name gender score2 city age score
0    Snow      M     79   北京  22    80
1  Tyrion      M     43   上海  32    90
2   Sansa      F     67   广东  18    67
3    Ryan      M    100   厦门  18   100
</code></pre>

<pre><code class="language-python"># 增加数据
df1 = pd.DataFrame([[&#39;Snow&#39;,&#39;M&#39;,22],
                    [&#39;Tyrion&#39;,&#39;M&#39;,32],
                    [&#39;Sansa&#39;,&#39;F&#39;,18],
                    [&#39;Arya&#39;,&#39;F&#39;,14]], 
                   columns=[&#39;name&#39;,&#39;gender&#39;,&#39;age&#39;])
print(df1)

# 先创建一个DataFrame，用来增加进数据框的最后一行
new=pd.DataFrame({&#39;name&#39;:&#39;lisa&#39;,
                  &#39;gender&#39;:&#39;F&#39;, &#39;age&#39;:19},
                 index=[0])
print(&#39;-&#39;*30)
print(new)
print(&#39;-&#39;*30)
df1=df1.append(new,ignore_index=True)   # ignore_index=False,表示不按原来的索引，从0开始自动递增
print(df1)


</code></pre>

<pre><code class="language-text">     name gender  age
0    Snow      M   22
1  Tyrion      M   32
2   Sansa      F   18
3    Arya      F   14
------------------------------
   name gender  age
0  lisa      F   19
------------------------------
     name gender  age
0    Snow      M   22
1  Tyrion      M   32
2   Sansa      F   18
3    Arya      F   14
4    lisa      F   19
</code></pre>

<h4 id="toc_15">插入多行多列</h4>

<ul>
<li>objs:合并对象</li>
<li>axis:合并方式，默认0表示按列合并，1表示按行合并</li>
<li>ignore_index:是否忽略索引</li>
</ul>

<pre><code class="language-python">df1 = pd.DataFrame(np.arange(6).reshape(3,2),columns=[&#39;four&#39;,&#39;five&#39;])
df2 = pd.DataFrame(np.arange(6).reshape(2,3),columns=[&#39;one&#39;,&#39;two&#39;,&#39;three&#39;]) 
print(df2)

print(&#39;-&#39;*30)

# 按行合并
result=pd.concat([df2,df1],axis=1)
print(result)

print(&#39;-&#39;*30)

# 按列合并
result=pd.concat([df2,df1],ignore_index=True,)
print(result)

</code></pre>

<pre><code class="language-text">   one  two  three
0    0    1      2
1    3    4      5
------------------------------
   one  two  three  four  five
0  0.0  1.0    2.0     0     1
1  3.0  4.0    5.0     2     3
2  NaN  NaN    NaN     4     5
------------------------------
   five  four  one  three  two
0   NaN   NaN  0.0    2.0  1.0
1   NaN   NaN  3.0    5.0  4.0
2   1.0   0.0  NaN    NaN  NaN
3   3.0   2.0  NaN    NaN  NaN
4   5.0   4.0  NaN    NaN  NaN



E:\anaconda\lib\site-packages\ipykernel_launcher.py:14: FutureWarning: Sorting because non-concatenation axis is not aligned. A future version
of pandas will change to not sort by default.

To accept the future behavior, pass &#39;sort=True&#39;.

To retain the current behavior and silence the warning, pass sort=False
</code></pre>

<p>​<br/><br/>
​    </p>

<h4 id="toc_16">DataFrame的删除</h4>

<ul>
<li>lables：要删除数据的标签</li>
<li>axis：0表示删除行，1表示删除列，默认0</li>
<li>inplace:是否在当前df中执行此操作</li>
</ul>

<pre><code class="language-python">df2 = pd.DataFrame(np.arange(9).reshape(3,3),columns=[&#39;one&#39;,&#39;two&#39;,&#39;three&#39;])
print(df2)
df4=df2.drop([&#39;one&#39;],axis=1, inplace=False) 
df3=df2.drop([0,1],axis=0, inplace=False) 

print(&#39;-&#39;*30)
print(df4)
print(&#39;-&#39;*30)
print(df3)


</code></pre>

<pre><code class="language-text">   one  two  three
0    0    1      2
1    3    4      5
2    6    7      8
------------------------------
   two  three
0    1      2
1    4      5
2    7      8
------------------------------
   one  two  three
2    6    7      8
</code></pre>

<h3 id="toc_17">数据处理</h3>

<h4 id="toc_18">通过<strong>dropna()</strong>滤除缺失数据：</h4>

<pre><code class="language-python">se=pd.Series([4,None,8,None,5]) 
print(se)
print(&#39;-&#39;*20)
print(se.dropna())
print(&#39;-&#39;*20)
print(se.notnull()) 
print(&#39;-&#39;*20)
print(se.isnull())


print(&#39;-&#39;*20)
# 通过布尔序列也能滤除：
print(se[se.notnull()])


</code></pre>

<pre><code class="language-text">0    4.0
1    NaN
2    8.0
3    NaN
4    5.0
dtype: float64
--------------------
0    4.0
2    8.0
4    5.0
dtype: float64
--------------------
0     True
1    False
2     True
3    False
4     True
dtype: bool
--------------------
0    False
1     True
2    False
3     True
4    False
dtype: bool
--------------------
0    4.0
2    8.0
4    5.0
dtype: float64
</code></pre>

<h4 id="toc_19">处理DataFrame对象</h4>

<pre><code class="language-python">df1=pd.DataFrame([[1,2,3],[None,None,2],[None,None,None],[8,8,None]])
print(df1)

print(&#39;-&#39;*20)
print(df1.dropna())
print(&#39;-&#39;*20)
# 传入how=‘all’滤除全为NaN的行：
print(df1.dropna(how=&#39;all&#39;)) # 默认情况下是how=&#39;any&#39;，只要有nan就删除

print(&#39;-&#39;*20)
# 传入axis=1滤除列：
print(df1.dropna(axis=1,how=&quot;any&quot;))

print(&#39;-&#39;*20)
#传入thresh=n保留至少有n个非NaN数据的行：  
print(df1.dropna(thresh=3))

</code></pre>

<pre><code class="language-text">     0    1    2
0  1.0  2.0  3.0
1  NaN  NaN  2.0
2  NaN  NaN  NaN
3  8.0  8.0  NaN
--------------------
     0    1    2
0  1.0  2.0  3.0
--------------------
     0    1    2
0  1.0  2.0  3.0
1  NaN  NaN  2.0
3  8.0  8.0  NaN
--------------------
Empty DataFrame
Columns: []
Index: [0, 1, 2, 3]
--------------------
     0    1    2
0  1.0  2.0  3.0
</code></pre>

<h4 id="toc_20">填充缺失数据</h4>

<pre><code class="language-python">df1=pd.DataFrame([[1,2,3],[None,None,2],[None,None,None],[8,8,None]])
print(df1)

</code></pre>

<pre><code class="language-text">     0    1    2
0  1.0  2.0  3.0
1  NaN  NaN  2.0
2  NaN  NaN  NaN
3  8.0  8.0  NaN
</code></pre>

<pre><code class="language-python"># 用常数填充fillna
print(df1.fillna(0))

</code></pre>

<pre><code class="language-text">     0    1    2
0  1.0  2.0  3.0
1  0.0  0.0  2.0
2  0.0  0.0  0.0
3  8.0  8.0  0.0
</code></pre>

<pre><code class="language-python">#传入inplace=True直接修改原对象： 
df1.fillna(0,inplace=True) 
print(df1)

</code></pre>

<pre><code class="language-text">     0    1    2
0  1.0  2.0  3.0
1  0.0  0.0  2.0
2  0.0  0.0  0.0
3  8.0  8.0  0.0
</code></pre>

<pre><code class="language-python">df1=pd.DataFrame([[1,2,3],[None,None,2],[None,None,None],[8,8,None]])
# 通过字典填充不同的常数
print(df1.fillna({0:10,1:20,2:30}))


</code></pre>

<pre><code class="language-text">      0     1     2
0   1.0   2.0   3.0
1  10.0  20.0   2.0
2  10.0  20.0  30.0
3   8.0   8.0  30.0
</code></pre>

<pre><code class="language-python">#填充平均值
print(df1.fillna(df1.mean()))
# 如果只填充一列
df1.iloc[:,1].fillna(5,inplace = True)
print(df1)

</code></pre>

<pre><code class="language-text">     0    1    2
0  1.0  2.0  3.0
1  4.5  5.0  2.0
2  4.5  5.0  2.5
3  8.0  8.0  2.5
     0    1    2
0  1.0  2.0  3.0
1  NaN  5.0  2.0
2  NaN  5.0  NaN
3  8.0  8.0  NaN
</code></pre>

<pre><code class="language-python"># 传 入 method=” “ 改 变 插 值 方 式 ： 
df2=pd.DataFrame(np.random.randint(0,10,(5,5))) 
df2.iloc[1:4,3]=None
df2.iloc[2:4,4]=None
print(df2)
print(&#39;-&#39;*20)

#用前面的值来填充ffill  用后面的值来填充bfill 
print(df2.fillna(method=&#39;ffill&#39;))

print(&#39;-&#39;*20)
# 传入limit=” “限制填充行数：
print(df2.fillna(method=&#39;bfill&#39;,limit=2))
print(&#39;-&#39;*20)
# 传入axis=” “修改填充方向：
print(df2.fillna(method=&quot;ffill&quot;,limit=1,axis=1))


</code></pre>

<pre><code class="language-text">   0  1  2    3    4
0  7  6  9  4.0  4.0
1  8  1  7  NaN  5.0
2  2  7  0  NaN  NaN
3  7  3  2  NaN  NaN
4  1  0  7  7.0  4.0
--------------------
   0  1  2    3    4
0  7  6  9  4.0  4.0
1  8  1  7  4.0  5.0
2  2  7  0  4.0  5.0
3  7  3  2  4.0  5.0
4  1  0  7  7.0  4.0
--------------------
   0  1  2    3    4
0  7  6  9  4.0  4.0
1  8  1  7  NaN  5.0
2  2  7  0  7.0  4.0
3  7  3  2  7.0  4.0
4  1  0  7  7.0  4.0
--------------------
     0    1    2    3    4
0  7.0  6.0  9.0  4.0  4.0
1  8.0  1.0  7.0  7.0  5.0
2  2.0  7.0  0.0  0.0  NaN
3  7.0  3.0  2.0  2.0  NaN
4  1.0  0.0  7.0  7.0  4.0
</code></pre>

<h4 id="toc_21">移除重复数据</h4>

<p>DataFrame中经常会出现重复行，利用duplicated()函数返回每一行判断是否重复的结果（重复则为True) </p>

<pre><code class="language-python">df1=pd.DataFrame({&#39;A&#39;:[1,1,1,2,2,3,1],&#39;B&#39;:list(&quot;aabbbca&quot;)}) 
print(df1)
print(&#39;-&#39;*30)
# 判断每一行是否重复(结果是bool值，TRUE代表重复的) 
print(df1.duplicated())

print(&#39;-&#39;*30)
# 去除全部的重复行
print(df1.drop_duplicates())

print(&#39;-&#39;*30)
#  指定列去除重复行
print(df1.drop_duplicates([&#39;A&#39;]))


print(&#39;-&#39;*30)
# 保留重复行中的最后一行
print(df1.drop_duplicates([&#39;A&#39;],keep=&#39;last&#39;))

print(&#39;-&#39;*30)
#去除重复的同时改变DataFrame对象
df1.drop_duplicates([&#39;A&#39;,&#39;B&#39;],inplace=True) 
print(df1)

</code></pre>

<pre><code class="language-text">   A  B
0  1  a
1  1  a
2  1  b
3  2  b
4  2  b
5  3  c
6  1  a
------------------------------
0    False
1     True
2    False
3    False
4     True
5    False
6     True
dtype: bool
------------------------------
   A  B
0  1  a
2  1  b
3  2  b
5  3  c
------------------------------
   A  B
0  1  a
3  2  b
5  3  c
------------------------------
   A  B
4  2  b
5  3  c
6  1  a
------------------------------
   A  B
0  1  a
2  1  b
3  2  b
5  3  c
</code></pre>

<h3 id="toc_22">数据合并</h3>

<h4 id="toc_23">join合并</h4>

<p>着重关注行的合并</p>

<pre><code class="language-python">import pandas as pd
df3=pd.DataFrame({&#39;Red&#39;:[1,3,5],&#39;Green&#39;:[5,0,3]},index=list(&#39;abc&#39;))
df4=pd.DataFrame({&#39;Blue&#39;:[1,9,8],&#39;Yellow&#39;:[6,6,7]},index=list(&#39;cde&#39;)) 
print(df3)
print(&#39;-&#39;*30)
print(df4)

# 简单合并（默认是left左连接,以左侧df3为基础）
df3.join(df4,how=&#39;left&#39;)
print(&#39;-&#39;*30)
print(df3)

# 右链接
df3.join(df4,how=&#39;right&#39;)

# 外链接
df3.join(df4,how=&#39;outer&#39;)



</code></pre>

<pre><code class="language-text">   Red  Green
a    1      5
b    3      0
c    5      3
------------------------------
   Blue  Yellow
c     1       6
d     9       6
e     8       7
------------------------------
   Red  Green
a    1      5
b    3      0
c    5      3
</code></pre>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code class="language-text">.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre>
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Red</th>
      <th>Green</th>
      <th>Blue</th>
      <th>Yellow</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>1.0</td>
      <td>5.0</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>b</th>
      <td>3.0</td>
      <td>0.0</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>c</th>
      <td>5.0</td>
      <td>3.0</td>
      <td>1.0</td>
      <td>6.0</td>
    </tr>
    <tr>
      <th>d</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>9.0</td>
      <td>6.0</td>
    </tr>
    <tr>
      <th>e</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>8.0</td>
      <td>7.0</td>
    </tr>
  </tbody>
</table>
</div>

<pre><code class="language-python"># 合并多个DataFrame对象
df5=pd.DataFrame({&#39;Brown&#39;:[3,4,5],&#39;White&#39;:[1,1,2]},index=list(&#39;aed&#39;)) 

df3.join([df4,df5])


</code></pre>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code class="language-text">.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre>
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Red</th>
      <th>Green</th>
      <th>Blue</th>
      <th>Yellow</th>
      <th>Brown</th>
      <th>White</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>1</td>
      <td>5</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>3.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>b</th>
      <td>3</td>
      <td>0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>c</th>
      <td>5</td>
      <td>3</td>
      <td>1.0</td>
      <td>6.0</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>

<h4 id="toc_24">merge合并</h4>

<p>着重关注的是列的合并</p>

<pre><code class="language-python">df1=pd.DataFrame({&#39;名字&#39;:list(&#39;ABCDE&#39;),&#39;性别&#39;:[&#39;男&#39;,&#39;女&#39;,&#39;男&#39;,&#39;男&#39;,&#39;女&#39;],&#39;职称&#39;:[&#39;副教授&#39;,&#39;讲     师&#39;,&#39;助教&#39;,&#39;教授&#39;,&#39;助教&#39;]},
                 index=range(1001,1006))
df1.columns.name=&#39;学院老师&#39;
df1.index.name=&#39;编号&#39;
print(df1)

print(&#39;-&#39;*20)
df2=pd.DataFrame({&#39;名字&#39;:list(&#39;ABDAX&#39;),&#39;课程&#39;:[&#39;C++&#39;,&#39;计算机导论&#39;,&#39;汇编&#39;,&#39;数据结构&#39;,&#39;马克思原理&#39;],&#39;职称&#39;:[&#39;副教授&#39;,&#39;讲师&#39;,&#39;教授&#39;,&#39;副教授&#39;,&#39;讲师&#39;]},index=[1001,1002,1004,1001,3001])
df2.columns.name=&#39;课程&#39;
df2.index.name=&#39;编号&#39;
print(df2)

</code></pre>

<pre><code class="language-text">学院老师 名字 性别       职称
编号                 
1001  A  男      副教授
1002  B  女  讲     师
1003  C  男       助教
1004  D  男       教授
1005  E  女       助教
--------------------
课程   名字     课程   职称
编号                 
1001  A    C++  副教授
1002  B  计算机导论   讲师
1004  D     汇编   教授
1001  A   数据结构  副教授
3001  X  马克思原理   讲师
</code></pre>

<pre><code class="language-python"># 默认下是根据左右对象中出现同名的列作为连接的键，且连接方式是how=’inner’ 
print(pd.merge(df1,df2))# 返回匹配的

# 指定列名合并
pd.merge(df1,df2,on=&#39;名字&#39;,suffixes=[&#39;_1&#39;,&#39;_2&#39;])# 返回匹配的

# 连接方式，根据左侧为准
pd.merge(df1,df2,how=&#39;left&#39;)

# 根据左侧为准
pd.merge(df1,df2,how=&#39;right&#39;)

# 所 有
# pd.merge(df1,df2,how=&#39;outer&#39;)

# 根据多个键进行连接
pd.merge(df1,df2,on=[&#39;职称&#39;,&#39;名字&#39;])


</code></pre>

<pre><code class="language-text">  名字 性别   职称    课程
0  A  男  副教授   C++
1  A  男  副教授  数据结构
2  D  男   教授    汇编
</code></pre>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code class="language-text">.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre>
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>名字</th>
      <th>性别</th>
      <th>职称</th>
      <th>课程</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>A</td>
      <td>男</td>
      <td>副教授</td>
      <td>C++</td>
    </tr>
    <tr>
      <th>1</th>
      <td>A</td>
      <td>男</td>
      <td>副教授</td>
      <td>数据结构</td>
    </tr>
    <tr>
      <th>2</th>
      <td>D</td>
      <td>男</td>
      <td>教授</td>
      <td>汇编</td>
    </tr>
  </tbody>
</table>
</div>

<h3 id="toc_25">拓展——轴向连接（Concat）</h3>

<ol>
<li> Series对象的连接</li>
</ol>

<pre><code class="language-python">s1=pd.Series([1,2],index=list(&#39;ab&#39;))
s2=pd.Series([3,4,5],index=list(&#39;bde&#39;)) 
print(s1)
print(s2)
print(pd.concat([s1,s2]))

#横向连接
print(pd.concat([s1,s2],axis=1))

# 用内连接求交集(连接方式，共有’inner’,’left’,right’,’outer’) 
pd.concat([s1,s2],axis=1,join=&#39;inner&#39;)

# 指定部分索引进行连接
pd.concat([s1,s2],axis=1,join_axes=[list(&#39;abc&#39;)])

# 创建层次化索引
pd.concat([s1,s2],keys=[&#39;A&#39;,&#39;B&#39;])

#当纵向连接时keys为列名
pd.concat([s1,s2],keys=[&#39;A&#39;,&#39;D&#39;],axis=1)


</code></pre>

<pre><code class="language-text">a    1
b    2
dtype: int64
b    3
d    4
e    5
dtype: int64
a    1
b    2
b    3
d    4
e    5
dtype: int64
     0    1
a  1.0  NaN
b  2.0  3.0
d  NaN  4.0
e  NaN  5.0



E:\anaconda\lib\site-packages\ipykernel_launcher.py:8: FutureWarning: Sorting because non-concatenation axis is not aligned. A future version
of pandas will change to not sort by default.

To accept the future behavior, pass &#39;sort=True&#39;.

To retain the current behavior and silence the warning, pass sort=False
</code></pre>

<p>​<br/><br/>
​    E:\anaconda\lib\site-packages\ipykernel_launcher.py:20: FutureWarning: Sorting because non-concatenation axis is not aligned. A future version<br/>
​    of pandas will change to not sort by default.<br/>
​<br/><br/>
​    To accept the future behavior, pass &#39;sort=True&#39;.<br/>
​    </p>

<pre><code class="language-text">To retain the current behavior and silence the warning, pass sort=False
</code></pre>

<p>​    </p>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code class="language-text">.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre>
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>D</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>1.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>b</th>
      <td>2.0</td>
      <td>3.0</td>
    </tr>
    <tr>
      <th>d</th>
      <td>NaN</td>
      <td>4.0</td>
    </tr>
    <tr>
      <th>e</th>
      <td>NaN</td>
      <td>5.0</td>
    </tr>
  </tbody>
</table>
</div>

<ol>
<li>DataFrame对象的连接</li>
</ol>

<pre><code class="language-python">df3=pd.DataFrame({&#39;Red&#39;:[1,3,5],&#39;Green&#39;:[5,0,3]},index=list(&#39;abd&#39;))
df4=pd.DataFrame({&#39;Blue&#39;:[1,9],&#39;Yellow&#39;:[6,6]},index=list(&#39;ce&#39;)) 
print(df3)
print(df4)
pd.concat([df3,df4]) 
pd.concat([df3,df4],axis=1,keys=[&#39;A&#39;,&#39;B&#39;])

# 用字典的方式连接同样可以创建层次化列索引
pd.concat({&#39;A&#39;:df3,&#39;B&#39;:df4},axis=1)


</code></pre>

<pre><code class="language-text">   Red  Green
a    1      5
b    3      0
d    5      3
   Blue  Yellow
c     1       6
e     9       6



E:\anaconda\lib\site-packages\ipykernel_launcher.py:5: FutureWarning: Sorting because non-concatenation axis is not aligned. A future version
of pandas will change to not sort by default.

To accept the future behavior, pass &#39;sort=True&#39;.

To retain the current behavior and silence the warning, pass sort=False

  &quot;&quot;&quot;
E:\anaconda\lib\site-packages\ipykernel_launcher.py:6: FutureWarning: Sorting because non-concatenation axis is not aligned. A future version
of pandas will change to not sort by default.

To accept the future behavior, pass &#39;sort=True&#39;.

To retain the current behavior and silence the warning, pass sort=False
</code></pre>

<p>​<br/><br/>
​    E:\anaconda\lib\site-packages\ipykernel_launcher.py:9: FutureWarning: Sorting because non-concatenation axis is not aligned. A future version<br/>
​    of pandas will change to not sort by default.<br/>
​<br/><br/>
​    To accept the future behavior, pass &#39;sort=True&#39;.<br/>
​    </p>

<pre><code class="language-text">To retain the current behavior and silence the warning, pass sort=False

  if __name__ == &#39;__main__&#39;:
</code></pre>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code class="language-text">.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead tr th {
    text-align: left;
}
</code></pre>
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th colspan="2" halign="left">A</th>
      <th colspan="2" halign="left">B</th>
    </tr>
    <tr>
      <th></th>
      <th>Red</th>
      <th>Green</th>
      <th>Blue</th>
      <th>Yellow</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>1.0</td>
      <td>5.0</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>b</th>
      <td>3.0</td>
      <td>0.0</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>c</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>1.0</td>
      <td>6.0</td>
    </tr>
    <tr>
      <th>d</th>
      <td>5.0</td>
      <td>3.0</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>e</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>9.0</td>
      <td>6.0</td>
    </tr>
  </tbody>
</table>
</div>

<h3 id="toc_26">多层索引（拓展）</h3>

<h4 id="toc_27">创建多层索引</h4>

<pre><code class="language-python">import numpy as np 
import pandas as pd
from pandas import Series,DataFrame

# Series也可以创建多层索引
s = Series(np.random.randint(0,150,size=6),index=list(&#39;abcdef&#39;)) 
print(s)
print(&#39;-&#39;*20)
s = Series(np.random.randint(0,150,size=6),
           index=[[&#39;a&#39;,&#39;a&#39;,&#39;b&#39;,&#39;b&#39;,&#39;c&#39;,&#39;c&#39;],[&#39;期中&#39;,&#39;期末&#39;,&#39;期中&#39;,&#39;期末&#39;,&#39;期中&#39;,&#39;期末&#39;]])  
print(s)

</code></pre>

<pre><code class="language-text">a    146
b    137
c     39
d     16
e    142
f    142
dtype: int32
--------------------
a  期中     43
   期末     53
b  期中     71
   期末    114
c  期中    149
   期末     13
dtype: int32
</code></pre>

<pre><code class="language-python">#DataFrame创建多层索引
df1 = DataFrame(np.random.randint(0,150,size=(6,4)),columns = [&#39;zs&#39;,&#39;ls&#39;,&#39;ww&#39;,&#39;zl&#39;],
                index = [[&#39;python&#39;,&#39;python&#39;,&#39;math&#39;,&#39;math&#39;,&#39;En&#39;,&#39;En&#39;],[&#39;期中&#39;,&#39;期末&#39;,&#39;期中&#39;,&#39;期末&#39;,&#39;期中&#39;,&#39;期末&#39;]])

print(df1)


</code></pre>

<pre><code class="language-text">            zs   ls   ww   zl
python 期中    7  131  141   55
       期末   77   52   85   69
math   期中  139  118   80    3
       期末   23    5   14   27
En     期中  142   47   28  136
       期末   19   95   33   55
</code></pre>

<h5 id="toc_28">特定结构</h5>

<pre><code class="language-python">class1=[&#39;python&#39;,&#39;python&#39;,&#39;math&#39;,&#39;math&#39;,&#39;En&#39;,&#39;En&#39;]
class2=[&#39;期中&#39;,&#39;期末&#39;,&#39;期中&#39;,&#39;期末&#39;,&#39;期中&#39;,&#39;期末&#39;]
m_index2=pd.MultiIndex.from_arrays([class1,class2])
df2=DataFrame(np.random.randint(0,150,(6,4)),index=m_index2) 
print(df2)

print(&#39;-&#39;*20)

class1=[&#39;期中&#39;,&#39;期中&#39;,&#39;期中&#39;,&#39;期末&#39;,&#39;期末&#39;,&#39;期末&#39;]
class2=[&#39;python&#39;,&#39;math&#39;,&#39;En&#39;,&#39;python&#39;,&#39;math&#39;,&#39;En&#39;] 
m_index2=pd.MultiIndex.from_arrays([class1,class2])
df2=DataFrame(np.random.randint(0,150,(6,4)),index=m_index2) 
print(df2)


</code></pre>

<pre><code class="language-text">             0    1    2    3
python 期中   13   13  108   94
       期末  117  130   87   74
math   期中   35  111   80   94
       期末  144   94  111    0
En     期中  135   80   87   90
       期末  108   63  119  118
--------------------
             0    1    2    3
期中 python   22   36   66   41
   math    142    5  139   73
   En       62  130  120  140
期末 python  144    5   60  128
   math     18   41   14   37
   En       74   62   10   83
</code></pre>

<h5 id="toc_29">product构造</h5>

<pre><code class="language-python">class1=[&#39;python&#39;,&#39;math&#39;,&#39;En&#39;]
class2=[&#39;期中&#39;,&#39;期末&#39;]
m_index2=pd.MultiIndex.from_product([class1,class2]) 
df2=DataFrame(np.random.randint(0,150,(6,4)),index=m_index2) 
print(df2)


</code></pre>

<pre><code class="language-text">             0    1    2    3
python 期中   23   98  144  114
       期末  122   80  115   13
math   期中   79   80   43   65
       期末   99  132  103    2
En     期中    1   81   27   72
       期末   50  113   28  116
</code></pre>

<h4 id="toc_30">多层索引对象的索引</h4>

<pre><code class="language-python">#多层索引对象的索引操作# series
s = Series(np.random.randint(0,150,size=6),index=[[&#39;a&#39;,&#39;a&#39;,&#39;b&#39;,&#39;b&#39;,&#39;c&#39;,&#39;c&#39;],[&#39;期中&#39;,&#39;期末&#39;,&#39;期中&#39;,&#39;期末&#39;,&#39;期中&#39;,&#39;期末&#39;]])  # print(s)
#取一个第一级索引
print(s[&#39;a&#39;])

# 取多个第一级索引
print(s[[&#39;a&#39;,&#39;b&#39;]])

# 根据索引获取值
print(s[&#39;a&#39;,&#39;期末&#39;])

# loc方法取值
print(s.loc[&#39;a&#39;])
print(s.loc[[&#39;a&#39;,&#39;b&#39;]])
print(s.loc[&#39;a&#39;,&#39;期末&#39;])

# iloc方法取值(iloc计算的事最内层索引)  
print(s.iloc[1])


print(s.iloc[1:4])

# dataframe 
class1=[&#39;python&#39;,&#39;math&#39;,&#39;En&#39;]
class2=[&#39; 期 中 &#39;,&#39; 期 末 &#39;] 
m_index2=pd.MultiIndex.from_product([class1,class2]) 
df2=DataFrame(np.random.randint(0,150,(6,4)),index=m_index2) 
print(df2)

# 获取列
print(df2[0])

# 一级索引
print(df2.loc[&#39;python&#39;])

# 多个一级索引
print(df2.loc[[&#39;python&#39;,&#39;math&#39;]])

# 取一行
# print(df2.loc[&#39;python&#39;,&#39;期末&#39;])

# 取一值
# print(df2.loc[&#39;python&#39;,&#39;期末&#39;][0])

# iloc是只取最内层的索引的
print(df2.iloc[0])

</code></pre>

<pre><code class="language-text">期中    110
期末    123
dtype: int32
a  期中    110
   期末    123
b  期中     93
   期末      2
dtype: int32
123
期中    110
期末    123
dtype: int32
a  期中    110
   期末    123
b  期中     93
   期末      2
dtype: int32
123
123
a  期末    123
b  期中     93
   期末      2
dtype: int32
                0    1    2    3
python  期 中   123   28  120   69
        期 末     4  146   50   32
math    期 中   142   65   56   81
        期 末    74   59   17   80
En      期 中   133   17   89  113
        期 末    18   35   60  106
python   期 中     123
         期 末       4
math     期 中     142
         期 末      74
En       期 中     133
         期 末      18
Name: 0, dtype: int32
         0    1    2   3
 期 中   123   28  120  69
 期 末     4  146   50  32
                0    1    2   3
python  期 中   123   28  120  69
        期 末     4  146   50  32
math    期 中   142   65   56  81
        期 末    74   59   17  80
0    123
1     28
2    120
3     69
Name: (python,  期 中 ), dtype: int32
</code></pre>

<h2 id="toc_31">Timestamp</h2>

<h3 id="toc_32">时间模块datetime</h3>

<h4 id="toc_33">datetime.date (date对象)</h4>

<pre><code class="language-python">import datetime
# 或者from datetime import date
today=datetime.date.today()#今天的时间
print(today,type(today))
print(str(today),type(str(today)))
#输出date类的格式

print(&#39;-&#39;*30)
t=datetime.date(1997,10,26)
print(t)
#（年，月，日）

</code></pre>

<pre><code class="language-text">2019-11-29 &lt;class &#39;datetime.date&#39;&gt;
2019-11-29 &lt;class &#39;str&#39;&gt;
------------------------------
1997-10-26
</code></pre>

<h4 id="toc_34">datetime.date(datetime对象)</h4>

<pre><code class="language-python">now=datetime.datetime.now()
print(now,type(now))
print(str(now),type(str(now))) 

t1 = datetime.datetime(2016,6,1)
t2 = datetime.datetime(2014,1,1,12,44,33)
print(t1,t2)
# (年，月，日，时，分，秒)，至少输入年月日

t2-t1
# 相减得到时间差 —— timedelta

</code></pre>

<pre><code class="language-text">2019-11-29 14:47:16.940429 &lt;class &#39;datetime.datetime&#39;&gt;
2019-11-29 14:47:16.940429 &lt;class &#39;str&#39;&gt;
2016-06-01 00:00:00 2014-01-01 12:44:33






datetime.timedelta(-882, 45873)
</code></pre>

<h4 id="toc_35">datetime.timedelta(时间差)</h4>

<pre><code class="language-python">today = datetime.datetime.today()  # datetime.datetime也有today()方法
yestoday = today - datetime.timedelta(1)  # 
print(today)
print(yestoday)
print(today - datetime.timedelta(7))
# 时间差主要用作时间的加减法，相当于可被识别的时间“差值”

</code></pre>

<pre><code class="language-text">2019-11-29 14:48:03.943359
2019-11-28 14:48:03.943359
2019-11-22 14:48:03.943359
</code></pre>

<h4 id="toc_36">parser.parse(日期字符串转换)</h4>

<pre><code class="language-python">from dateutil.parser import parse

date = &#39;12-21-2017&#39;
t = parse(date)
print(t,type(t))
# 直接将str转化成datetime.datetime

print(parse(&#39;2000-1-1&#39;),&#39;\n&#39;,
     parse(&#39;5/1/2014&#39;),&#39;\n&#39;,
     parse(&#39;5/1/2014&#39;, dayfirst = True),&#39;\n&#39;,  # 国际通用格式中，日在月之前，可以通过dayfirst来设置
     parse(&#39;22/1/2014&#39;),&#39;\n&#39;,
     parse(&#39;Jan 31, 1997 10:45 PM&#39;))
# 各种格式可以解析，但无法支持中文

</code></pre>

<pre><code class="language-text">2017-12-21 00:00:00 &lt;class &#39;datetime.datetime&#39;&gt;
2000-01-01 00:00:00 
 2014-05-01 00:00:00 
 2014-01-05 00:00:00 
 2014-01-22 00:00:00 
 1997-01-31 22:45:00
</code></pre>

<h3 id="toc_37">Timestamp(Pandas时刻数据)</h3>

<p>时刻数据代表时间点，是pandas的数据类型，是将值与时间点相关联的最基本类型的时间序列数据。<strong>pandas.Timestamp()</strong></p>

<h4 id="toc_38">pd.Timestamp()</h4>

<pre><code class="language-python">import numpy as np
import pandas as pd

date1 = datetime.datetime(2016,12,1,12,45,30)  # 创建一个datetime.datetime
date2 = &#39;2017-12-21&#39;  # 创建一个字符串
t1 = pd.Timestamp(date1)
t2 = pd.Timestamp(date2)
print(t1,type(t1))
print(t2)
print(pd.Timestamp(&#39;2017-12-21 15:00:22&#39;))
# 直接生成pandas的时刻数据 → 时间戳
# 数据类型为 pandas的Timestamp

</code></pre>

<pre><code class="language-text">2016-12-01 12:45:30 &lt;class &#39;pandas._libs.tslibs.timestamps.Timestamp&#39;&gt;
2017-12-21 00:00:00
2017-12-21 15:00:22
</code></pre>

<h4 id="toc_39">pd.to_datetime（转化为时间戳）</h4>

<pre><code class="language-python">from datetime import datetime

date1 = datetime(2016,12,1,12,45,30)
date2 = &#39;2017-12-21&#39;
t1 = pd.to_datetime(date1)
t2 = pd.to_datetime(date2)
print(t1,type(t1))
print(t2,type(t2))
# pd.to_datetime()：如果是单个时间数据，转换成pandas的时刻数据，数据类型为Timestamp

lst_date = [ &#39;2017-12-21&#39;, &#39;2017-12-22&#39;, &#39;2017-12-23&#39;]
t3 = pd.to_datetime(lst_date)
print(t3,type(t3))
# 多个时间数据，将会转换为pandas的DatetimeIndex

</code></pre>

<pre><code class="language-text">2016-12-01 12:45:30 &lt;class &#39;pandas._libs.tslibs.timestamps.Timestamp&#39;&gt;
2017-12-21 00:00:00 &lt;class &#39;pandas._libs.tslibs.timestamps.Timestamp&#39;&gt;
DatetimeIndex([&#39;2017-12-21&#39;, &#39;2017-12-22&#39;, &#39;2017-12-23&#39;], dtype=&#39;datetime64[ns]&#39;, freq=None) &lt;class &#39;pandas.core.indexes.datetimes.DatetimeIndex&#39;&gt;
</code></pre>

<ul>
<li>多个时间数据转换时间戳索引</li>
</ul>

<pre><code class="language-python">date1 = [datetime(2015,6,1),datetime(2015,7,1),datetime(2015,8,1),datetime(2015,9,1),datetime(2015,10,1)]
date2 = [&#39;2017-2-1&#39;,&#39;2017-2-2&#39;,&#39;2017-2-3&#39;,&#39;2017-2-4&#39;,&#39;2017-2-5&#39;,&#39;2017-2-6&#39;]
print(date1)
print(date2)
t1 = pd.to_datetime(date2)
t2 = pd.to_datetime(date2)
print(t1)
print(t2)
# 多个时间数据转换为 DatetimeIndex

date3 = [&#39;2017-2-1&#39;,&#39;2017-2-2&#39;,&#39;2017-2-3&#39;,&#39;hello world!&#39;,&#39;2017-2-5&#39;,&#39;2017-2-6&#39;]
t3 = pd.to_datetime(date3, errors = &#39;ignore&#39;)
print(t3,type(t3))
# 当一组时间序列中夹杂其他格式数据，可用errors参数返回
# errors = &#39;ignore&#39;:不可解析时返回原始输入，这里就是直接生成一般数组

t4 = pd.to_datetime(date3, errors = &#39;coerce&#39;)
print(t4,type(t4))
# errors = &#39;coerce&#39;:不可扩展，缺失值返回NaT（Not a Time），结果认为DatetimeIndex

</code></pre>

<pre><code class="language-text">[datetime.datetime(2015, 6, 1, 0, 0), datetime.datetime(2015, 7, 1, 0, 0), datetime.datetime(2015, 8, 1, 0, 0), datetime.datetime(2015, 9, 1, 0, 0), datetime.datetime(2015, 10, 1, 0, 0)]
[&#39;2017-2-1&#39;, &#39;2017-2-2&#39;, &#39;2017-2-3&#39;, &#39;2017-2-4&#39;, &#39;2017-2-5&#39;, &#39;2017-2-6&#39;]
DatetimeIndex([&#39;2017-02-01&#39;, &#39;2017-02-02&#39;, &#39;2017-02-03&#39;, &#39;2017-02-04&#39;,
               &#39;2017-02-05&#39;, &#39;2017-02-06&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=None)
DatetimeIndex([&#39;2017-02-01&#39;, &#39;2017-02-02&#39;, &#39;2017-02-03&#39;, &#39;2017-02-04&#39;,
               &#39;2017-02-05&#39;, &#39;2017-02-06&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=None)
[&#39;2017-2-1&#39; &#39;2017-2-2&#39; &#39;2017-2-3&#39; &#39;hello world!&#39; &#39;2017-2-5&#39; &#39;2017-2-6&#39;] &lt;class &#39;numpy.ndarray&#39;&gt;
DatetimeIndex([&#39;2017-02-01&#39;, &#39;2017-02-02&#39;, &#39;2017-02-03&#39;, &#39;NaT&#39;, &#39;2017-02-05&#39;,
               &#39;2017-02-06&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=None) &lt;class &#39;pandas.core.indexes.datetimes.DatetimeIndex&#39;&gt;
</code></pre>

<h3 id="toc_40">DatetimeIndex(Pandas时间戳索引)</h3>

<h4 id="toc_41">pd.DatetimeIndex()与TimeSeries时间序列</h4>

<pre><code class="language-python">rng = pd.DatetimeIndex([&#39;12/1/2017&#39;,&#39;12/2/2017&#39;,&#39;12/3/2017&#39;,&#39;12/4/2017&#39;,&#39;12/5/2017&#39;])
print(rng,type(rng))
print(rng[0],type(rng[0]))
# 直接生成时间戳索引，支持str、datetime.datetime
# 单个时间戳为Timestamp，多个时间戳为DatetimeIndex

st = pd.Series(np.random.rand(len(rng)), index = rng)
print(st,type(st))
print(st.index)
# 以DatetimeIndex为index的Series，为TimeSries，时间序列

</code></pre>

<pre><code class="language-text">DatetimeIndex([&#39;2017-12-01&#39;, &#39;2017-12-02&#39;, &#39;2017-12-03&#39;, &#39;2017-12-04&#39;,
               &#39;2017-12-05&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=None) &lt;class &#39;pandas.core.indexes.datetimes.DatetimeIndex&#39;&gt;
2017-12-01 00:00:00 &lt;class &#39;pandas._libs.tslibs.timestamps.Timestamp&#39;&gt;
2017-12-01    0.322258
2017-12-02    0.677879
2017-12-03    0.142017
2017-12-04    0.366208
2017-12-05    0.139923
dtype: float64 &lt;class &#39;pandas.core.series.Series&#39;&gt;
DatetimeIndex([&#39;2017-12-01&#39;, &#39;2017-12-02&#39;, &#39;2017-12-03&#39;, &#39;2017-12-04&#39;,
               &#39;2017-12-05&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=None)
</code></pre>

<h4 id="toc_42">pd.date_range()-日期范围</h4>

<p>生成日期范围</p>

<p>生成方法：</p>

<ul>
<li>start+end</li>
<li>star/end+periods</li>
</ul>

<p>默认频率：day</p>

<pre><code class="language-python">rng1 = pd.date_range(&#39;1/1/2017&#39;,&#39;1/10/2017&#39;, normalize=True)
rng2 = pd.date_range(start = &#39;1/1/2017&#39;, periods = 10)
rng3 = pd.date_range(end = &#39;1/30/2017 15:00:00&#39;, periods = 10)  # 增加了时、分、秒
print(rng1,type(rng1))
print(rng2)
print(rng3)
print(&#39;-------&#39;)
# 直接生成DatetimeIndex
# pd.date_range(start=None, end=None, periods=None, freq=&#39;D&#39;, tz=None, normalize=False, name=None, closed=None, **kwargs)
# start：开始时间
# end：结束时间
# periods：偏移量
# freq：频率，默认天，pd.date_range()默认频率为日历日，pd.bdate_range()默认频率为工作日
# tz：时区

rng4 = pd.date_range(start = &#39;1/1/2017 15:30&#39;, periods = 10, name = &#39;hello world!&#39;, normalize = True)
print(rng4)
print(&#39;-------&#39;)
# normalize：时间参数值正则化到午夜时间戳（这里最后就直接变成0:00:00，并不是15:30:00）
# name：索引对象名称

print(pd.date_range(&#39;20170101&#39;,&#39;20170104&#39;))  # 20170101也可读取
print(pd.date_range(&#39;20170101&#39;,&#39;20170104&#39;,closed = &#39;right&#39;))
print(pd.date_range(&#39;20170101&#39;,&#39;20170104&#39;,closed = &#39;left&#39;))
print(&#39;-------&#39;)
# closed：默认为None的情况下，左闭右闭，left则左闭右开，right则左开右闭

print(pd.bdate_range(&#39;20170101&#39;,&#39;20170107&#39;))
# pd.bdate_range()默认频率为工作日

print(list(pd.date_range(start = &#39;1/1/2017&#39;, periods = 10)))
# 直接转化为list，元素为Timestamp

</code></pre>

<pre><code class="language-text">DatetimeIndex([&#39;2017-01-01&#39;, &#39;2017-01-02&#39;, &#39;2017-01-03&#39;, &#39;2017-01-04&#39;,
               &#39;2017-01-05&#39;, &#39;2017-01-06&#39;, &#39;2017-01-07&#39;, &#39;2017-01-08&#39;,
               &#39;2017-01-09&#39;, &#39;2017-01-10&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;) &lt;class &#39;pandas.core.indexes.datetimes.DatetimeIndex&#39;&gt;
DatetimeIndex([&#39;2017-01-01&#39;, &#39;2017-01-02&#39;, &#39;2017-01-03&#39;, &#39;2017-01-04&#39;,
               &#39;2017-01-05&#39;, &#39;2017-01-06&#39;, &#39;2017-01-07&#39;, &#39;2017-01-08&#39;,
               &#39;2017-01-09&#39;, &#39;2017-01-10&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)
DatetimeIndex([&#39;2017-01-21 15:00:00&#39;, &#39;2017-01-22 15:00:00&#39;,
               &#39;2017-01-23 15:00:00&#39;, &#39;2017-01-24 15:00:00&#39;,
               &#39;2017-01-25 15:00:00&#39;, &#39;2017-01-26 15:00:00&#39;,
               &#39;2017-01-27 15:00:00&#39;, &#39;2017-01-28 15:00:00&#39;,
               &#39;2017-01-29 15:00:00&#39;, &#39;2017-01-30 15:00:00&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)
-------
DatetimeIndex([&#39;2017-01-01&#39;, &#39;2017-01-02&#39;, &#39;2017-01-03&#39;, &#39;2017-01-04&#39;,
               &#39;2017-01-05&#39;, &#39;2017-01-06&#39;, &#39;2017-01-07&#39;, &#39;2017-01-08&#39;,
               &#39;2017-01-09&#39;, &#39;2017-01-10&#39;],
              dtype=&#39;datetime64[ns]&#39;, name=&#39;hello world!&#39;, freq=&#39;D&#39;)
-------
DatetimeIndex([&#39;2017-01-01&#39;, &#39;2017-01-02&#39;, &#39;2017-01-03&#39;, &#39;2017-01-04&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)
DatetimeIndex([&#39;2017-01-02&#39;, &#39;2017-01-03&#39;, &#39;2017-01-04&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)
DatetimeIndex([&#39;2017-01-01&#39;, &#39;2017-01-02&#39;, &#39;2017-01-03&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)
-------
DatetimeIndex([&#39;2017-01-02&#39;, &#39;2017-01-03&#39;, &#39;2017-01-04&#39;, &#39;2017-01-05&#39;,
               &#39;2017-01-06&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=&#39;B&#39;)
[Timestamp(&#39;2017-01-01 00:00:00&#39;, freq=&#39;D&#39;), Timestamp(&#39;2017-01-02 00:00:00&#39;, freq=&#39;D&#39;), Timestamp(&#39;2017-01-03 00:00:00&#39;, freq=&#39;D&#39;), Timestamp(&#39;2017-01-04 00:00:00&#39;, freq=&#39;D&#39;), Timestamp(&#39;2017-01-05 00:00:00&#39;, freq=&#39;D&#39;), Timestamp(&#39;2017-01-06 00:00:00&#39;, freq=&#39;D&#39;), Timestamp(&#39;2017-01-07 00:00:00&#39;, freq=&#39;D&#39;), Timestamp(&#39;2017-01-08 00:00:00&#39;, freq=&#39;D&#39;), Timestamp(&#39;2017-01-09 00:00:00&#39;, freq=&#39;D&#39;), Timestamp(&#39;2017-01-10 00:00:00&#39;, freq=&#39;D&#39;)]
</code></pre>

<h4 id="toc_43">pd.date_range()-日期范围：频率(1)</h4>

<pre><code class="language-python">print(pd.date_range(&#39;2017/1/1&#39;,&#39;2017/1/4&#39;))  # 默认freq = &#39;D&#39;：每日历日
print(pd.date_range(&#39;2017/1/1&#39;,&#39;2017/1/4&#39;, freq = &#39;B&#39;))  # B：每工作日
print(pd.date_range(&#39;2017/1/1&#39;,&#39;2017/1/2&#39;, freq = &#39;H&#39;))  # H：每小时
print(pd.date_range(&#39;2017/1/1 12:00&#39;,&#39;2017/1/1 12:10&#39;, freq = &#39;T&#39;))  # T/MIN：每分
print(pd.date_range(&#39;2017/1/1 12:00:00&#39;,&#39;2017/1/1 12:00:10&#39;, freq = &#39;S&#39;))  # S：每秒
print(pd.date_range(&#39;2017/1/1 12:00:00&#39;,&#39;2017/1/1 12:00:10&#39;, freq = &#39;L&#39;))  # L：每毫秒（千分之一秒）
print(pd.date_range(&#39;2017/1/1 12:00:00&#39;,&#39;2017/1/1 12:00:10&#39;, freq = &#39;U&#39;))  # U：每微秒（百万分之一秒）

print(pd.date_range(&#39;2017/1/1&#39;,&#39;2017/2/1&#39;, freq = &#39;W-MON&#39;))  
# W-MON：从指定星期几开始算起，每周
# 星期几缩写：MON/TUE/WED/THU/FRI/SAT/SUN

print(pd.date_range(&#39;2017/1/1&#39;,&#39;2017/5/1&#39;, freq = &#39;WOM-2MON&#39;))  
# WOM-2MON：每月的第几个星期几开始算，这里是每月第二个星期一

</code></pre>

<pre><code class="language-text">DatetimeIndex([&#39;2017-01-01&#39;, &#39;2017-01-02&#39;, &#39;2017-01-03&#39;, &#39;2017-01-04&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)
DatetimeIndex([&#39;2017-01-02&#39;, &#39;2017-01-03&#39;, &#39;2017-01-04&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;B&#39;)
DatetimeIndex([&#39;2017-01-01 00:00:00&#39;, &#39;2017-01-01 01:00:00&#39;,
               &#39;2017-01-01 02:00:00&#39;, &#39;2017-01-01 03:00:00&#39;,
               &#39;2017-01-01 04:00:00&#39;, &#39;2017-01-01 05:00:00&#39;,
               &#39;2017-01-01 06:00:00&#39;, &#39;2017-01-01 07:00:00&#39;,
               &#39;2017-01-01 08:00:00&#39;, &#39;2017-01-01 09:00:00&#39;,
               &#39;2017-01-01 10:00:00&#39;, &#39;2017-01-01 11:00:00&#39;,
               &#39;2017-01-01 12:00:00&#39;, &#39;2017-01-01 13:00:00&#39;,
               &#39;2017-01-01 14:00:00&#39;, &#39;2017-01-01 15:00:00&#39;,
               &#39;2017-01-01 16:00:00&#39;, &#39;2017-01-01 17:00:00&#39;,
               &#39;2017-01-01 18:00:00&#39;, &#39;2017-01-01 19:00:00&#39;,
               &#39;2017-01-01 20:00:00&#39;, &#39;2017-01-01 21:00:00&#39;,
               &#39;2017-01-01 22:00:00&#39;, &#39;2017-01-01 23:00:00&#39;,
               &#39;2017-01-02 00:00:00&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=&#39;H&#39;)
DatetimeIndex([&#39;2017-01-01 12:00:00&#39;, &#39;2017-01-01 12:01:00&#39;,
               &#39;2017-01-01 12:02:00&#39;, &#39;2017-01-01 12:03:00&#39;,
               &#39;2017-01-01 12:04:00&#39;, &#39;2017-01-01 12:05:00&#39;,
               &#39;2017-01-01 12:06:00&#39;, &#39;2017-01-01 12:07:00&#39;,
               &#39;2017-01-01 12:08:00&#39;, &#39;2017-01-01 12:09:00&#39;,
               &#39;2017-01-01 12:10:00&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=&#39;T&#39;)
DatetimeIndex([&#39;2017-01-01 12:00:00&#39;, &#39;2017-01-01 12:00:01&#39;,
               &#39;2017-01-01 12:00:02&#39;, &#39;2017-01-01 12:00:03&#39;,
               &#39;2017-01-01 12:00:04&#39;, &#39;2017-01-01 12:00:05&#39;,
               &#39;2017-01-01 12:00:06&#39;, &#39;2017-01-01 12:00:07&#39;,
               &#39;2017-01-01 12:00:08&#39;, &#39;2017-01-01 12:00:09&#39;,
               &#39;2017-01-01 12:00:10&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=&#39;S&#39;)
DatetimeIndex([       &#39;2017-01-01 12:00:00&#39;, &#39;2017-01-01 12:00:00.001000&#39;,
               &#39;2017-01-01 12:00:00.002000&#39;, &#39;2017-01-01 12:00:00.003000&#39;,
               &#39;2017-01-01 12:00:00.004000&#39;, &#39;2017-01-01 12:00:00.005000&#39;,
               &#39;2017-01-01 12:00:00.006000&#39;, &#39;2017-01-01 12:00:00.007000&#39;,
               &#39;2017-01-01 12:00:00.008000&#39;, &#39;2017-01-01 12:00:00.009000&#39;,
               ...
               &#39;2017-01-01 12:00:09.991000&#39;, &#39;2017-01-01 12:00:09.992000&#39;,
               &#39;2017-01-01 12:00:09.993000&#39;, &#39;2017-01-01 12:00:09.994000&#39;,
               &#39;2017-01-01 12:00:09.995000&#39;, &#39;2017-01-01 12:00:09.996000&#39;,
               &#39;2017-01-01 12:00:09.997000&#39;, &#39;2017-01-01 12:00:09.998000&#39;,
               &#39;2017-01-01 12:00:09.999000&#39;,        &#39;2017-01-01 12:00:10&#39;],
              dtype=&#39;datetime64[ns]&#39;, length=10001, freq=&#39;L&#39;)
DatetimeIndex([       &#39;2017-01-01 12:00:00&#39;, &#39;2017-01-01 12:00:00.000001&#39;,
               &#39;2017-01-01 12:00:00.000002&#39;, &#39;2017-01-01 12:00:00.000003&#39;,
               &#39;2017-01-01 12:00:00.000004&#39;, &#39;2017-01-01 12:00:00.000005&#39;,
               &#39;2017-01-01 12:00:00.000006&#39;, &#39;2017-01-01 12:00:00.000007&#39;,
               &#39;2017-01-01 12:00:00.000008&#39;, &#39;2017-01-01 12:00:00.000009&#39;,
               ...
               &#39;2017-01-01 12:00:09.999991&#39;, &#39;2017-01-01 12:00:09.999992&#39;,
               &#39;2017-01-01 12:00:09.999993&#39;, &#39;2017-01-01 12:00:09.999994&#39;,
               &#39;2017-01-01 12:00:09.999995&#39;, &#39;2017-01-01 12:00:09.999996&#39;,
               &#39;2017-01-01 12:00:09.999997&#39;, &#39;2017-01-01 12:00:09.999998&#39;,
               &#39;2017-01-01 12:00:09.999999&#39;,        &#39;2017-01-01 12:00:10&#39;],
              dtype=&#39;datetime64[ns]&#39;, length=10000001, freq=&#39;U&#39;)
DatetimeIndex([&#39;2017-01-02&#39;, &#39;2017-01-09&#39;, &#39;2017-01-16&#39;, &#39;2017-01-23&#39;,
               &#39;2017-01-30&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=&#39;W-MON&#39;)
DatetimeIndex([&#39;2017-01-09&#39;, &#39;2017-02-13&#39;, &#39;2017-03-13&#39;, &#39;2017-04-10&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;WOM-2MON&#39;)
</code></pre>

<h4 id="toc_44">pd.date_range()-日期范围：频率(2)</h4>

<pre><code class="language-python">print(pd.date_range(&#39;2017&#39;,&#39;2018&#39;, freq = &#39;M&#39;))  
print(pd.date_range(&#39;2017&#39;,&#39;2020&#39;, freq = &#39;Q-DEC&#39;))  
print(pd.date_range(&#39;2017&#39;,&#39;2020&#39;, freq = &#39;A-DEC&#39;)) 
print(&#39;------&#39;)
# M：每月最后一个日历日
# Q-月：指定月为季度末，每个季度末最后一月的最后一个日历日
# A-月：每年指定月份的最后一个日历日
# 月缩写：JAN/FEB/MAR/APR/MAY/JUN/JUL/AUG/SEP/OCT/NOV/DEC
# 所以Q-月只有三种情况：1-4-7-10,2-5-8-11,3-6-9-12

print(pd.date_range(&#39;2017&#39;,&#39;2018&#39;, freq = &#39;BM&#39;))  
print(pd.date_range(&#39;2017&#39;,&#39;2020&#39;, freq = &#39;BQ-DEC&#39;))  
print(pd.date_range(&#39;2017&#39;,&#39;2020&#39;, freq = &#39;BA-DEC&#39;)) 
print(&#39;------&#39;)
# BM：每月最后一个工作日
# BQ-月：指定月为季度末，每个季度末最后一月的最后一个工作日
# BA-月：每年指定月份的最后一个工作日

print(pd.date_range(&#39;2017&#39;,&#39;2018&#39;, freq = &#39;MS&#39;))  
print(pd.date_range(&#39;2017&#39;,&#39;2020&#39;, freq = &#39;QS-DEC&#39;))  
print(pd.date_range(&#39;2017&#39;,&#39;2020&#39;, freq = &#39;AS-DEC&#39;)) 
print(&#39;------&#39;)
# M：每月第一个日历日
# Q-月：指定月为季度末，每个季度末最后一月的第一个日历日
# A-月：每年指定月份的第一个日历日

print(pd.date_range(&#39;2017&#39;,&#39;2018&#39;, freq = &#39;BMS&#39;))  
print(pd.date_range(&#39;2017&#39;,&#39;2020&#39;, freq = &#39;BQS-DEC&#39;))  
print(pd.date_range(&#39;2017&#39;,&#39;2020&#39;, freq = &#39;BAS-DEC&#39;)) 
print(&#39;------&#39;)
# BM：每月第一个工作日
# BQ-月：指定月为季度末，每个季度末最后一月的第一个工作日
# BA-月：每年指定月份的第一个工作日

</code></pre>

<pre><code class="language-text">DatetimeIndex([&#39;2017-01-31&#39;, &#39;2017-02-28&#39;, &#39;2017-03-31&#39;, &#39;2017-04-30&#39;,
               &#39;2017-05-31&#39;, &#39;2017-06-30&#39;, &#39;2017-07-31&#39;, &#39;2017-08-31&#39;,
               &#39;2017-09-30&#39;, &#39;2017-10-31&#39;, &#39;2017-11-30&#39;, &#39;2017-12-31&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=&#39;M&#39;)
DatetimeIndex([&#39;2017-03-31&#39;, &#39;2017-06-30&#39;, &#39;2017-09-30&#39;, &#39;2017-12-31&#39;,
               &#39;2018-03-31&#39;, &#39;2018-06-30&#39;, &#39;2018-09-30&#39;, &#39;2018-12-31&#39;,
               &#39;2019-03-31&#39;, &#39;2019-06-30&#39;, &#39;2019-09-30&#39;, &#39;2019-12-31&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=&#39;Q-DEC&#39;)
DatetimeIndex([&#39;2017-12-31&#39;, &#39;2018-12-31&#39;, &#39;2019-12-31&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;A-DEC&#39;)
------
DatetimeIndex([&#39;2017-01-31&#39;, &#39;2017-02-28&#39;, &#39;2017-03-31&#39;, &#39;2017-04-28&#39;,
               &#39;2017-05-31&#39;, &#39;2017-06-30&#39;, &#39;2017-07-31&#39;, &#39;2017-08-31&#39;,
               &#39;2017-09-29&#39;, &#39;2017-10-31&#39;, &#39;2017-11-30&#39;, &#39;2017-12-29&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=&#39;BM&#39;)
DatetimeIndex([&#39;2017-03-31&#39;, &#39;2017-06-30&#39;, &#39;2017-09-29&#39;, &#39;2017-12-29&#39;,
               &#39;2018-03-30&#39;, &#39;2018-06-29&#39;, &#39;2018-09-28&#39;, &#39;2018-12-31&#39;,
               &#39;2019-03-29&#39;, &#39;2019-06-28&#39;, &#39;2019-09-30&#39;, &#39;2019-12-31&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=&#39;BQ-DEC&#39;)
DatetimeIndex([&#39;2017-12-29&#39;, &#39;2018-12-31&#39;, &#39;2019-12-31&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;BA-DEC&#39;)
------
DatetimeIndex([&#39;2017-01-01&#39;, &#39;2017-02-01&#39;, &#39;2017-03-01&#39;, &#39;2017-04-01&#39;,
               &#39;2017-05-01&#39;, &#39;2017-06-01&#39;, &#39;2017-07-01&#39;, &#39;2017-08-01&#39;,
               &#39;2017-09-01&#39;, &#39;2017-10-01&#39;, &#39;2017-11-01&#39;, &#39;2017-12-01&#39;,
               &#39;2018-01-01&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=&#39;MS&#39;)
DatetimeIndex([&#39;2017-03-01&#39;, &#39;2017-06-01&#39;, &#39;2017-09-01&#39;, &#39;2017-12-01&#39;,
               &#39;2018-03-01&#39;, &#39;2018-06-01&#39;, &#39;2018-09-01&#39;, &#39;2018-12-01&#39;,
               &#39;2019-03-01&#39;, &#39;2019-06-01&#39;, &#39;2019-09-01&#39;, &#39;2019-12-01&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=&#39;QS-DEC&#39;)
DatetimeIndex([&#39;2017-12-01&#39;, &#39;2018-12-01&#39;, &#39;2019-12-01&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;AS-DEC&#39;)
------
DatetimeIndex([&#39;2017-01-02&#39;, &#39;2017-02-01&#39;, &#39;2017-03-01&#39;, &#39;2017-04-03&#39;,
               &#39;2017-05-01&#39;, &#39;2017-06-01&#39;, &#39;2017-07-03&#39;, &#39;2017-08-01&#39;,
               &#39;2017-09-01&#39;, &#39;2017-10-02&#39;, &#39;2017-11-01&#39;, &#39;2017-12-01&#39;,
               &#39;2018-01-01&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=&#39;BMS&#39;)
DatetimeIndex([&#39;2017-03-01&#39;, &#39;2017-06-01&#39;, &#39;2017-09-01&#39;, &#39;2017-12-01&#39;,
               &#39;2018-03-01&#39;, &#39;2018-06-01&#39;, &#39;2018-09-03&#39;, &#39;2018-12-03&#39;,
               &#39;2019-03-01&#39;, &#39;2019-06-03&#39;, &#39;2019-09-02&#39;, &#39;2019-12-02&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=&#39;BQS-DEC&#39;)
DatetimeIndex([&#39;2017-12-01&#39;, &#39;2018-12-03&#39;, &#39;2019-12-02&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;BAS-DEC&#39;)
------
</code></pre>

<h4 id="toc_45">pd.date_range()-日期范围：复合频率</h4>

<pre><code class="language-python">print(pd.date_range(&#39;2017/1/1&#39;,&#39;2017/2/1&#39;, freq = &#39;7D&#39;))  # 7天
print(pd.date_range(&#39;2017/1/1&#39;,&#39;2017/1/2&#39;, freq = &#39;2h30min&#39;))  # 2小时30分钟
print(pd.date_range(&#39;2017&#39;,&#39;2018&#39;, freq = &#39;2M&#39;))  # 2月，每月最后一个日历日

</code></pre>

<pre><code class="language-text">DatetimeIndex([&#39;2017-01-01&#39;, &#39;2017-01-08&#39;, &#39;2017-01-15&#39;, &#39;2017-01-22&#39;,
               &#39;2017-01-29&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=&#39;7D&#39;)
DatetimeIndex([&#39;2017-01-01 00:00:00&#39;, &#39;2017-01-01 02:30:00&#39;,
               &#39;2017-01-01 05:00:00&#39;, &#39;2017-01-01 07:30:00&#39;,
               &#39;2017-01-01 10:00:00&#39;, &#39;2017-01-01 12:30:00&#39;,
               &#39;2017-01-01 15:00:00&#39;, &#39;2017-01-01 17:30:00&#39;,
               &#39;2017-01-01 20:00:00&#39;, &#39;2017-01-01 22:30:00&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=&#39;150T&#39;)
DatetimeIndex([&#39;2017-01-31&#39;, &#39;2017-03-31&#39;, &#39;2017-05-31&#39;, &#39;2017-07-31&#39;,
               &#39;2017-09-30&#39;, &#39;2017-11-30&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=&#39;2M&#39;)
</code></pre>

<h4 id="toc_46">asfreq：时期频率转换</h4>

<pre><code class="language-python">ts = pd.Series(np.random.rand(4),
              index = pd.date_range(&#39;20170101&#39;,&#39;20170104&#39;))
print(ts)
print(ts.asfreq(&#39;4H&#39;,method = &#39;ffill&#39;))
# 改变频率，这里是D改为4H
# method：插值模式，None不插值，ffill用之前值填充，bfill用之后值填充

</code></pre>

<pre><code class="language-text">2017-01-01    0.380807
2017-01-02    0.082508
2017-01-03    0.989844
2017-01-04    0.946656
Freq: D, dtype: float64
2017-01-01 00:00:00    0.380807
2017-01-01 04:00:00    0.380807
2017-01-01 08:00:00    0.380807
2017-01-01 12:00:00    0.380807
2017-01-01 16:00:00    0.380807
2017-01-01 20:00:00    0.380807
2017-01-02 00:00:00    0.082508
2017-01-02 04:00:00    0.082508
2017-01-02 08:00:00    0.082508
2017-01-02 12:00:00    0.082508
2017-01-02 16:00:00    0.082508
2017-01-02 20:00:00    0.082508
2017-01-03 00:00:00    0.989844
2017-01-03 04:00:00    0.989844
2017-01-03 08:00:00    0.989844
2017-01-03 12:00:00    0.989844
2017-01-03 16:00:00    0.989844
2017-01-03 20:00:00    0.989844
2017-01-04 00:00:00    0.946656
Freq: 4H, dtype: float64
</code></pre>

<h4 id="toc_47">pd.date_range()-日期范围：超前/滞后数据</h4>

<pre><code class="language-python">ts = pd.Series(np.random.rand(4),
              index = pd.date_range(&#39;20170101&#39;,&#39;20170104&#39;))
print(ts)

print(ts.shift(2))
print(ts.shift(-2))
print(&#39;------&#39;)
# 正数：数值后移（滞后）；负数：数值前移（超前）

per = ts/ts.shift(1) - 1
print(per)
print(&#39;------&#39;)
# 计算变化百分比，这里计算：该时间戳与上一个时间戳相比，变化百分比

print(ts.shift(2, freq = &#39;D&#39;))
print(ts.shift(2, freq = &#39;T&#39;))
# 加上freq参数：对时间戳进行位移，而不是对数值进行位移

</code></pre>

<pre><code class="language-text">2017-01-01    0.887591
2017-01-02    0.220969
2017-01-03    0.397006
2017-01-04    0.392343
Freq: D, dtype: float64
2017-01-01         NaN
2017-01-02         NaN
2017-01-03    0.887591
2017-01-04    0.220969
Freq: D, dtype: float64
2017-01-01    0.397006
2017-01-02    0.392343
2017-01-03         NaN
2017-01-04         NaN
Freq: D, dtype: float64
------
2017-01-01         NaN
2017-01-02   -0.751046
2017-01-03    0.796660
2017-01-04   -0.011747
Freq: D, dtype: float64
------
2017-01-03    0.887591
2017-01-04    0.220969
2017-01-05    0.397006
2017-01-06    0.392343
Freq: D, dtype: float64
2017-01-01 00:02:00    0.887591
2017-01-02 00:02:00    0.220969
2017-01-03 00:02:00    0.397006
2017-01-04 00:02:00    0.392343
Freq: D, dtype: float64
</code></pre>

<h3 id="toc_48">Period（Pandas时期）</h3>

<h4 id="toc_49">pd.Period()创建时期</h4>

<pre><code class="language-python">p = pd.Period(&#39;2017&#39;, freq = &#39;M&#39;)
print(p, type(p))
# 生成一个以2017-01开始，月为频率的时间构造器
# pd.Period()参数：一个时间戳 + freq 参数 → freq 用于指明该 period 的长度，时间戳则说明该 period 在时间轴上的位置

print(p + 1)
print(p - 2)
print(pd.Period(&#39;2012&#39;, freq = &#39;A-DEC&#39;) - 1)
# 通过加减整数，将周期整体移动
# 这里是按照 月、年 移动

</code></pre>

<pre><code class="language-text">2017-01 &lt;class &#39;pandas._libs.tslibs.period.Period&#39;&gt;
2017-02
2016-11
2011
</code></pre>

<h4 id="toc_50">pd.period_range()创建时期范围</h4>

<pre><code class="language-python">prng = pd.period_range(&#39;1/1/2011&#39;, &#39;1/1/2012&#39;, freq=&#39;M&#39;)
print(prng,type(prng))
print(prng[0],type(prng[0]))
# 数据格式为PeriodIndex，单个数值为Period

ts = pd.Series(np.random.rand(len(prng)), index = prng)
print(ts,type(ts))
print(ts.index)

</code></pre>

<pre><code class="language-text">PeriodIndex([&#39;2011-01&#39;, &#39;2011-02&#39;, &#39;2011-03&#39;, &#39;2011-04&#39;, &#39;2011-05&#39;, &#39;2011-06&#39;,
             &#39;2011-07&#39;, &#39;2011-08&#39;, &#39;2011-09&#39;, &#39;2011-10&#39;, &#39;2011-11&#39;, &#39;2011-12&#39;,
             &#39;2012-01&#39;],
            dtype=&#39;period[M]&#39;, freq=&#39;M&#39;) &lt;class &#39;pandas.core.indexes.period.PeriodIndex&#39;&gt;
2011-01 &lt;class &#39;pandas._libs.tslibs.period.Period&#39;&gt;
2011-01    0.824645
2011-02    0.903224
2011-03    0.531356
2011-04    0.232478
2011-05    0.410850
2011-06    0.604149
2011-07    0.680435
2011-08    0.039116
2011-09    0.600320
2011-10    0.503596
2011-11    0.995603
2011-12    0.810485
2012-01    0.985762
Freq: M, dtype: float64 &lt;class &#39;pandas.core.series.Series&#39;&gt;
PeriodIndex([&#39;2011-01&#39;, &#39;2011-02&#39;, &#39;2011-03&#39;, &#39;2011-04&#39;, &#39;2011-05&#39;, &#39;2011-06&#39;,
             &#39;2011-07&#39;, &#39;2011-08&#39;, &#39;2011-09&#39;, &#39;2011-10&#39;, &#39;2011-11&#39;, &#39;2011-12&#39;,
             &#39;2012-01&#39;],
            dtype=&#39;period[M]&#39;, freq=&#39;M&#39;)
</code></pre>

<p><strong>时间序列</strong></p>

<ul>
<li><p>Period(&#39;2011&#39;, freq = &#39;A-DEC&#39;)可以看成多个时间期的时间段中的游标</p></li>
<li><p>Timestamp表示一个时间戳，是一个时间截面；Period是一个时期，是一个时间段！！但两者作为index时区别不大</p></li>
</ul>

<h4 id="toc_51">asfreq：频率转换</h4>

<pre><code class="language-python">p = pd.Period(&#39;2017&#39;,&#39;A-DEC&#39;)
print(p)
print(p.asfreq(&#39;M&#39;, how = &#39;start&#39;))  # 也可写 how = &#39;s&#39;
print(p.asfreq(&#39;D&#39;, how = &#39;end&#39;))  # 也可写 how = &#39;e&#39;
# 通过.asfreq(freq, method=None, how=None)方法转换成别的频率

prng = pd.period_range(&#39;2017&#39;,&#39;2018&#39;,freq = &#39;M&#39;)
ts1 = pd.Series(np.random.rand(len(prng)), index = prng)
ts2 = pd.Series(np.random.rand(len(prng)), index = prng.asfreq(&#39;D&#39;, how = &#39;start&#39;))
print(ts1.head(),len(ts1))
print(ts2.head(),len(ts2))
# asfreq也可以转换TIMESeries的index

</code></pre>

<pre><code class="language-text">2017
2017-01
2017-12-31
2017-01    0.803362
2017-02    0.680803
2017-03    0.503056
2017-04    0.885740
2017-05    0.983818
Freq: M, dtype: float64 13
2017-01-01    0.544769
2017-02-01    0.378608
2017-03-01    0.119503
2017-04-01    0.238595
2017-05-01    0.497255
Freq: D, dtype: float64 13
</code></pre>

<h4 id="toc_52">时间戳与时期之间的转换</h4>

<pre><code class="language-python">rng = pd.date_range(&#39;2017/1/1&#39;, periods = 10, freq = &#39;M&#39;)
prng = pd.period_range(&#39;2017&#39;,&#39;2018&#39;, freq = &#39;M&#39;)

ts1 = pd.Series(np.random.rand(len(rng)), index = rng)
print(ts1.head())
print(ts1.to_period().head())
# 每月最后一日，转化为每月

ts2 = pd.Series(np.random.rand(len(prng)), index = prng)
print(ts2.head())
print(ts2.to_timestamp().head())
# 每月，转化为每月第一天

</code></pre>

<pre><code class="language-text">2017-01-31    0.867821
2017-02-28    0.543612
2017-03-31    0.893282
2017-04-30    0.809654
2017-05-31    0.464549
Freq: M, dtype: float64
2017-01    0.867821
2017-02    0.543612
2017-03    0.893282
2017-04    0.809654
2017-05    0.464549
Freq: M, dtype: float64
2017-01    0.731718
2017-02    0.517833
2017-03    0.473853
2017-04    0.009430
2017-05    0.998953
Freq: M, dtype: float64
2017-01-01    0.731718
2017-02-01    0.517833
2017-03-01    0.473853
2017-04-01    0.009430
2017-05-01    0.998953
Freq: MS, dtype: float64
</code></pre>

<h3 id="toc_53">时间序列 - 索引及切片</h3>

<p>TimeSeries是Series的一个子类，所以Series索引及数据选取方面的方法基本一样</p>

<p>同时TimeSeries通过时间序列有更便捷的方法做索引和切片</p>

<h4 id="toc_54">索引</h4>

<pre><code class="language-python">from datetime import datetime

rng = pd.date_range(&#39;2017/1&#39;,&#39;2017/3&#39;)
ts = pd.Series(np.random.rand(len(rng)), index = rng)
print(ts.head())

print(ts[0])
print(ts[:2])
print(&#39;-----&#39;)
# 基本下标位置索引

print(ts[&#39;2017/1/2&#39;])
print(ts[&#39;20170103&#39;])
print(ts[&#39;1/10/2017&#39;])
print(ts[datetime(2017,1,20)])
print(&#39;-----&#39;)
# 时间序列标签索引，支持各种时间字符串，以及datetime.datetime

# 时间序列由于按照时间先后排序，故不用考虑顺序问题
# 索引方法同样适用于Dataframe

</code></pre>

<pre><code class="language-text">2017-01-01    0.790453
2017-01-02    0.252198
2017-01-03    0.360769
2017-01-04    0.525272
2017-01-05    0.452863
Freq: D, dtype: float64
0.7904527728537566
2017-01-01    0.790453
2017-01-02    0.252198
Freq: D, dtype: float64
-----
0.25219772923312767
0.3607686710038176
0.6528232574813878
0.352811458536781
-----
</code></pre>

<h4 id="toc_55">切片</h4>

<pre><code class="language-python">rng = pd.date_range(&#39;2017/1&#39;,&#39;2017/3&#39;,freq = &#39;12H&#39;)
ts = pd.Series(np.random.rand(len(rng)), index = rng)

print(ts[&#39;2017/1/5&#39;:&#39;2017/1/10&#39;])
print(&#39;-----&#39;)
# 和Series按照index索引原理一样，也是末端包含

print(ts[&#39;2017/2&#39;].head())
# 传入月，直接得到一个切片

</code></pre>

<pre><code class="language-text">2017-01-05 00:00:00    0.042829
2017-01-05 12:00:00    0.441050
2017-01-06 00:00:00    0.400631
2017-01-06 12:00:00    0.026122
2017-01-07 00:00:00    0.493281
2017-01-07 12:00:00    0.559460
2017-01-08 00:00:00    0.673397
2017-01-08 12:00:00    0.682465
2017-01-09 00:00:00    0.160642
2017-01-09 12:00:00    0.048712
2017-01-10 00:00:00    0.668822
2017-01-10 12:00:00    0.734941
Freq: 12H, dtype: float64
-----
2017-02-01 00:00:00    0.528840
2017-02-01 12:00:00    0.692276
2017-02-02 00:00:00    0.812610
2017-02-02 12:00:00    0.620347
2017-02-03 00:00:00    0.877217
Freq: 12H, dtype: float64
</code></pre>

<h4 id="toc_56">重复索引的时间序列</h4>

<pre><code class="language-python">dates = pd.DatetimeIndex([&#39;1/1/2015&#39;,&#39;1/2/2015&#39;,&#39;1/3/2015&#39;,&#39;1/4/2015&#39;,&#39;1/1/2015&#39;,&#39;1/2/2015&#39;])
ts = pd.Series(np.random.rand(6), index = dates)
print(ts)
print(ts.is_unique,ts.index.is_unique)
print(&#39;-----&#39;)
# index有重复，is_unique检查 → values唯一，index不唯一

print(ts[&#39;20150101&#39;],type(ts[&#39;20150101&#39;]))
print(ts[&#39;20150104&#39;],type(ts[&#39;20150104&#39;]))
print(&#39;-----&#39;)
# index有重复的将返回多个值

print(ts.groupby(level = 0).mean())
# 通过groupby做分组，重复的值这里用平均值处理

</code></pre>

<pre><code class="language-text">2015-01-01    0.987115
2015-01-02    0.331198
2015-01-03    0.900640
2015-01-04    0.906425
2015-01-01    0.090501
2015-01-02    0.841942
dtype: float64
True False
-----
2015-01-01    0.987115
2015-01-01    0.090501
dtype: float64 &lt;class &#39;pandas.core.series.Series&#39;&gt;
2015-01-04    0.906425
dtype: float64 &lt;class &#39;pandas.core.series.Series&#39;&gt;
-----
2015-01-01    0.538808
2015-01-02    0.586570
2015-01-03    0.900640
2015-01-04    0.906425
dtype: float64
</code></pre>

<h3 id="toc_57">时间序列 - 重采样</h3>

<p>将时间序列从一个频率转换为另一个频率的过程，且会有数据的结合</p>

<ul>
<li><p>降采样：高频数据 → 低频数据，eg.以天为频率的数据转为以月为频率的数据</p></li>
<li><p>升采样：低频数据 → 高频数据，eg.以年为频率的数据转为以月为频率的数据</p></li>
</ul>

<h4 id="toc_58">重采样：.resample()</h4>

<pre><code class="language-python"># 创建一个以天为频率的TimeSeries，重采样为按2天为频率

rng = pd.date_range(&#39;20170101&#39;, periods = 12)
ts = pd.Series(np.arange(12), index = rng)
print(ts)

ts_re = ts.resample(&#39;5D&#39;)
ts_re2 = ts.resample(&#39;5D&#39;).sum()
print(ts_re, type(ts_re))
print(ts_re2, type(ts_re2))
print(&#39;-----&#39;)
# ts.resample(&#39;5D&#39;)：得到一个重采样构建器，频率改为5天
# ts.resample(&#39;5D&#39;).sum():得到一个新的聚合后的Series，聚合方式为求和
# freq：重采样频率 → ts.resample(&#39;5D&#39;)
# .sum()：聚合方法

print(ts.resample(&#39;5D&#39;).mean(),&#39;→ 求平均值\n&#39;)
print(ts.resample(&#39;5D&#39;).max(),&#39;→ 求最大值\n&#39;)
print(ts.resample(&#39;5D&#39;).min(),&#39;→ 求最小值\n&#39;)
print(ts.resample(&#39;5D&#39;).median(),&#39;→ 求中值\n&#39;)
print(ts.resample(&#39;5D&#39;).first(),&#39;→ 返回第一个值\n&#39;)
print(ts.resample(&#39;5D&#39;).last(),&#39;→ 返回最后一个值\n&#39;)
print(ts.resample(&#39;5D&#39;).ohlc(),&#39;→ OHLC重采样\n&#39;)
# OHLC:金融领域的时间序列聚合方式 → open开盘、high最大值、low最小值、close收盘

</code></pre>

<pre><code class="language-text">2017-01-01     0
2017-01-02     1
2017-01-03     2
2017-01-04     3
2017-01-05     4
2017-01-06     5
2017-01-07     6
2017-01-08     7
2017-01-09     8
2017-01-10     9
2017-01-11    10
2017-01-12    11
Freq: D, dtype: int32
DatetimeIndexResampler [freq=&lt;5 * Days&gt;, axis=0, closed=left, label=left, convention=start, base=0] &lt;class &#39;pandas.core.resample.DatetimeIndexResampler&#39;&gt;
2017-01-01    10
2017-01-06    35
2017-01-11    21
dtype: int32 &lt;class &#39;pandas.core.series.Series&#39;&gt;
-----
2017-01-01     2.0
2017-01-06     7.0
2017-01-11    10.5
dtype: float64 → 求平均值

2017-01-01     4
2017-01-06     9
2017-01-11    11
dtype: int32 → 求最大值

2017-01-01     0
2017-01-06     5
2017-01-11    10
dtype: int32 → 求最小值

2017-01-01     2.0
2017-01-06     7.0
2017-01-11    10.5
dtype: float64 → 求中值

2017-01-01     0
2017-01-06     5
2017-01-11    10
dtype: int32 → 返回第一个值

2017-01-01     4
2017-01-06     9
2017-01-11    11
dtype: int32 → 返回最后一个值

            open  high  low  close
2017-01-01     0     4    0      4
2017-01-06     5     9    5      9
2017-01-11    10    11   10     11 → OHLC重采样
</code></pre>

<p>​    </p>

<h4 id="toc_59">降采样</h4>

<pre><code class="language-python">rng = pd.date_range(&#39;20170101&#39;, periods = 12)
ts = pd.Series(np.arange(1,13), index = rng)
print(ts)

print(ts.resample(&#39;5D&#39;).sum(),&#39;→ 默认\n&#39;)
print(ts.resample(&#39;5D&#39;, closed = &#39;left&#39;).sum(),&#39;→ left\n&#39;)
print(ts.resample(&#39;5D&#39;, closed = &#39;right&#39;).sum(),&#39;→ right\n&#39;)
print(&#39;-----&#39;)
# closed：各时间段哪一端是闭合（即包含）的，默认 左闭右闭
# 详解：这里values为0-11，按照5D重采样 → [1,2,3,4,5],[6,7,8,9,10],[11,12]
# left指定间隔左边为结束 → [1,2,3,4,5],[6,7,8,9,10],[11,12]
# right指定间隔右边为结束 → [1],[2,3,4,5,6],[7,8,9,10,11],[12]

print(ts.resample(&#39;5D&#39;, label = &#39;left&#39;).sum(),&#39;→ leftlabel\n&#39;)
print(ts.resample(&#39;5D&#39;, label = &#39;right&#39;).sum(),&#39;→ rightlabel\n&#39;)
# label：聚合值的index，默认为取左
# 值采样认为默认（这里closed默认）

</code></pre>

<pre><code class="language-text">2017-01-01     1
2017-01-02     2
2017-01-03     3
2017-01-04     4
2017-01-05     5
2017-01-06     6
2017-01-07     7
2017-01-08     8
2017-01-09     9
2017-01-10    10
2017-01-11    11
2017-01-12    12
Freq: D, dtype: int32
2017-01-01    15
2017-01-06    40
2017-01-11    23
dtype: int32 → 默认

2017-01-01    15
2017-01-06    40
2017-01-11    23
dtype: int32 → left

2016-12-27     1
2017-01-01    20
2017-01-06    45
2017-01-11    12
dtype: int32 → right

-----
2017-01-01    15
2017-01-06    40
2017-01-11    23
dtype: int32 → leftlabel

2017-01-06    15
2017-01-11    40
2017-01-16    23
dtype: int32 → rightlabel
</code></pre>

<p>​    </p>

<h4 id="toc_60">升采样及插值</h4>

<pre><code class="language-python">rng = pd.date_range(&#39;2017/1/1 0:0:0&#39;, periods = 5, freq = &#39;H&#39;)
ts = pd.DataFrame(np.arange(15).reshape(5,3),
                  index = rng,
                  columns = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;])
print(ts)

print(ts.resample(&#39;15T&#39;).asfreq())
print(ts.resample(&#39;15T&#39;).ffill())
print(ts.resample(&#39;15T&#39;).bfill())
# 低频转高频，主要是如何插值
# .asfreq()：不做填充，返回Nan
# .ffill()：向上填充
# .bfill()：向下填充

</code></pre>

<pre><code class="language-text">                      a   b   c
2017-01-01 00:00:00   0   1   2
2017-01-01 01:00:00   3   4   5
2017-01-01 02:00:00   6   7   8
2017-01-01 03:00:00   9  10  11
2017-01-01 04:00:00  12  13  14
                        a     b     c
2017-01-01 00:00:00   0.0   1.0   2.0
2017-01-01 00:15:00   NaN   NaN   NaN
2017-01-01 00:30:00   NaN   NaN   NaN
2017-01-01 00:45:00   NaN   NaN   NaN
2017-01-01 01:00:00   3.0   4.0   5.0
2017-01-01 01:15:00   NaN   NaN   NaN
2017-01-01 01:30:00   NaN   NaN   NaN
2017-01-01 01:45:00   NaN   NaN   NaN
2017-01-01 02:00:00   6.0   7.0   8.0
2017-01-01 02:15:00   NaN   NaN   NaN
2017-01-01 02:30:00   NaN   NaN   NaN
2017-01-01 02:45:00   NaN   NaN   NaN
2017-01-01 03:00:00   9.0  10.0  11.0
2017-01-01 03:15:00   NaN   NaN   NaN
2017-01-01 03:30:00   NaN   NaN   NaN
2017-01-01 03:45:00   NaN   NaN   NaN
2017-01-01 04:00:00  12.0  13.0  14.0
                      a   b   c
2017-01-01 00:00:00   0   1   2
2017-01-01 00:15:00   0   1   2
2017-01-01 00:30:00   0   1   2
2017-01-01 00:45:00   0   1   2
2017-01-01 01:00:00   3   4   5
2017-01-01 01:15:00   3   4   5
2017-01-01 01:30:00   3   4   5
2017-01-01 01:45:00   3   4   5
2017-01-01 02:00:00   6   7   8
2017-01-01 02:15:00   6   7   8
2017-01-01 02:30:00   6   7   8
2017-01-01 02:45:00   6   7   8
2017-01-01 03:00:00   9  10  11
2017-01-01 03:15:00   9  10  11
2017-01-01 03:30:00   9  10  11
2017-01-01 03:45:00   9  10  11
2017-01-01 04:00:00  12  13  14
                      a   b   c
2017-01-01 00:00:00   0   1   2
2017-01-01 00:15:00   3   4   5
2017-01-01 00:30:00   3   4   5
2017-01-01 00:45:00   3   4   5
2017-01-01 01:00:00   3   4   5
2017-01-01 01:15:00   6   7   8
2017-01-01 01:30:00   6   7   8
2017-01-01 01:45:00   6   7   8
2017-01-01 02:00:00   6   7   8
2017-01-01 02:15:00   9  10  11
2017-01-01 02:30:00   9  10  11
2017-01-01 02:45:00   9  10  11
2017-01-01 03:00:00   9  10  11
2017-01-01 03:15:00  12  13  14
2017-01-01 03:30:00  12  13  14
2017-01-01 03:45:00  12  13  14
2017-01-01 04:00:00  12  13  14
</code></pre>

<h4 id="toc_61">时期重采样 - Period</h4>

<pre><code class="language-python">prng = pd.period_range(&#39;2016&#39;,&#39;2017&#39;,freq = &#39;M&#39;)
ts = pd.Series(np.arange(len(prng)), index = prng)
print(ts)

#print(ts.resample(&#39;3M&#39;).sum())  
# 降采样
print(ts.resample(&#39;15D&#39;).ffill())  # 升采样

</code></pre>

<pre><code class="language-text">2016-01     0
2016-02     1
2016-03     2
2016-04     3
2016-05     4
2016-06     5
2016-07     6
2016-08     7
2016-09     8
2016-10     9
2016-11    10
2016-12    11
2017-01    12
Freq: M, dtype: int32
2016-01-01     0
2016-01-16     0
2016-01-31     0
2016-02-15     1
2016-03-01     2
2016-03-16     2
2016-03-31     2
2016-04-15     3
2016-04-30     3
2016-05-15     4
2016-05-30     4
2016-06-14     5
2016-06-29     5
2016-07-14     6
2016-07-29     6
2016-08-13     7
2016-08-28     7
2016-09-12     8
2016-09-27     8
2016-10-12     9
2016-10-27     9
2016-11-11    10
2016-11-26    10
2016-12-11    11
2016-12-26    11
2017-01-10    12
2017-01-25    12
Freq: 15D, dtype: int3gou
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/02/21</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%B8%B8%E7%94%A8%E5%BA%93.html'>常用库</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
      

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>分类目录</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90.html"><strong>数据分析</strong></a>
        
            <a href="ML&DL.html"><strong>ML&DL</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>最近文章</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15822402376673.html">2.2 补充梯度下降理解</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15822402376778.html">1.1 机器学习</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15822394457187.html">淘宝用户行为分析</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15822375587081.html">4. excel常见函数</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15822373698224.html">1. 认识excel</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>

              <div id="site-categories" class="side-item">
              <div class="side-header">
                <h2>联系我</h2>
              </div>
            </div>

            <div id="site-info" class="site-info">
              
               
                <!--
                     <h1>Ryanhuo</h1> 
                     <div class="site-des">My Blog 2.0</div>-->
                <div class="social">
     
     
     
     
     
     
     
     
     
     <a target="_blank" class="github" target="_blank" href="https://github.com/Ryanhuo" title="GitHub">GitHub</a>
     <a target="_blank" class="email" href="mailto:ryan97916@outlook.com" title="Email">Email</a>
       <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
       
      </div>
       <div class="social">  
                <img src="asset/img/公众号.jpg" alt="公众号二维码">
              </div>
              </div>

            
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2020
Powered by <a target="_blank" href="http://ryanhuo.github.io">Ryan</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>



  














<style type="text/css">
figure{margin: 0;padding: 0;}
figcaption{text-align:center;}

/* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background:#b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #F7F7F7;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>



  </body>
</html>
