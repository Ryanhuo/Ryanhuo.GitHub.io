<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Ryanhuo]]></title>
  <link href="ryanhuo.github.io/atom.xml" rel="self"/>
  <link href="ryanhuo.github.io/"/>
  <updated>2020-02-26T22:31:29+08:00</updated>
  <id>ryanhuo.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[2.2 补充梯度下降理解]]></title>
    <link href="ryanhuo.github.io/15822402376673.html"/>
    <updated>2020-02-21T07:10:37+08:00</updated>
    <id>ryanhuo.github.io/15822402376673.html</id>
    <content type="html"><![CDATA[
<pre><code class="language-python">from matplotlib import pyplot as plt
import numpy as np
from matplotlib.patches import Polygon
</code></pre>

<h2 id="toc_0">导数</h2>

<blockquote>
<p>引入</p>

<ul>
<li>\(平均速度=\frac{位移}{时间}\)</li>
</ul>
</blockquote>

<pre><code class="language-python">plt.figure(figsize=(15,8),dpi=80)
x=np.linspace(0,10,num=100)
y=x**2
plt.plot(x,y)

plt.xlabel(&#39;t&#39;)
plt.ylabel(&#39;S&#39;)
x0=2
y0=4
plt.plot([x0, x0,], [0, y0,], &#39;k--&#39;, linewidth=2.5,color=&#39;y&#39;)
#plt.scatter([x0, ], [y0, ], s=50, color=&#39;r&#39;)

x1=8
y1=64
plt.plot([x1, x1,], [0, y1,], &#39;k--&#39;, linewidth=2,color=&#39;y&#39;)

xtick_labels = [&#39;t&#39;,&#39;u&#39;]
plt.xticks([x0,x1],xtick_labels)
#plt.scatter([x0, ], [y0, ], s=50, color=&#39;r&#39;)
plt.annotate(s=&#39;(t,$f(t)$)&#39;,xy=(2,4) ,xycoords=&#39;data&#39;,xytext=(2,3), fontsize=12)
plt.annotate(s=&#39;(t,$f(t)$)&#39;,xy=(8,64) ,xycoords=&#39;data&#39;,xytext=(8,60), fontsize=12)
plt.text(3,40,r&#39;$v=\frac{f(u)-f(t)}{u-t}$&#39;,fontdict={&#39;size&#39;: 16, &#39;color&#39;: &#39;b&#39;})
plt.show()
</code></pre>

<p><img src="media/15822402376673/output_2_0.png" alt="png"/></p>

<blockquote>
<ul>
<li>h=u-t</li>
<li>当t与u无限接近时，h无限接近于0，即瞬时速度</li>
</ul>
</blockquote>

<pre><code class="language-python">plt.figure(figsize=(15,8),dpi=80)
x=np.arange(0,10,0.1)
y=x**2
plt.plot(x,y)



plt.xlabel(&#39;t&#39;)
plt.ylabel(&#39;S&#39;)
x0=2
y0=4
plt.plot([x0, x0,], [0, y0,], &#39;k--&#39;, linewidth=2.5,color=&#39;y&#39;)
#plt.scatter([x0, ], [y0, ], s=50, color=&#39;r&#39;)

x1=2.5
y1=2.5*2.5
plt.plot([x1, x1,], [0, y1,], &#39;k--&#39;, linewidth=2,color=&#39;y&#39;)

xtick_labels = [&#39;x&#39;,&#39;x+h&#39;]
plt.xticks([x0,x1],xtick_labels)


x2=np.arange(0,10,0.1)
y2= 2*x
plt.plot(x2,y2,linestyle=&#39;--&#39;)

plt.text(3,40,r&#39;$\lim_{x \to h}=\frac{f(x+h)-f(x)}{h}$&#39;,fontdict={&#39;size&#39;: 16, &#39;color&#39;: &#39;b&#39;})
plt.show()
</code></pre>

<p><img src="media/15822402376673/output_4_0.png" alt="png"/></p>

<p>\[f&#39;(x)=\lim{\Delta x \to 0}\frac{f(x+\Delta x)-f(x)}{\Delta x}\]</p>

<ul>
<li>\(\Delta x=x_新-x\)</li>
<li>\(\Delta y=y_新-y\)<br/>
同理可得<br/>
\[f&#39;(x)=\lim{\Delta x \to 0}\frac{\Delta y}{\Delta x}\]</li>
</ul>

<blockquote>
<p>假设x小到以至于几乎注意不到，用\(dx\)，表示x中十分微小得变化</p>
</blockquote>

<h2 id="toc_1">偏导</h2>

<p>一个多变量的函数的偏导数，就是它关于其中一个变量的导数而保持其他变量恒定（相对于全导数，在其中所有变量都允许变化）。偏导数在向量分析和微分几何中是很有用的。</p>

<blockquote>
<p><strong>例子</strong><br/>
圆锥的体积\(V(r,h)=\frac{r^2\pi h }{3}\)</p>

<ul>
<li>\(\frac{\partial V}{\partial r}=\frac{2 \pi r h }{3}\)    高度固定，体积变化率</li>
<li>\(\frac{\partial V}{\partial r}=\frac{\pi r ^2 }{3}\)    半径固定，体积变化率</li>
</ul>
</blockquote>

<h2 id="toc_2">微分</h2>

<h3 id="toc_3">求和</h3>

<pre><code class="language-python">plt.figure(figsize=(15,8),dpi=80)
x=np.arange(0,12,3)
y=x**2
plt.bar(x,y,width=4)

xtick_labels = [&#39;t{}&#39;.format(i) for i in x]
plt.xticks(x,xtick_labels)
plt.xlabel(&#39;t&#39;)
plt.ylabel(&#39;v&#39;)
plt.show()
</code></pre>

<p><img src="media/15822402376673/output_8_0.png" alt="png"/></p>

<p>\[总位移=\sum_{j=1}^{n}v_j(t_j-t{j-1})\]</p>

<h3 id="toc_4">积分</h3>

<blockquote>
<p>考虑v是t得连续函数时</p>
</blockquote>

<pre><code class="language-python">plt.figure(figsize=(15,8),dpi=80)
x=np.arange(0,10,1)
y=x**2

plt.plot(x,y)
plt.bar(x,y,width=1,alpha=0.3,color=&#39;g&#39;)

xtick_labels = [&#39;t{}&#39;.format(i) for i in x]
plt.xticks(x,xtick_labels)
plt.xlabel(&#39;t&#39;)
plt.ylabel(&#39;v&#39;)


x0=4.5
y0=25
plt.plot([x0, x0,], [0, y0,], &#39;k--&#39;, linewidth=2,color=&#39;r&#39;)
#plt.scatter([x0, ], [y0, ], s=50, color=&#39;r&#39;)

x1=5.5
y1=25
plt.plot([x1, x1,], [0, y1,], &#39;k--&#39;, linewidth=2,color=&#39;r&#39;)

x2=5
y2=25
plt.plot([x2, x2,], [0, y2,], &#39;k--&#39;, linewidth=3,color=&#39;r&#39;)

plt.annotate(s=&#39;p&#39;,xy=(4.5,0) ,xycoords=&#39;data&#39;,xytext=(4.5,-3), fontsize=12,color=&#39;r&#39;)
plt.annotate(s=&#39;q&#39;,xy=(5.5,0) ,xycoords=&#39;data&#39;,xytext=(5.5,-3), fontsize=12,color=&#39;r&#39;)
plt.annotate(s=&#39;c&#39;,xy=(5,25) ,xycoords=&#39;data&#39;,xytext=(5,30), fontsize=12,color=&#39;r&#39;)


plt.text(3,40,r&#39;$S\approx\sum_{j=1}^n{v(c_j)(t_j-t_{j-1})}$&#39;,fontdict={&#39;size&#39;: 16, &#39;color&#39;: &#39;y&#39;})
plt.show()
</code></pre>

<p><img src="media/15822402376673/output_11_0.png" alt="png"/></p>

<h4 id="toc_5">定义</h4>

<p>\[\int_a^bf(x)\mathrm{d}x\]</p>

<ul>
<li>函数从a到b的积分</li>
<li>a，b为积分极限</li>
<li>\(dx\)说明水平轴的变量</li>
</ul>

<p>\[\int_a^bf(x)\mathrm{d}x=\lim_{mesh \to 0}\sum_{j=1}^n{v(c_j)(t_j-t_{j-1})}\]</p>

<ul>
<li>\(c_j\)为\(x_1,x_2\)区间内任意值</li>
<li>mesh表示\((x_1-x_0)\),\((x_2-x_1)\)间隔值</li>
</ul>

<blockquote>
<p>区分：</p>

<p>位移：\(\int_a^b v(t)\mathrm{d}x\)</p>

<p>路程：\(\int_a^b ｜v(t)｜\mathrm{d}x\)</p>
</blockquote>

<h4 id="toc_6">计算</h4>

<pre><code class="language-python">def f(x):
    return np.exp(x*x)
x=np.linspace(0,3,num=100)
fig,ax=plt.subplots(figsize=(10,5))#绘制8*5的图形
plt.plot(x,f(x))
a,b=0,2#积分域0到1
ix=np.linspace(a,b)
iy=f(ix)
verts=[(a,0)]+list(zip(ix,iy))+[(b,0)]#表示积分的区域
#使用Polygon函数填充，表面颜色是0.7，边沿颜色是0.5
poly=Polygon(verts,facecolor=&#39;0.7&#39;,edgecolor=&#39;0.5&#39;)
ax.add_patch(poly)#将填充面积添加到图表里
plt.text(0.5*(a+b),1,r&#39;$\int_&#39;+str(a)+&#39;^&#39;+str(b)+&#39; f(x)\mathrm{d}x$&#39;,horizontalalignment=&#39;center&#39;,fontsize=20)
#添加LaTex的标量名称需要用2个$符号包含在内才行,这标明是积分，水平居中对齐，坐标是（0.5，1），字体20
plt.xlabel(&#39;$x$&#39;)
plt.ylabel(&#39;$f(x)=x^2$&#39;)
ax.set_xticks((a,b))#x轴刻度位置
ax.set_xticklabels((&#39;$&#39;+str(a)+&#39;$&#39;,&#39;$&#39;+str(b)+&#39;$&#39;))#内容
plt.show()
</code></pre>

<p><img src="media/15822402376673/output_15_0.png" alt="png"/></p>

<ul>
<li>在[0,2]区间内等分成n份<br/>
此时：<br/>
\[[x_{j-1},x_j]=[\frac{2(j-1)}{n},\frac{2j}{n}]\]<br/>
\[c_j=x_j=\frac{2j}{n}\]</li>
</ul>

<p>\[\int_0^2 x^2\mathrm{d}x=\lim_{最大区间 \to 0}\sum_{j=1}^n f(j)(x_j-x_{j-1} )=\lim_{n \to \infty}\frac{4(n+1)(2n+1)}{3n^2} =\frac{8}{3}\]</p>

<h2 id="toc_7">梯度</h2>

<p>（多变微分的一般化）</p>

<p>\[J(\Theta)=5\theta_1+2\theta_2-12\theta_3\]</p>

<p>\[\nabla J(\Theta)=&lt;\frac{\partial J}{\partial \theta_1},\frac{\partial J}{\partial \theta_2},\frac{\partial J}{\partial \theta_3}&gt;=&lt;5,2,-12&gt;\]</p>

<ul>
<li>单变量梯度：函数的微分，即斜率</li>
<li>多变量梯度： 向量，指出函数给定点上升最快的方向</li>
<li>\[\nabla f(a)\]称点a的梯度，向量场</li>
</ul>

<h2 id="toc_8">梯度下降法</h2>

<p>\[\theta_1=\theta_0-\alpha \nabla J(\Theta)\]</p>

<ul>
<li>J是关于\(\theta\)的函数</li>
<li>初始位置为\(\theta_0\)</li>
<li>从该点出发走到最低点（反梯度方向）</li>
<li>\(\alpha\)为步长，学习率</li>
</ul>

<h3 id="toc_9">梯度下降法求解线性回归</h3>

<p><strong>代价函数</strong><br/>
\[J(\Theta)=\frac{1}{2m}\sum_{i=1}^m(h_{\theta}(x^{(i)})-y^{(i)})^2\]</p>

<ul>
<li>$\frac{1}{2}\(用于抵消常量<br/>
\)\(h_{\theta}(x^{(i)})=\theta_0+\theta_1 x^{(i)}\)$</li>
</ul>

<p>得到代价函数：</p>

<p>\[J(\Theta)=\frac{1}{2m}\sum_{i=1}^m(\theta_0+\theta_1 x^{(i)}-y^{(i)})^2\]</p>

<p>\[\theta_0:\frac{\partial J}{\partial \theta_0}\frac{1}{m}\sum_{i=1}^m(\theta_0+\theta_1 x^{(i)}-y^{(i)})\]<br/>
\[\theta_1:\frac{\partial J}{\partial \theta_1}\frac{1}{m}\sum_{i=1}^m(\theta_0+\theta_1 x^{(i)}-y^{(i)})*x^{(i)}\]</p>

<pre><code class="language-python">x_train = np.array([[2.5], [3.5], [6.3], [9.9], [9.91], [8.02],
                    [4.5], [5.5], [6.23], [7.923], [2.941], [5.02],
                    [6.34], [7.543], [7.546], [8.744], [9.674], [9.643],
                    [5.33], [5.31], [6.78], [1.01], [9.68],
                    [9.99], [3.54], [6.89], [10.9]], dtype=np.float32)

y_train = np.array([[3.34], [3.86], [5.63], [7.78], [10.6453], [8.43],
                    [4.75], [5.345], [6.546], [7.5754], [2.35654], [5.43646],
                    [6.6443], [7.64534], [7.546], [8.7457], [9.6464], [9.74643],
                    [6.32], [6.42], [6.1243], [1.088], [10.342],
                    [9.24], [4.22], [5.44], [9.33]], dtype=np.float32)

y_data = np.array([[2.5], [3.5], [6.3], [9.9], [9.91], [8.02],
                    [4.5], [5.5], [6.23], [7.923], [2.941], [5.02],
                    [6.34], [7.543], [7.546], [8.744], [9.674], [9.643],
                    [5.33], [5.31], [6.78], [1.01], [9.68],
                    [9.99], [3.54], [6.89], [10.9]], dtype=np.float32)

plt.plot(x_train, y_train, &#39;bo&#39;,label=&#39;real&#39;)
plt.plot(x_train, y_data, &#39;r-&#39;,label=&#39;estimated&#39;)
plt.show()
</code></pre>

<p><img src="media/15822402376673/output_20_0.png" alt="png"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[1.1 机器学习]]></title>
    <link href="ryanhuo.github.io/15822402376778.html"/>
    <updated>2020-02-21T07:10:37+08:00</updated>
    <id>ryanhuo.github.io/15822402376778.html</id>
    <content type="html"><![CDATA[
<h1 id="toc_0">机器学习的应用</h1>

<ul>
<li><strong>数据库挖掘。</strong>机器学习被用于数据挖掘的原因之一是网络和自动化技术的增长，这意味着，我们有史上最大的数据集比如说，大量的硅谷公司正在收集<strong>web</strong>上的单击数据，也称为点击流数据，并尝试使用机器学习算法来分析数据，更好的了解用户，并为用户提供更好的服务。这在硅谷有巨大的市场。再比如，医疗记录。随着自动化的出现，我们现在有了电子医疗记录。如果我们可以把医疗记录变成医学知识，我们就可以更好地理解疾病。再如，</li>
<li><strong>计算生物学。</strong>还是因为自动化技术，生物学家们收集的大量基因数据序列、<strong>DNA</strong>序列和等等，机器运行算法让我们更好地了解人类基因组，大家都知道这对人类意味着什么。再比如，工程方面，在工程的所有领域，我们有越来越大、越来越大的数据集，我们试图使用学习算法，来理解这些数据。另外，</li>
<li><strong>机械应用</strong>。有些人不能直接操作。例如，我已经在无人直升机领域工作了许多年。我们不知道如何写一段程序让直升机自己飞。我们唯一能做的就是让计算机自己学习如何驾驶直升机。</li>
<li><strong>手写识别。</strong>现在我们能够非常便宜地把信寄到这个美国甚至全世界的原因之一就是当你写一个像这样的信封，一种学习算法已经学会如何读你信封，它可以自动选择路径，所以我们只需要花几个美分把这封信寄到数千英里外。</li>
</ul>

<h1 id="toc_1">机器学习</h1>

<p>在机器学习的历史上，一共出现了两种定义。</p>

<ul>
<li><p>1956 年，开发了西洋跳棋 AI 程序的 Arthur Samuel 在标志着人工智能学科诞生的达特茅斯会议上定义了 “机器学习” 这个词，定义为，“在没有明确设置的情况下，使计算机具有学习能力的研究领域”。</p></li>
<li><p>1997 年，Tom Mitchell 提供了一个更现代的定义：“如果用 P 来测量程序在任务 T 中性能。若一个程序通过利用经验 E 在 T 任务中获得了性能改善，则我们就说关于任务 T 和 性能测量 P ，该程序对经验 E 进行了学习。”</p></li>
</ul>

<p>例如：玩跳棋。 </p>

<p>E = 玩很多盘跳棋游戏的经验</p>

<p>T = 玩跳棋的任务。</p>

<p>P = 程序将赢得下一场比赛的概率。</p>

<h1 id="toc_2">分类</h1>

<p>一般来说，任何机器学习问题都可以分配到两大类中的一个：</p>

<p>有监督学习 supervised learning 和无监督学习 unsupervised learning。</p>

<p>简单的说，监督学习就是我们教计算机去做某件事情，无监督学习是我们让计算机自己学习。</p>

<p><img src="media/15822402376778/machine-learning.png" alt="img"/></p>

<p align='center'>
<img src='../images/machine-learning.png'>
</p>

<h2 id="toc_3">监督学习</h2>

<p>在监督式学习中，首先有一个数据集，并且已知正确的输出是什么，且输入和输出存在关联。 监督学习问题分为“回归 Regression”和“分类 Classification”问题。</p>

<p>在回归问题中，我们试图预测连续输出中的结果，这意味着我们试图将输入变量映射到某个连续函数。例如给定一个人的照片，根据照片预测年龄，这就是一个回归的问题。</p>

<p><img src="Week1_%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.assets/Linear_regression.svg" alt="img"/></p>

<p>在分类问题中，我们试图预测离散输出中的结果。换句话说，我们试图将输入变量映射到离散类别中。例如给予患有肿瘤的患者，我们必须预测肿瘤是恶性的还是良性的。</p>

<p><img src="media/15822402376778/Kernel_Machine.svg" alt="img"/></p>

<h2 id="toc_4">无监督学习</h2>

<p>无监督学习使我们能够很少或根本不知道我们的结果应该是什么样子。我们可以从数据中得出结构，我们不一定知道变量的影响。 我们可以通过基于数据中变量之间的关系对数据进行聚类来推导出这种结构。 在无监督学习的情况下，没有基于预测结果的反馈。无监督学习可以分为“聚类”和“非聚类”。</p>

<p>聚类：获取1,000,000个不同基因的集合，并找到一种方法将这些基因自动分组成不同变量的相似或相关的组，例如寿命，位置，角色等。 </p>

<p><img src="media/15822402376778/KMeans-Gaussian-data.svg" alt="img"/></p>

<p>非聚类：“鸡尾酒会算法”，允许您在混乱的环境中查找结果。 （即在鸡尾酒会上识别来自声音网格的个人声音和音乐）。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[淘宝用户行为分析]]></title>
    <link href="ryanhuo.github.io/15822394457187.html"/>
    <updated>2020-02-21T06:57:25+08:00</updated>
    <id>ryanhuo.github.io/15822394457187.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15822394457187/20191113162310.png" alt=""/></p>

<h2 id="toc_0">理解数据</h2>

<p>UserBehavior是阿里巴巴提供的一个淘宝用户行为数据集，数据集包含了2017年11月25日至2017年12月3日之间，有行为的约一百万随机用户的所有行为（行为包括点击、购买、加购、喜欢）。（数据来源：<a href="https://tianchi.aliyun.com/dataset/dataDetail?dataId=649%EF%BC%89">https://tianchi.aliyun.com/dataset/dataDetail?dataId=649）</a></p>

<table>
<thead>
<tr>
<th>列名称</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>用户ID</td>
<td>整数类型，序列化后的用户ID</td>
</tr>
<tr>
<td>商品ID</td>
<td>整数类型，序列化后的商品ID</td>
</tr>
<tr>
<td>商品类目ID</td>
<td>整数类型，序列化后的商品所属类目ID</td>
</tr>
<tr>
<td>行为类型</td>
<td>字符串，枚举类型，包括(&#39;pv&#39;, &#39;buy&#39;, &#39;cart&#39;, &#39;fav&#39;)</td>
</tr>
<tr>
<td>时间戳</td>
<td>行为发生的时间戳</td>
</tr>
</tbody>
</table>

<p>其中行为类型下对应行为为:</p>

<table>
<thead>
<tr>
<th>行为类型</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>pv</td>
<td>商品详情页pv，等价于点击</td>
</tr>
<tr>
<td>buy</td>
<td>商品购买</td>
</tr>
<tr>
<td>cart</td>
<td>将商品加入购物车</td>
</tr>
<tr>
<td>fav</td>
<td>收藏商品</td>
</tr>
</tbody>
</table>

<p>总计100,150,807条数据集，本文截取397118条数据作为数据集进行分析。</p>

<h2 id="toc_1">提出问题</h2>

<h3 id="toc_2">AARRR模型</h3>

<p>采用AARRR漏斗模型拆解用户进入APP后的每一步行为。AARRR模型是根据用户使用产品全流程的不同阶段进行划分的，针对每一环节的用户流失情况分析出不同环节的优化优先级，主要通过以下个各阶段来进行分析：</p>

<p><img src="media/15822394457187/20191113162323.png" alt=""/></p>

<p>各阶段主要包括的指标有：</p>

<ul>
<li>用户获取
<ol>
<li>渠道到达量（曝光率）</li>
<li>渠道转化率</li>
<li>渠道ROI，投资回报率，利润/投资</li>
</ol></li>
</ul>

<p>（日应用下载量，日新增用户数，获客成本，一次会话用户数占比）</p>

<ul>
<li>用户活跃
<ol>
<li>活跃用户占比</li>
<li>用户会话session次数</li>
<li>用户访问时长</li>
<li>用户平均访问次数</li>
</ol></li>
<li>用户留存
<ol>
<li>次日/7日留存率</li>
</ol></li>
<li>营收
<ol>
<li>付费用户数</li>
<li>付费用户占比</li>
<li>ARPU：某段时间内每位用户平均收入</li>
<li>客单价：销售总额/顾客总数（没有时间维度）</li>
<li>LTV：用户生命周期价值</li>
<li>LTV=ARPU*1/流失率</li>
</ol></li>
<li>传播
<ol>
<li>k因子：每个用户带来几个新用户</li>
<li>用户分享率</li>
<li>活动/邀请曝光量</li>
</ol></li>
</ul>

<h3 id="toc_3">RFM模型</h3>

<p><img src="media/15822394457187/20191113162329.png" alt=""/></p>

<p>RFM模型是衡量客户价值和客户创利能力的重要工具和手段。模型通过一个客户的近期购买行为、购买的总体频率以及花了多少钱3项指标来描述该客户的价值状况。</p>

<ul>
<li>最近一次消费 (Recency)</li>
<li>消费频率 (Frequency)</li>
<li>消费金额 (Monetary)</li>
</ul>

<p>根据三个维度指标数据，建立度量机制可将用户数据组合得到价值客户的体系。</p>

<ul>
<li>重要价值客户（111）：最近消费时间近、消费频次和消费金额都很高，必须是VIP啊！</li>
<li>重要保持客户（011）：最近消费时间较远，但消费频次和金额都很高，说明这是个一段时间没来的忠诚客户，我们需要主动和他保持联系。</li>
<li>重要发展客户（101）：最近消费时间较近、消费金额高，但频次不高，忠诚度不高，很有潜力的用户，必须重点发展。</li>
<li>重要挽留客户（001）：最近消费时间较远、消费频次不高，但消费金额高的用户，可能是将要流失或者已经要流失的用户，应当基于挽留措施。</li>
</ul>

<h3 id="toc_4">本文分析结构</h3>

<p>本文根据上述模型及电商中常用指标，建立如下分析结构体系：   <a href="%E9%99%84%E4%BB%B6%E6%B7%98%E5%AE%9D%E7%94%A8%E6%88%B7%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90.xmind">淘宝用户行为分析.xmind</a> </p>

<p><img src="media/15822394457187/20191113162337.png" alt=""/></p>

<h2 id="toc_5">数据清洗</h2>

<h3 id="toc_6">选择子集，列名重复，删除重复值，缺失值处理</h3>

<p>mysql中导入，未出现异常数据，结果总计397290</p>

<pre><code class="language-text">select COUNT(*) from userbehaivor;
</code></pre>

<h3 id="toc_7">一致化处理</h3>

<p>将时间戳转化为可识别日期函数</p>

<pre><code class="language-text">ALTER TABLE UserBehavior ADD COLUMN datentime TIMESTAMP(0) NULL;
UPDATE UserBehavior
SET datentime = FROM_UNIXTIME(timestamps);

ALTER TABLE UserBehavior ADD COLUMN dates CHAR(10) NULL;
UPDATE UserBehavior
SET dates = SUBSTRING(datentime FROM 1 FOR 10);

ALTER TABLE UserBehavior ADD COLUMN time CHAR(10) NULL;
UPDATE UserBehavior
SET time = SUBSTRING(datentime FROM 12 FOR 8);

ALTER TABLE UserBehavior ADD COLUMN hours CHAR(10) NULL;
UPDATE UserBehavior SET hours = SUBSTRING(datentime FROM 12 FOR 2);
</code></pre>

<h3 id="toc_8">结果排序，异常值处理</h3>

<p>将结果排序未有异样，本数据集包含了2017年11月25日至2017年12月3日之间数据，查看时间值。</p>

<pre><code class="language-text">select max(dates),min(dates) from userbehavior;
</code></pre>

<p>结果显示出现异常值。</p>

<table>
<thead>
<tr>
<th>max(dates)</th>
<th>MIN(dates)</th>
</tr>
</thead>

<tbody>
<tr>
<td>2017-12-03</td>
<td>2017-09-11</td>
</tr>
</tbody>
</table>

<p>对超过时间范围数据进行删除。</p>

<pre><code class="language-text">DELETE  from userbehavior where datentime &lt;&#39;2017-11-25 00:00:00&#39; or datentime &gt; &#39;2017-12-04 00:00:00&#39;;
</code></pre>

<p>共删除172条数据，总计397118条数据。清洗完数据如图所示</p>

<p><img src="media/15822394457187/20191113162345.png" alt=""/></p>

<h2 id="toc_9">模型构建</h2>

<h3 id="toc_10">流量指标</h3>

<h5 id="toc_11">1. 总计PV，UV，PV/UV</h5>

<pre><code class="language-text">SELECT  COUNT(DISTINCT 用户id)AS &#39;UV&#39;,SUM(case WHEN 行为类型=&#39;pv&#39;then 1 else 0 end) as &#39;PV&#39;,
(SUM(case WHEN 行为类型=&#39;pv&#39;then 1 else 0 end)/COUNT(DISTINCT 用户id)) as &#39;PV/UV&#39;FROM userbehavior;
</code></pre>

<table>
<thead>
<tr>
<th>UV</th>
<th>PV</th>
<th>PV/UV</th>
</tr>
</thead>

<tbody>
<tr>
<td>3879</td>
<td>356827</td>
<td>91.9894</td>
</tr>
</tbody>
</table>

<h5 id="toc_12">2. 日期维度下PV，UV，PV/UV</h5>

<pre><code class="language-text">SELECT  COUNT(DISTINCT 用户id)AS &#39;UV&#39;,
SUM(case WHEN 行为类型=&#39;pv&#39;then 1 else 0 end) as &#39;PV&#39;,
(SUM(case WHEN 行为类型=&#39;pv&#39;then 1 else 0 end)/COUNT(DISTINCT 用户id)) 
as &#39;PV/UV&#39;,dates FROM userbehavior GROUP BY dates;
</code></pre>

<p><img src="media/15822394457187/20191113162354.png" alt=""/></p>

<h5 id="toc_13">3. 时间维度下PV，UV，PV/UV</h5>

<pre><code class="language-text">SELECT  COUNT(DISTINCT 用户id)AS &#39;UV&#39;,
SUM(case WHEN 行为类型=&#39;pv&#39;then 1 else 0 end) as &#39;PV&#39;,
(SUM(case WHEN 行为类型=&#39;pv&#39;then 1 else 0 end)/COUNT(DISTINCT 用户id))
as &#39;PV/UV&#39;, hours FROM userbehavior GROUP BY hours;
</code></pre>

<p><img src="media/15822394457187/20191113162358.png" alt=""/></p>

<h5 id="toc_14">4. 跳失率</h5>

<p>跳失率，是指显示顾客通过相应入口进入，只访问了一个页面就离开的访问次数占该页面总访问次数的比例。</p>

<pre><code class="language-text">select COUNT(DISTINCT 用户id) as 点击用户数 ,count(用户id) as 总访问用户数, COUNT(DISTINCT 用户id)/COUNT(用户id) as 跳失率 
from userbehavior where 行为类型=&#39;pv&#39;
</code></pre>

<p><img src="media/15822394457187/20191113162403.png" alt=""/></p>

<h3 id="toc_15">用户行为指标</h3>

<h5 id="toc_16">1. 总计点击，收藏，添加购物车，购买用户情况</h5>

<pre><code class="language-text">select
SUM(case when 行为类型=&#39;pv&#39; then 1 else 0 end) as &#39;点击用户&#39;,
SUM(case when 行为类型=&#39;fav&#39; then 1 else 0 end) as &#39;收藏用户&#39;,
SUM(case when 行为类型=&#39;cart&#39; then 1 else 0 end) as &#39;添加购物车用户&#39;,
SUM(case when 行为类型=&#39;buy&#39; then 1 else 0 end) as &#39;购买用户&#39;
from userbehavior


</code></pre>

<p><img src="media/15822394457187/20191113162408.png" alt=""/></p>

<h5 id="toc_17">2. 日期维度下点击，收藏，添加购物车，购买用户情况</h5>

<pre><code class="language-text">select
SUM(case when 行为类型=&#39;pv&#39; then 1 else 0 end) as &#39;点击用户&#39;,
SUM(case when 行为类型=&#39;fav&#39; then 1 else 0 end) as &#39;收藏用户&#39;,
SUM(case when 行为类型=&#39;cart&#39; then 1 else 0 end) as &#39;添加购物车用户&#39;,
SUM(case when 行为类型=&#39;buy&#39; then 1 else 0 end) as &#39;购买用户&#39;,
dates
from userbehavior group by dates


</code></pre>

<p><img src="media/15822394457187/20191113162423.png" alt=""/></p>

<h5 id="toc_18">3. 时间维度下点击，收藏，添加购物车，购买用户情况</h5>

<pre><code class="language-text">select
SUM(case when 行为类型=&#39;pv&#39; then 1 else 0 end) as &#39;点击用户&#39;,
SUM(case when 行为类型=&#39;fav&#39; then 1 else 0 end) as &#39;收藏用户&#39;,
SUM(case when 行为类型=&#39;cart&#39; then 1 else 0 end) as &#39;添加购物车用户&#39;,
SUM(case when 行为类型=&#39;buy&#39; then 1 else 0 end) as &#39;购买用户&#39;,
hours
from userbehavior group by hours


</code></pre>

<p><img src="media/15822394457187/20191113162430.png" alt=""/></p>

<h5 id="toc_19">4. 购买数前十用户行为细分</h5>

<pre><code class="language-text">select
DISTINCT 用户id,
SUM(case when 行为类型=&#39;pv&#39; then 1 else 0 end) as &#39;点击用户&#39;,
SUM(case when 行为类型=&#39;fav&#39; then 1 else 0 end) as &#39;收藏用户&#39;,
SUM(case when 行为类型=&#39;cart&#39; then 1 else 0 end) as &#39;添加购物车用户&#39;,
SUM(case when 行为类型=&#39;buy&#39; then 1 else 0 end) as &#39;购买用户&#39;
from userbehavior group by 用户id order by 购买用户 desc limit 10


</code></pre>

<p><img src="media/15822394457187/20191113162436.png" alt=""/></p>

<h3 id="toc_20">产品销售指标</h3>

<h5 id="toc_21">1. 商品销售情况</h5>

<pre><code class="language-text">SELECT
商品id,
SUM(case when 行为类型=&#39;buy&#39; then 1 else 0 end ) as &#39;购买数量&#39;
from userbehavior group by 商品id 
having 购买数量&gt;0
ORDER BY 购买数量 desc


</code></pre>

<p><img src="media/15822394457187/20191113162441.png" alt=""/></p>

<h5 id="toc_22">2.  商品类目销售情况</h5>

<pre><code class="language-text">SELECT
    商品类目id,
    SUM( CASE WHEN 行为类型 = &#39;buy&#39; THEN 1 ELSE 0 END) AS &#39;购买数量&#39;
FROM userbehavior GROUP BY 商品类目id
HAVING 购买数量 &gt;0  ORDER BY 购买数量 DESC


</code></pre>

<p><img src="media/15822394457187/20191113162446.png" alt=""/></p>

<h5 id="toc_23">3.  复购率</h5>

<pre><code class="language-text">#建立视图窗口
CREATE VIEW b
as 
SELECT 用户id,
COUNT(行为类型) as 购买次数
from userbehavior 
where 行为类型=&#39;buy&#39;
GROUP  BY 用户id
having 购买次数&gt;1
#计算复购率
select (select count(*) from b)/(select count(DISTINCT 用户id) from userbehavior where 行为类型=&#39;buy&#39;) as &#39;复购率&#39; 
from userbehavior limit 1
# 购买次数分布情况
select `购买次数`,count(*)from b
group by 购买次数 ;


</code></pre>

<p><img src="media/15822394457187/20191113162452.png" alt=""/></p>

<p><img src="media/15822394457187/20191113162506.png" alt=""/></p>

<p><img src="media/15822394457187/20191113162513.png" alt=""/></p>

<h3 id="toc_24">客户价值指标（RFM模型）</h3>

<pre><code class="language-text">#建立r值制图
create view r as
SELECT 用户id,max(dates) AS `近期购买时间`
FROM userbehavior
WHERE (行为类型 = &#39;buy&#39;) GROUP BY 用户id

#划分r值标准视图
create view r等级划分 as
SELECT
    用户id,近期购买时间,
(case  when datediff(&#39;2017-12-04&#39;,近期购买时间)&lt;=2 then 5 
       when datediff(&#39;2017-12-04&#39;,近期购买时间)&lt;=3 then 4
       when datediff(&#39;2017-12-04&#39;,近期购买时间)&lt;=4 then 3
       when datediff(&#39;2017-12-04&#39;,近期购买时间)&lt;=6 then 2
       else 1 end) as &#39;R&#39;
FROM r;
#f值计算同视图b，建立f等级划分视图
create view F等级划分
as
select userid, 购买次数,(case  when 购买次数&lt;=2 then 1 
when 购买次数&lt;=4 then 2 
when 购买次数&lt;=8 then 3
when 购买次数&lt;=10 then 4 
else 5 end) as &#39;F&#39; from b

select r等级划分.*,f等级划分.F`,
(case
when ((r等级划分.R &gt;= 3.5847) and (f等级划分.F &gt;= 1.9972)) then &#39;重要高价值客户&#39; 
when ((r等级划分.R &lt; 3.5847) and (f等级划分.F &gt;= 1.9972)) then &#39;重要唤回客户&#39;
when ((r等级划分.R &gt;= 3.5847) and (f等级划分.F &lt; 1.9972)) then &#39;重要深耕客户&#39; 
when ((r等级划分.R &lt; 3.5847) and (f等级划分.F &lt; 1.9972)) then &#39;重要挽留客户&#39; 
end) AS `客户分类` 
from r等级划分,f等级划分` where (r等级划分.用户id` = f等级划分.用户id)


</code></pre>

<p><img src="media/15822394457187/20191113162519.png" alt=""/></p>

<pre><code class="language-text">SELECT 客户分类,count(*) as 客户数量 from rfm 
GROUP BY 客户分类
</code></pre>

<p><img src="media/15822394457187/20191113162527.png" alt=""/></p>

<h2 id="toc_25">可视化分析</h2>

<h3 id="toc_26">流量指标</h3>

<p><img src="media/15822394457187/%E5%B9%BB%E7%81%AF%E7%89%871.png" alt="幻灯片1"/></p>

<p>总时间维度下访客量达35万，合集访客数为2万人次，近平均每人次访问116次。</p>

<p><img src="media/15822394457187/%E5%B9%BB%E7%81%AF%E7%89%872.png" alt="幻灯片2"/></p>

<p>在时间维度下，每日晚20：00-22：00时间区间内，访客量，访客数以及平均访问达到日最高值，在白天时间内15：00左右的访客量，访客数以及平均访问相比较高。<br/>
<img src="media/15822394457187/%E5%B9%BB%E7%81%AF%E7%89%873.png" alt="幻灯片3"/></p>

<p>日期维度下，访客量，访客数量在12月2日及3日较高，而平均访问数量较少，说明这段时间内使用用户量较大，多次频繁操作用户较少，12月2日和3日为周末时间段即双休日下访问人数增多。同时，在12月1日周五时间点下，用户平均访问达最高值。</p>

<p><img src="media/15822394457187/%E5%B9%BB%E7%81%AF%E7%89%874.png" alt="幻灯片4"/></p>

<p>“跳失率”是指顾客通过相应入口进入，只访问了一个页面就离开的访问数占总访问次数的比例。跳失率为1.085%，跳失率较小，转化率较好。</p>

<h3 id="toc_27">用户行为指标</h3>

<p><img src="media/15822394457187/%E5%B9%BB%E7%81%AF%E7%89%875.png" alt="幻灯片5"/></p>

<p>日期维度下，2017年12月2日及3日（周末时间段）用户的购买，收藏，点击及添加购物车的次数普遍大于工作日时间段，数据时间节点有限，对于周期性的估算无法判定。</p>

<p><img src="media/15822394457187/%E5%B9%BB%E7%81%AF%E7%89%876.png" alt="幻灯片6"/></p>

<p>在时间维度下，用户在晚间（以19：00为下班时间段），用户各类行为呈上升趋势，至十点出现下滑，在白天时间中，10：00及16：00相比较各指标较高。</p>

<p><img src="media/15822394457187/%E5%B9%BB%E7%81%AF%E7%89%877.png" alt="幻灯片7"/></p>

<p>参考AARRR模型建立漏斗图，用户通过访问页面至添加购物车或收藏行为转为率为8.99%，由购物车或收藏至购买转化率达8.99%，对购物车及收藏两行为细分得到。<br/>
<img src="media/15822394457187/%E5%B9%BB%E7%81%AF%E7%89%878.png" alt="幻灯片8"/></p>

<p>用户通过访问页面至收藏行为转为率为2.79%，由收藏至购买转化率达82.61%；用户通过访问页面至添加购物车行为转为率为6.20%，由购物车至购买转化率达37.15%.发现用户通过点击至添加购物车转为虽高于收藏转化率，但购买转化率上，由收藏至购买的转化率可达82.61%而购物车的转化率仅为37.15%。<br/>
<img src="media/15822394457187/%E5%B9%BB%E7%81%AF%E7%89%879.png" alt="幻灯片9"/></p>

<p>分析购买量TOP10用户数据，用户添加购物车及收藏只达15.01%，而转化率达125.51%。购买力或购物欲较为强的这一类消费者多数不通过收藏或者购物车购买。</p>

<h3 id="toc_28">产品销售指标</h3>

<p><img src="media/15822394457187/%E5%B9%BB%E7%81%AF%E7%89%8710.png" alt="幻灯片10"/></p>

<p>产品总体复购率达到67.33%，复购水平总体较好，多数用户复购次数为2-5。<br/>
<img src="media/15822394457187/%E5%B9%BB%E7%81%AF%E7%89%8711.png" alt="幻灯片11"/></p>

<p>在商品类目销售下，商品类目为2735466，4145813，1464116的商品销售最高，最高销售次数达142次。</p>

<p><img src="media/15822394457187/%E5%B9%BB%E7%81%AF%E7%89%8712.png" alt="幻灯片12"/></p>

<p>在商品id销售下，商品id为4401268，3122135，3991727的商品销售最佳，最高销售次数为10次。</p>

<h3 id="toc_29">客户价值指标</h3>

<p><img src="media/15822394457187/%E5%B9%BB%E7%81%AF%E7%89%8713.png" alt="幻灯片13"/></p>

<p><img src="media/15822394457187/%E5%B9%BB%E7%81%AF%E7%89%8714.png" alt="幻灯片14"/></p>

<p>根据RFM模型显示，在总计1816购买客户中，重要高价值客户占比45%，占比较高，其次为重要深耕用户。</p>

<h2 id="toc_30">建议与对策</h2>

<p>针对用户行为问题使用AARRR漏斗模型进行业务分析，结合上述分析的业务指标，提出修改建议。</p>

<h3 id="toc_31">获取客户（Acquisition）</h3>

<ol>
<li>周末时间段以及每日19点起至11点的用户访问，点击，购买的较为高，大部分用户喜欢在周末或者晚间时间进行购物，可以在这些时间段开展相对一些促销活动获取用户关注。</li>
<li>淘宝作为国内电商第一平台，用户量大，可以多参与平台活动，提高曝光度，获取新用户</li>
</ol>

<h3 id="toc_32">激活用户(Activation)</h3>

<ol>
<li>相比较而言，收藏商品的用户至购买的转化率较高，可以利用相关优惠券或其他增加用户收藏商品的频率。</li>
<li>点击量较大的情况下，购买数量占比较少，说明用户花费较为多的时间在寻找商品。商家可以通过产品关键词的准确率，提高转化率。</li>
<li>数据显示，购买能力较强的用户直接购买的转化率更高，商家可以精简下单步骤，提高用户购买体验。</li>
</ol>

<h3 id="toc_33">提高留存（Retention）</h3>

<ol>
<li>对于重要价值客户留存率高；对这部分高质量高粘性客户，应该加强维持呵护，利用购买积分等活动增加粘合度。</li>
<li>对于重要唤回客户近期没有消费过，有可能发展为流失的重要客户，有可能被竞争对手拉过去了，针对这部分客户采取赠送、奖励、红包等方式唤回，刺激消费，重点转化。</li>
<li>对于重要深耕客户，根据这部分用户可以根据以往的消费记录，个性化推荐，增加优惠券刺激消费，增加粘性。</li>
<li>对于重要挽留客户，商家应找寻流失原因进行整改。</li>
<li></li>
</ol>

<h3 id="toc_34">增加收入（Revenue）</h3>

<ol>
<li>产品复购率为67.33%，复购率较好，为进一步提高复购率，商家可以从产品本身更新换代，修改不足，进行升级。</li>
<li>做好售后相关事宜，提高用户的好感度。</li>
<li>策划营销内容上推陈出新，吸引用户购买或者回购。</li>
</ol>

<h3 id="toc_35">推荐（Refer）</h3>

<ol>
<li>借鉴拼购思维，提高用户量。</li>
<li>利用微信等社交媒体进行传播。利用消费者打卡，分享，集赞的方式获取更多用户。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[4. excel常见函数]]></title>
    <link href="ryanhuo.github.io/15822375587081.html"/>
    <updated>2020-02-21T06:25:58+08:00</updated>
    <id>ryanhuo.github.io/15822375587081.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">了解函数</h2>

<p><img src="media/15822375587081/clipimage048.gif" alt="img"/></p>

<h2 id="toc_1">求平均值</h2>

<p><img src="media/15822375587081/clipimage050.jpg" alt="img"/></p>

<h2 id="toc_2">IF语句</h2>

<p><img src="media/15822375587081/clipimage052.jpg" alt="img"/></p>

<h2 id="toc_3">VLOOKUP函数</h2>

<p><img src="media/15822375587081/clipimage054.jpg" alt="img"/></p>

<h2 id="toc_4">函数错误修复</h2>

<p><img src="media/15822375587081/clipimage056.jpg" alt="img"/></p>

<p><img src="media/15822375587081/clipimage058.jpg" alt="img"/></p>

<p><img src="media/15822375587081/clipimage060.jpg" alt="img"/></p>

<h2 id="toc_5">OFFSET函数</h2>

<p>offset（基准单元格，行位移，列位移，行高，列宽）</p>

<p><img src="media/15822375587081/15755973577389e7f2f6ab37144f8a768b8c68ef65c72.png" alt="img"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[1. 认识excel]]></title>
    <link href="ryanhuo.github.io/15822373698224.html"/>
    <updated>2020-02-21T06:22:49+08:00</updated>
    <id>ryanhuo.github.io/15822373698224.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">Excel的常见对象</h2>

<ul>
<li>工作簿: 工作表的集合</li>
<li>工作表 (数据的集合)</li>
<li>字段: 数据的列标题</li>
<li>记录: 一行数据</li>
</ul>

<p><img src="media/15822373698224/clipimage009.jpg" alt="img"/></p>

<h2 id="toc_1">数据类型</h2>

<ul>
<li><p>基本数据类型</p>
<p>文本型</p>
<p>数值型</p>
<p>整数型</p>
<p>小数型</p>
<p>日期型</p>
<p>布尔型</p>
<p>其他类型</p></li>
<li><p>变量类型</p>
<p>名义型：没有顺序，只表示分类（男女）</p>
<p>有序型：优良中差</p>
<p>连续型：身高，体重……</p>
<p>星期属于有序型，时间属于连续型</p></li>
</ul>

<p><img src="media/15822373698224/15755973575563ccce84116434250b142855add4fd1d5.png" alt=""/></p>

<p><img src="media/15822373698224/clipimage011.jpg" alt="img"/></p>

<blockquote>
<p>注: 如果将纯数字存储为文本格式将导致无法计算, 此时可以通过 某列 * 1来快速修改数据类型</p>
</blockquote>

<p><img src="media/15822373698224/15755973575802db39373188546f886725305392087fe.png" alt=""/></p>

<p><img src="media/15822373698224/1575597357601457ecb632c28490e9942f7e3cd5905ea.png" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[5. excel图表]]></title>
    <link href="ryanhuo.github.io/15822373698312.html"/>
    <updated>2020-02-21T06:22:49+08:00</updated>
    <id>ryanhuo.github.io/15822373698312.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">插入图表</h2>

<p><img src="media/15822373698312/clipimage062.jpg" alt="img"/> </p>

<h2 id="toc_1">图表的坐标轴</h2>

<p><img src="media/15822373698312/clipimage064.jpg" alt="img"/> </p>

<h2 id="toc_2">图表的次坐标轴</h2>

<p><img src="media/15822373698312/clipimage066.jpg" alt="img"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2. excel导入数据]]></title>
    <link href="ryanhuo.github.io/15822373698416.html"/>
    <updated>2020-02-21T06:22:49+08:00</updated>
    <id>ryanhuo.github.io/15822373698416.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">通过网站站导入数据</h2>

<ul>
<li><a href="https://archive.ics.uci.edu/ml/machine-learning-databases/breast-cancer-wisconsin/breast-%20cancer-wisconsin.data">数据源</a></li>
<li>具体步骤如下:
<img src="media/15822373698416/clipimage014.jpg" alt="img"/> </li>
</ul>

<p><img src="media/15822373698416/clipimage016.jpg" alt="img"/></p>

<h2 id="toc_1">导文本数据</h2>

<p><img src="media/15822373698416/clipimage018.jpg" alt="img"/></p>

<p>选择对应的文本文件之后, 需要选择分隔符和新表所在位置就可以完成导入数据</p>

<h2 id="toc_2">导入MySQL数据库数据</h2>

<p>需要安装MySQL connect/net工具</p>

<ol>
<li>提前准备好需要连接的数据库 demo</li>
</ol>

<p><img src="media/15822373698416/clipimage020.jpg" alt="img"/></p>

<ol>
<li><p>选择数据 —&gt; 新建查询</p>
<p><img src="media/15822373698416/clipimage021.jpg" alt="img"/> </p></li>
<li><p>选择从MySQL数据库中获取数据</p></li>
</ol>

<p><img src="media/15822373698416/clipimage023.jpg" alt="img"/></p>

<ol>
<li>输入连接的服务器和数据库名称</li>
</ol>

<p><img src="media/15822373698416/clipimage025.jpg" alt="img"/> </p>

<ol>
<li>不要使用默认的windows服务, 选择数据库服务, 输用户户名和密码</li>
</ol>

<p><img src="media/15822373698416/clipimage027.jpg" alt="img"/></p>

<ol>
<li>数据加载成功</li>
</ol>

<p><img src="media/15822373698416/clipimage029.jpg" alt="img"/></p>

<h2 id="toc_3">Tips</h2>

<p><img src="media/15822373698416/157559735762576a31e55c01e483f8ee315acbc9fd55d.png" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[6. Excel VBA]]></title>
    <link href="ryanhuo.github.io/15822373698488.html"/>
    <updated>2020-02-21T06:22:49+08:00</updated>
    <id>ryanhuo.github.io/15822373698488.html</id>
    <content type="html"><![CDATA[
<h1 id="toc_0">为什么要学VBA</h1>

<p><strong>可以控制操作EXcel的代码</strong></p>

<h2 id="toc_1">利用录制宏实现工资条生成</h2>

<p><img src="media/15822373698488/image-20191226152236576.png" alt="image-20191226152236576"/></p>

<h3 id="toc_2">1. 调出开发者工具栏目</h3>

<p><img src="media/15822373698488/image-20191226151037913.png" alt="image-20191226151037913"/></p>

<h3 id="toc_3">2. 录制宏</h3>

<ul>
<li>使用相对引用位置</li>
<li>初始位置在工号单元格</li>
<li>所有操作使用鼠标进行</li>
</ul>

<p><img src="media/15822373698488/image-20191226151159297.png" alt="image-20191226151159297"/></p>

<h3 id="toc_4">3. 快速操作</h3>

<ul>
<li>利用快捷键操作 ctl+（自定义快捷键）</li>
<li>利用表格控件操作</li>
</ul>

<p><img src="media/15822373698488/image-20191226152209751.png" alt="image-20191226152209751"/></p>

<h3 id="toc_5">4. 宏安全性</h3>

<blockquote>
<p>为了防止宏病毒，在已知安全前提下，可以调用宏文件</p>
</blockquote>

<p><img src="media/15822373698488/image-20191226152412440.png" alt="image-20191226152412440"/></p>

<h3 id="toc_6">5. 本质代码</h3>

<pre><code class="language-vba">Sub 工资()
&#39;
&#39; 工资 宏
&#39;

&#39;
    ActiveCell.Offset(2, 0).Rows(&quot;1:2&quot;).EntireRow.Select
    Selection.Insert Shift:=xlDown, CopyOrigin:=xlFormatFromLeftOrAbove
    ActiveCell.Offset(-2, 0).Range(&quot;A1:J1&quot;).Select
    Selection.Copy
    ActiveCell.Offset(3, 0).Range(&quot;A1&quot;).Select
    ActiveSheet.Paste
    ActiveCell.Offset(-1, 0).Range(&quot;A1:J1&quot;).Select
    Application.CutCopyMode = False
    Selection.Borders(xlDiagonalDown).LineStyle = xlNone
    Selection.Borders(xlDiagonalUp).LineStyle = xlNone
    Selection.Borders(xlEdgeLeft).LineStyle = xlNone
    With Selection.Borders(xlEdgeTop)
        .LineStyle = xlContinuous
        .ColorIndex = 49
        .TintAndShade = 0
        .Weight = xlMedium
    End With
    With Selection.Borders(xlEdgeBottom)
        .LineStyle = xlContinuous
        .ColorIndex = 49
        .TintAndShade = 0
        .Weight = xlMedium
    End With
    Selection.Borders(xlEdgeRight).LineStyle = xlNone
    Selection.Borders(xlInsideHorizontal).LineStyle = xlNone
End Sub
</code></pre>

<h2 id="toc_7">VBA</h2>

<blockquote>
<p>微软开发，建立在office中应用程序开发工具</p>
</blockquote>

<p><strong>优点</strong></p>

<ul>
<li>Excel，录制宏不能解决问题的对策</li>
<li>简单编辑修改，运用面广</li>
</ul>

<p><img src="media/15822373698488/image-20191226153549716.png" alt="image-20191226153549716"/></p>

<h1 id="toc_8">VBA编程</h1>

<h2 id="toc_9">编写界面的介绍</h2>

<h2 id="toc_10">调取界面</h2>

<ul>
<li>Alt+F11</li>
<li>开发工具——Visual Basic</li>
<li>开发工具——查看代码</li>
<li>其他</li>
</ul>

<h2 id="toc_11">VBE窗口</h2>

<p><img src="media/15822373698488/image-20191226155524633.png" alt="image-20191226155524633"/></p>

<h3 id="toc_12">工具栏</h3>

<p><img src="media/15822373698488/image-20191226155620064.png" alt="image-20191226155620064"/></p>

<h3 id="toc_13">资源管理</h3>

<p><img src="media/15822373698488/image-20191226155649337.png" alt="image-20191226155649337"/></p>

<h3 id="toc_14">代码</h3>

<p><img src="media/15822373698488/image-20191226155823202.png" alt="image-20191226155823202"/></p>

<h3 id="toc_15">立即窗口</h3>

<ul>
<li>即时执行代码，显示结果</li>
</ul>

<p><img src="media/15822373698488/image-20191226160032882.png" alt="image-20191226160032882"/></p>

<h2 id="toc_16">VBA代码</h2>

<p><img src="media/15822373698488/image-20191226160221900.png" alt="image-20191226160221900"/></p>

<h3 id="toc_17">代码示例</h3>

<pre><code class="language-vba">Sub 复制()
&#39;
&#39; 宏1 宏
&#39;

&#39;
    Selection.Copy
    Range(&quot;D8&quot;).Select
    ActiveSheet.Paste
    Range(&quot;D8&quot;).Select
End Sub

</code></pre>

<ul>
<li><strong>开始语句</strong>
Sub 复制()</li>
<li><strong>注释语句</strong>
&#39;<br/>
&#39; 宏1 宏<br/>
&#39;<br/>
&#39; </li>
<li><strong>代码</strong>
Selection.Copy<br/>
  Range(&quot;D8&quot;).Select<br/>
  ActiveSheet.Paste<br/>
  Range(&quot;D8&quot;).Select</li>
<li><strong>结束语句</strong>
End Sub</li>
</ul>

<h3 id="toc_18">实操</h3>

<ol>
<li><p>添加一个模块用于保存VBA</p></li>
<li><p>动手写Sub过程</p>
<ol>
<li>选择模块</li>
<li>插入——过程
<img src="media/15822373698488/image-20191226160932484.png" alt="image-20191226160932484"/></li>
<li>确定——保存</li>
</ol>
<p><img src="media/15822373698488/image-20191226161107256.png" alt="image-20191226161107256"/></p></li>
<li><p>运行程序</p></li>
</ol>

<p><img src="media/15822373698488/image-20191226161136556.png" alt="image-20191226161136556"/></p>

<h1 id="toc_19">VBA语法</h1>

<h2 id="toc_20">Excel数据类型</h2>

<ul>
<li>文本</li>
<li>数值</li>
<li>日期值</li>
<li>逻辑值</li>
<li>错误值</li>
</ul>

<p><img src="media/15822373698488/image-20191226161659886.png" alt="image-20191226161659886"/></p>

<h2 id="toc_21">VBA数据类型</h2>

<p><img src="media/15822373698488/image-20191226162522844.png" alt="image-20191226162522844"/></p>

<h2 id="toc_22">变量</h2>

<ul>
<li>变量，给数据预留的内存空间</li>
<li>常量，通常用于存储某些固定的数据</li>
</ul>

<h3 id="toc_23">声明变量</h3>

<pre><code class="language-text">Dim 变量名 As 数据类型
</code></pre>

<ul>
<li>变量名：以字母（汉字）开头，不包含特殊符号</li>
</ul>

<p><strong>其他定义方法</strong></p>

<p><mark>定义私有变量</mark></p>

<pre><code class="language-text">private 变量名 As 数据类型
</code></pre>

<p><mark>定义共有变量</mark></p>

<pre><code class="language-text">public 变量名 As 数据类型
</code></pre>

<p><mark>定义静态变量</mark></p>

<p>当程序结束是，静态变量保持原值不变</p>

<pre><code class="language-text">static 变量名 As 数据类型
</code></pre>

<h3 id="toc_24">变量赋值</h3>

<ol>
<li>数据类型</li>
</ol>

<pre><code class="language-text">[Let] 变量名称= 要存储的数据
</code></pre>

<ul>
<li>中括号中关键词let可以省略，即</li>
</ul>

<pre><code class="language-text">变量名称= 要存储的数据
</code></pre>

<ol>
<li>对象类型</li>
</ol>

<pre><code class="language-text">set 变量名称=要存储的对象名称
</code></pre>

<p>例子：</p>

<pre><code class="language-text">set sht = activesheet ’将活动工作表赋值给变量sht
</code></pre>

<h3 id="toc_25">对象变量运用例子</h3>

<pre><code class="language-text">sub 对象变量()
    dim sht as worksheet  &#39;定义一个工作表对象sht
    set sht = activesheet  ‘将活动工作表赋值给变量sht
    sht.range（“A1”）.value=“我在学习VBA”
end sub
</code></pre>

<h3 id="toc_26">tips</h3>

<p>P50页</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[3. excel常见的操作]]></title>
    <link href="ryanhuo.github.io/15822373698642.html"/>
    <updated>2020-02-21T06:22:49+08:00</updated>
    <id>ryanhuo.github.io/15822373698642.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">填充</h2>

<p><img src="media/15822373698642/clipimage032.gif" alt="img"/> </p>

<p><img src="media/15822373698642/clipimage034.jpg" alt="img"/></p>

<h2 id="toc_1">拆分</h2>

<p><img src="media/15822373698642/clipimage037.gif" alt="img"/> </p>

<h2 id="toc_2">排序和筛选</h2>

<p><img src="media/15822373698642/clipimage039.jpg" alt="img"/></p>

<p><img src="media/15822373698642/clipimage041.jpg" alt="img"/> </p>

<h2 id="toc_3">下拉表</h2>

<p><img src="media/15822373698642/clipimage043.jpg" alt="img"/> </p>

<p><img src="media/15822373698642/clipimage045.jpg" alt="img"/></p>

<p>## 单元格</p>

<p><img src="media/15822373698642/1575597357644fc7dbbbd70b14f05b14f0444dfe4294f.png" alt=""/></p>

<h2 id="toc_4">查找和替换</h2>

<p><img src="media/15822373698642/1575597357644fc7dbbbd70b14f05b14f0444dfe4294f15759.png" alt=""/></p>

<h2 id="toc_5">复制粘贴</h2>

<p><img src="media/15822373698642/15755973576873f6834aaea2340f29561aecb4b91f198.png" alt=""/></p>

<h2 id="toc_6">表格转表</h2>

<ul>
<li>列是基础的数据字段</li>
<li>易于处理大量数据</li>
<li>关联外部数据</li>
</ul>

<p><img src="media/15822373698642/15755973576873f6834aaea2340f29561aecb4b91f19815759.png" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2.1 单变量线性回归(Linear Regression with One Variable)]]></title>
    <link href="ryanhuo.github.io/15822327222121.html"/>
    <updated>2020-02-21T05:05:22+08:00</updated>
    <id>ryanhuo.github.io/15822327222121.html</id>
    <content type="html"><![CDATA[
<p>在给定训练集的情况下，学习函数h：X→Y，使得h（x）是y的相应值的“好”预测器。由于历史原因，这个函数h被称为假设。</p>

<p><img src="media/15822327222121/68_0_1-20200217012807346.png" alt="img"/></p>

<p>通过输入住房面积 x，通过学习好的函数，输出房子的估价。</p>

<h2 id="toc_0">代价函数</h2>

<p>代价函数是线性回归中的一个应用，在线性回归中，要解决的一个问题就是最小化问题。</p>

<p>假设在一元线性回归中，在一个训练集中，我们需要找到一条直线能和该训练集中的点最接近。假设直线方程为 </p>

<p>\[h_{\theta}(x) = \theta_{0} + \theta_{1}x\]</p>

<p>如何选择 \(\theta_{0}\)、\(\theta_{1}\)，使得 \(h_{\theta}(x)\) 更接近于训练集 (x,y) ？</p>

<p>上述问题可以转换为求</p>

<p>\[ \rm{CostFunction} = \rm{F}({\theta_{0}},{\theta_{1}}) = \frac{1}{2m}\sum_{i = 1}^{m} (h_{\theta}(x^{(i)})-y^{(i)})^2 \]  </p>

<p>求最小值<mark>\[\min_{{\theta_{0}} {\theta_{1}}} \rm{F}({\theta_{0},{\theta_{1}})} \]</mark></p>

<h3 id="toc_1">代价函数的直观理解I</h3>

<blockquote>
<p>令\(\theta_0\)=0时，求出不同\(\theta_1\)下代价函数的值</p>
</blockquote>

<p><img src="media/15822327222121/2c9fe871ca411ba557e65ac15d55745d.png" alt="img"/></p>

<h3 id="toc_2">代价函数的直观理解II</h3>

<p><img src="media/15822327222121/0b789788fc15889fe33fb44818c40852.png" alt="img"/></p>

<p><a href="media/15822327222121/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95.md">梯度下降法补充知识</a></p>

<h2 id="toc_3">梯度下降</h2>

<p>梯度下降是一个用来求函数最小值的算法，我们将使用梯度下降算法来求出代价函数\(J(\theta_0,\theta_1)\)的最小值。</p>

<blockquote>
<p><strong>have some function</strong>  :     \(J(\theta_0,\theta_1)\)</p>

<p><strong>want</strong>  :   \(\min_{{\theta_{0}} {\theta_{1}}} J(\theta_0,\theta_1)\)</p>

<p><strong>outline</strong>  :</p>

<ul>
<li>初始化 \({\theta_{0}}\) 和 \({\theta_{1}}\) , \({\theta_{0}}\) = 0 , \({\theta_{1}}\) = 0</li>
<li>不断的改变 \({\theta_{0}}\) 和 \({\theta_{1}}\) 值，不断减少 \(F({\theta_{0}},{\theta_{1}})\) 直至达到最小值（或者局部最小）。</li>
</ul>
</blockquote>

<p><img src="media/15822327222121/db48c81304317847870d486ba5bb2015.jpg" alt="img"/></p>

<p>想象成下山，如何下山的速度最快？这里涉及到了下山的速度，即步长。</p>

<p>repeat until convergence\[ \{\theta_j:=\theta_j-{\alpha}\frac{\partial }{\partial {\theta_{0}}}J(\theta_0,\theta_1) (for \quad j=o\quad and\quad  j=1) \}\]</p>

<blockquote>
<ul>
<li><code>:=</code> 赋值</li>
<li>\(\alpha\) 被称作为<strong>学习速率</strong>，\(\alpha\)值大，下山的步伐大</li>
<li>更新等式，需要同时更新\(\theta_0,\theta_1\)</li>
</ul>
</blockquote>

<p>更新实现方法：</p>

<p>\[ {\begin{align*}\rm{temp}0&amp;:= {\theta_{0}}\alpha *\frac{\partial }{\partial {\theta_{0}\rm{F}({\theta_{0}},{\theta_{1}}) \\\rm{temp}1 &amp;:= {\theta_{1}} \alpha *\frac{\partial }{\partial {\theta_{1}\rm{F}({\theta_{0}},{\theta_{1}}) \\{\theta_{0}} &amp;:= \rm{temp}0 \\{\theta_{1}} &amp;:= \rm{temp}1 \\\end{align*} }\]</p>

<p>直到收敛。注意 \({\theta_{0}}\) 和 \({\theta_{1}}\) 值要<strong>同时更新</strong>，<strong>切记不要求一次导更新一次！</strong></p>

<p><img src="media/15822327222121/68_3.gif" alt=""/></p>

<p>如果 \(\alpha\) 被设置的很小，需要很多次循环才能到底最低点。<br/>
如果 \(\alpha\) 被设置的很大，来来回回可能就会离最低点越来越远，<strong>会导致无法收敛，甚至发散</strong>。</p>

<p>当快要到最低点的时候，梯度下降会越来越慢，因为 \( \frac{\partial }{\partial {\theta}}\) 越来越小。</p>

<h3 id="toc_4">梯度下降的直观理解</h3>

<p>\[\theta_j:=\theta_j-\alpha{\frac{\partial}{\partial{\theta_j}}J(\theta_0,\theta_1)}\]</p>

<blockquote>
<p>简化模型：</p>

<ul>
<li>\(min_{\theta_0} J(\theta_1)\)</li>
<li>\(\theta_1 \in \R\)</li>
</ul>
</blockquote>

<p><img src="media/15822327222121/ee916631a9f386e43ef47efafeb65b0f.png" alt="img"/></p>

<blockquote>
<ul>
<li>导数求切线斜率</li>
<li>此时\(\theta_1\)减去一个大于0的斜率，\(\theta_1\)左移</li>
<li>假设你将初始化\(\theta_1\)在局部最低点已经在一个局部的最优处或局部最低点。结果是局部最优点的导数将等于零,\(\theta_1\)不变</li>
</ul>
</blockquote>

<h4 id="toc_5">\(\alpha\)</h4>

<ul>
<li>太小速度会很慢</li>
<li>太大会超过最小值</li>
</ul>

<p><img src="media/15822327222121/IMG_2889.jpg" alt="IMG_2889"/></p>

<blockquote>
<p>例：</p>

<p><img src="media/15822327222121/4668349e04cf0c4489865e133d112e98.png" alt="img"/></p>

<p>::越接近最小值，下降的斜率越低，下降速度越慢::</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2. python语法入门]]></title>
    <link href="ryanhuo.github.io/15822327222447.html"/>
    <updated>2020-02-21T05:05:22+08:00</updated>
    <id>ryanhuo.github.io/15822327222447.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">注释</h2>

<p>对代码的解释和说明， 可以提供代码的可读性。</p>

<blockquote>
<p>注释分为单行注释和多行注释<br/>
单行注释是以 # 开始<br/>
多行注释，可以使用三个双引号或者三个单引号&quot;&quot;&quot; &quot;&quot;&quot; &#39;&#39;&#39; &#39;&#39;&#39;</p>
</blockquote>

<pre><code class="language-python"># 定义字符串变量name
&#39;&#39;&#39;
我是多行注释
我是多行注释
我是多行注释
&#39;&#39;&#39;
age=19
&quot;&quot;&quot;
我是多行注释
我是多行注释
我是多行注释
&quot;&quot;&quot;

sex=&#39;男&#39;
</code></pre>

<p>注意： ctr + / -&gt; 单⾏行注释快捷键</p>

<h2 id="toc_1">变量的定义</h2>

<p><strong>变量：</strong> 通俗理解就是存储程序数据的容器。</p>

<p><strong>变量定义的格式</strong>：变量名 = 数据 (变量名尽量有含义，方便理解 )</p>

<pre><code class="language-python">score=100 #定义一个变量名字叫score，存储的数据是100
print(score)

name=&#39;张三&#39;
print(name)

pi=3.14
print(pi)

is_ok =True
print(is_ok)

#提示：在python里面不需要指定数据的类型，会根据数据自动推导出数据类型

#通过type查看变量类型
score_type=type(score)
print(score_type)

name_type=type(name)
print(name_type)

pi_type=type(pi)
print(pi_type)

print(type(is_ok))
</code></pre>

<p><strong>总结：</strong> 常用的数据类型 int，str, ﬂoat, bool, list, tuple, dict,set</p>

<h2 id="toc_2">变量的命名规则</h2>

<p><strong>变量名：</strong>是由字母，数字，下划线组成的，注意只有这三种，但不能以数字开头</p>

<p>错误的使用：</p>

<pre><code class="language-python">3name=&#39;李四&#39;
print(3name)
name!age=18
</code></pre>

<blockquote>
<p>变量命名方式： 驼峰命名法 和 下划线命名法<br/>
驼峰命名法: 小驼峰和大驼峰 小驼峰: 第一个单词首字母要小写，其它单词首字母都大写 大驼峰: 每个单词首字母都大写<br/>
下划线命名： 单词都使用小写字母，单词之间使用下划线进行分割, 比如: my_name</p>
</blockquote>

<pre><code class="language-python">my_name=&#39;李四&#39; #下划线命名
myName=&#39;李四&#39; #小驼峰
MyName=&#39;李四&#39; #大驼峰
</code></pre>

<h2 id="toc_3">关键字</h2>

<p><strong>关键字：</strong> 在python里面具有特殊功能的标识符（理解成变量名、函数名）， 关键字不能作为变量名使用。</p>

<pre><code class="language-text">[&#39;False&#39;, &#39;None&#39;, &#39;True&#39;, &#39;and&#39;, &#39;as&#39;,
 &#39;assert&#39;, &#39;break&#39;, &#39;class&#39;, &#39;continue&#39;, &#39;def&#39;, 
&#39;del&#39;, &#39;elif&#39;, &#39;else&#39;, &#39;except&#39;, &#39;finally&#39;,
 &#39;for&#39;, &#39;from&#39;, &#39;global&#39;, &#39;if&#39;, &#39;import&#39;,
 &#39;in&#39;, &#39;is&#39;, &#39;lambda&#39;, &#39;nonlocal&#39;, &#39;not&#39;, 
&#39;or&#39;, &#39;pass&#39;, &#39;raise&#39;, &#39;return&#39;, &#39;try&#39;,
&#39;while&#39;, &#39;with&#39;, &#39;yield&#39;]
</code></pre>

<h2 id="toc_4">常用的数据类型转换</h2>

<table>
<thead>
<tr>
<th><strong>函数</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>

<tbody>
<tr>
<td>int(x [,base ])</td>
<td>将x转换为一个整数</td>
</tr>
<tr>
<td>ﬂoat(x )</td>
<td>将x转换为一个浮点数</td>
</tr>
<tr>
<td>complex(real [,imag ])</td>
<td>创建一个复数，real为实部，imag为虚部</td>
</tr>
<tr>
<td>str(x )</td>
<td>将对象 x 转换为字符串串</td>
</tr>
<tr>
<td>repr(x )</td>
<td>将对象 x 转换为表达式字符串串</td>
</tr>
<tr>
<td>eval(str )</td>
<td>用来计算在字符串串中的有效Python表达式,并返回一个对象</td>
</tr>
<tr>
<td>tuple(s )</td>
<td>将序列列 s 转换为一个元组</td>
</tr>
<tr>
<td>list(s )</td>
<td>将序列列 s 转换为一个列列表</td>
</tr>
<tr>
<td>chr(x )</td>
<td>将一个整数转换为一个Unicode字符</td>
</tr>
<tr>
<td>ord(x )</td>
<td>将一个字符转换为它的ASCII整数值</td>
</tr>
<tr>
<td>hex(x )</td>
<td>将一个整数转换为一个十六进制字符串串</td>
</tr>
<tr>
<td>oct(x )</td>
<td>将一个整数转换为一个八进制字符串串</td>
</tr>
<tr>
<td>bin(x )</td>
<td>将一个整数转换为一个二进制字符串串</td>
</tr>
</tbody>
</table>

<h2 id="toc_5">输入和输出</h2>

<p>生活中无时无刻其实都存在输入和输出的例子,我们先举例看一下生活中有哪些输入输出的情况,在来对比Python中的输入输出和生活中的有什么相同和不同之处。</p>

<h3 id="toc_6">生活中的输出</h3>

<p>我们经常会去电影院看电影,我们从电影院屏幕中获取影片的内容来观看影片,而影片的放映室经过投影仪&quot;&quot;照射&quot;&quot;到大屏幕,同样的也可以说是投影仪把影片输出到大荧幕上来供我们观看,这就是生活中最简单的输出方式。</p>

<h3 id="toc_7">Python中的输出</h3>

<p>Python中的输出和生活中的输出是一样的原理理，只不不过Python中的输出，特指是在控制台中输出,或  者是将你准备要输出的内容相应的输出到你的设备上，如你在手机上看到的文字、图片、视频等数据,其 实本质上也是我们敲打代码输出到手机上的.那我们先来看一下第一种，如何将你想要输出文字输出到控制台.</p>

<p>例如我们将一段文字&quot;Hello World&quot;输出到控制台，这里面利用的 print() 函数进行输出,以后我们会讲到函数的概念，先暂时知道print()可以帮助我们进行输出。</p>

<pre><code class="language-python">print(&#39;hello world&#39;)
</code></pre>

<p>右键点击选择 Run 和你对应的要运⾏行的⽂文件名字就可以运⾏行刚刚的输出代码<br/>
<img src="media/15822327222447/1.10.png" alt=""/></p>

<p>我们在图⽚片最下方看见的输出结果为hello world 输出的位置就是控制台</p>

<p><img src="media/15822327222447/1.11.png" alt=""/></p>

<p>我们可以试试输出100+100会是什什么结果</p>

<pre><code class="language-python">print(100+100)
</code></pre>

<h3 id="toc_8">生活中的输入</h3>

<p>生活中的输入无处不在，例如你需要在各种软件中输入的账号密码，去ATM机器取钱也同样需要输入密码。</p>

<p><img src="media/15822327222447/1.12.png" alt=""/></p>

<h3 id="toc_9">Python中的输入</h3>

<p>和输出同理理我们也可用到控制台来记录输入结果,同样用到一个函数 input() ，我们可以利用这段代码在控制台输入，然后在利用刚刚学的 print() 函数把你输入的结果在输出来。</p>

<pre><code class="language-python">name=input()
print(name)
</code></pre>

<blockquote>
<p>当你运行完毕 name = input () 代码并将鼠标光标移动到控制台，Python交互式命令就在等你的输入了,你可以输入任意字符,然后按回车完成输入。</p>
</blockquote>

<h2 id="toc_10">格式化输出</h2>

<pre><code class="language-pyhton"># 格式化符号：%s，%d，%f，%x
# %s:输出字符串
# %d:输出int类型数字
# %f:输出浮点数
# %x:输出16进制数据

score=100
print(&#39;python成绩为：%d&#39;% sore)
</code></pre>

<h2 id="toc_11">if语句</h2>

<p>计算机之所以能做很多⾃自动化的任务，因为它可以自己做条件判断。</p>

<p>比如，输入用户年龄，根据年龄打印不同的内容，在Python程序中，用 if 语句实现：</p>

<pre><code class="language-python">age=20
if age &gt;=18:
    print(&#39;your age is&#39;,age)
    print(&#39;adult&#39;)
</code></pre>

<p>根据Python的缩进规则，如果 if 语句判断是 True ，就把缩进的两行print语句执行了，否则，什么也不做。</p>

<p>也可以给 if 添加一个 else 语句，意思是，如果 if 判断是 False ，不要执行 if 的内容，去把 else 执行了：</p>

<pre><code class="language-python">age = 3
if age &gt;= 18:
    print(&#39;your age is&#39;, age) 
    print(&#39;adult&#39;)
else:
    print(&#39;your age is&#39;, age) 
    print(&#39;teenager&#39;)
</code></pre>

<p>注意不不要少写了冒号: 。</p>

<p>当然上面的判断是很粗略的，完全可以用 elif 做更细致的判断：</p>

<pre><code class="language-python">age = 3
if age &gt;= 18:
    print(&#39;adult&#39;) 
elif age &gt;= 6:
    print(&#39;teenager&#39;) 
else:
    print(&#39;kid&#39;)

</code></pre>

<p>elif 是else if 的缩写，完全可以有多个 elif ，所以 if 语句的完整形式就是：</p>

<pre><code class="language-python">if &lt;条件判断1&gt;:
    &lt;执行1&gt;
elif &lt;条件判断2&gt;:
    &lt;执行2&gt;
elif &lt;条件判断3&gt;:
    &lt;执行3&gt;
else:
    &lt;执行4&gt;
</code></pre>

<p>if 语句执行有个特点，它是从上往下判断，如果在某个判断上是 True ，把该判断对应的语句执行后， 就忽略掉剩下的elif 和 else ，所以，请测试并解释为什么下面的程序打印的是 teenager ：</p>

<pre><code class="language-python">age = 20
if age &gt;= 6:
    print(&#39;teenager&#39;) 
elif age &gt;= 18:
    print(&#39;adult&#39;) 
else:
    print(&#39;kid&#39;)
</code></pre>

<h2 id="toc_12">运算符</h2>

<h3 id="toc_13">算数运算符</h3>

<p>Python支持以下几种运算符:</p>

<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>描述</strong></th>
<th><strong>实例</strong></th>
</tr>
</thead>

<tbody>
<tr>
<td>+</td>
<td>加</td>
<td>两个对象相加 a + b 输出结果 30</td>
</tr>
<tr>
<td>-</td>
<td>减</td>
<td>得到负数或是一个数减去另一个数  a - b 输出结果 -10</td>
</tr>
<tr>
<td>*</td>
<td>乘</td>
<td>两个数相乘或是返回一个被重复若⼲干次的字符串串 a * b 输出结果 200</td>
</tr>
<tr>
<td>/</td>
<td>除</td>
<td>b / a 输出结果  2</td>
</tr>
<tr>
<td>//</td>
<td>取整除</td>
<td>返回商的整数部分 9//2 输出结果 4 , 9.0//2.0 输出结果 4.0</td>
</tr>
<tr>
<td>%</td>
<td>取余</td>
<td>返回除法的余数 b % a 输出结果 0</td>
</tr>
<tr>
<td>**</td>
<td>指数</td>
<td>a**b 为10的20次方，  输出结果 100000000000000000000</td>
</tr>
</tbody>
</table>

<blockquote>
<p>混合运算时，优先级顺序为：(*<em>)高于(</em>)(/)(%)(//)高于(+)(-) 为了避免歧义，建议使用 () 来处理运算符优先级。并且，不同类型的数字在进行混合运算时，整数将会转换成浮点数进行运算。</p>
</blockquote>

<h3 id="toc_14">赋值运算符</h3>

<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>描述</strong></th>
<th><strong>实例</strong></th>
</tr>
</thead>

<tbody>
<tr>
<td>=</td>
<td>赋值运算符</td>
<td>把 = 号右边的结果 赋给 左边的变量，如 num = 1  + 2 * 3，结果num的值为7</td>
</tr>
</tbody>
</table>

<pre><code class="language-python"># 单个变量赋值
num = 10

# 多个变量赋值
num1, num2, f1, str1 = 100, 200, 3.14, &quot;hello&quot;

</code></pre>

<h3 id="toc_15">复合赋值运算符</h3>

<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>描述</strong></th>
<th><strong>实例例</strong></th>
</tr>
</thead>

<tbody>
<tr>
<td>+=</td>
<td>加法赋值运算符</td>
<td>c += a 等效于 c = c + a</td>
</tr>
<tr>
<td>-=</td>
<td>减法赋值运算符</td>
<td>c -= a 等效于 c = c - a</td>
</tr>
<tr>
<td>*=</td>
<td>乘法赋值运算符</td>
<td>c *= a 等效于 c = c * a</td>
</tr>
<tr>
<td>/=</td>
<td>除法赋值运算符</td>
<td>c /= a 等效于 c = c / a</td>
</tr>
<tr>
<td>%=</td>
<td>取模赋值运算符</td>
<td>c %= a 等效于 c = c % a</td>
</tr>
<tr>
<td>**=</td>
<td>幂赋值运算符</td>
<td>c** <strong>= a</strong> <strong>等效于</strong>  <strong>c = c</strong> a</td>
</tr>
<tr>
<td>//=</td>
<td>取整除赋值运算符</td>
<td>c //= a 等效于 c = c // a</td>
</tr>
</tbody>
</table>

<h2 id="toc_16">循环</h2>

<p>我们来试想这样一种情况,现在让你们在控制台输出100条hello world ,本质上,我们写一百条 print 函数输出就可以了,但是如果一千条一万条呢.这就要用到循环语句了.</p>

<h3 id="toc_17">while循环</h3>

<p>while循环语句语法</p>

<pre><code class="language-python">while 条件:
    条件满足时，做的事情1 
    条件满足时，做的事情2 
    条件满足时，做的事情3
</code></pre>

<p>例例如输出100条 hello world</p>

<pre><code class="language-python">i = 100
whiel i &lt;=100:
    print(&#39;hello world&#39;)
    i + 1
</code></pre>

<p>相对应,在while循环语句里面,每执行一次循环语句, i 就会加1,直到i 等于101时不满足 i&lt;=100 的条件,循环就结束了</p>

<h3 id="toc_18">for循环</h3>

<p>for循环和while一样同样可以进行循环,并且是运用最多的循环方式,而且它有一项非常厉害的功能——遍历 ,在Python中  for 循环可以遍历任何序列项目,如字符串,或者今后会学到的列表,例如我们遍历字符串,就特指将字符串的所有字符全部访问一遍</p>

<pre><code class="language-python">names = [&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;] 
for name in names:
    print(name)
</code></pre>

<p>执行这段代码，会依次打印 names 的每一个元素：</p>

<pre><code class="language-python">Michael 
Bob 
Tracy
</code></pre>

<p>所以for x in ... 循环就是把每个元素代入变量x ，然后执行缩进块的语句。再比如我们想计算1-10的整数之和，可以用一个 sum 变量做累加：</p>

<pre><code class="language-python">sum = 0
for x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]:
    sum = sum + x 
    print(sum)

</code></pre>

<p>Python还提供了一个range()函数,可以配合我们的for循环使用,例如:</p>

<pre><code class="language-python">for i in range(5): 
    print(i)

#效果等同于 while 循环的：

i = 0
while i &lt; 5:
    print(i) 
    i += 1

</code></pre>

<p>我们在来学习两个关键字 breake continue ,这两个关键字是我们循环语句的好帮手</p>

<h3 id="toc_19">break</h3>

<p>在循环中， break 语句可以提前退出循环。例如，本来要循环打印1～100的数字：</p>

<pre><code class="language-python">n = 1
while n &lt;= 100: 
    print(n)
    n = n + 1 
print(&#39;END&#39;)
</code></pre>

<p>上面的代码可以打印出1~100。</p>

<p>如果要提前结束循环，可以用 break 语句：</p>

<pre><code class="language-python">n = 1
while n &lt;= 100:
    if n &gt; 10: # 当n = 11时，条件满足，执行break语句
        break # break语句会结束当前循环
    print(n) 
    n = n + 1
print(&#39;END&#39;)
</code></pre>

<p>执行上面的代码可以看到，打印出1~10后，紧接着打印 END ，程序结束。可见 break 的作用是提前结束循环。</p>

<h3 id="toc_20">continue</h3>

<p>在循环过程中，也可以通过 continue 语句，跳过当前的这次循环，直接开始下一次循环。</p>

<pre><code class="language-python">n = 0
while n &lt; 10:
    n = n + 1 
    print(n)
</code></pre>

<p>上面的程序可以打印出1～10。但是，如果我们想只打印奇数，可以用 continue 语句跳过某些循环：</p>

<pre><code class="language-python">n = 0
while n &lt; 10:
    n = n + 1
    if n % 2 == 0: # 如果n是偶数，执行continue语句
        continue # continue语句会直接继续下⼀一轮循环，后续的print()语句不不会执行
    print(n)

</code></pre>

<p>执行上面的代码可以看到，打印的不再是1～10，而是1，3，5，7，9。    可见 continue 的作用是提前结束本轮循环，并直接开始下一轮循环。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[6. python包的使用及读写]]></title>
    <link href="ryanhuo.github.io/15822327222510.html"/>
    <updated>2020-02-21T05:05:22+08:00</updated>
    <id>ryanhuo.github.io/15822327222510.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">捕获异常</h2>

<p>一旦出错，还要一级一级上报，直到某个函数可以处理该错误（比如，给用户输出一个错误信息）。所以高级语言通常都内置了一套try...except...finally...的错误处理机制，Python也不例外。  让我们用一个例子来看看try的机制：</p>

<pre><code class="language-python">try:
    print(&#39;try...&#39;)
    r = 10 / 0
    print(&#39;result:&#39;, r)
except ZeroDivisionError as e: 
    print(&#39;except:&#39;, e)
finally:
    print(&#39;finally...&#39;) 
print(&#39;END&#39;)
</code></pre>

<pre><code class="language-text">try...
except: division by zero
finally...
END
</code></pre>

<p>当我们认为某些代码可能会出错时，就可以用try来运行这段代码，如果执行出错，则后续代码不会继续执行，而是  直接跳转至错误处理代码，即except语句块，执行完except后，如果有finally语句块，则执行finally语句块，至此，执行完毕。</p>

<p>上面的代码在计算10 / 0时会产生一个除法运算错误：</p>

<pre><code class="language-text">try...
except: division by zero finally...
END
</code></pre>

<p>从输出可以看到，当错误发生时，后续语句print(&#39;result:&#39;, r)不会被执行，except由于捕获到ZeroDivisionError，因此被执行。最后，finally语句被执行。然后，程序继续按照流程往下走。</p>

<p>如果把除数0改成2，则执行结果如下：</p>

<pre><code class="language-text">try...
result: 5 
finally... 
END
</code></pre>

<p>由于没有错误发生，所以except语句块不会被执行，但是finally如果有，则一定会被执行（可以没有finally语句）。</p>

<p>你还可以猜测，错误应该有很多种类，如果发生了不同类型的错误，应该由不同的except语句块处理。没错，可以 有多个except来捕获不同类型的错误：</p>

<pre><code class="language-text">try:
    print(&#39;try...&#39;) 
    r = 10 / int(&#39;a&#39;)
    print(&#39;result:&#39;, r) 
except ValueError as e:
    print(&#39;ValueError:&#39;, e) 
except ZeroDivisionError as e:
    print(&#39;ZeroDivisionError:&#39;, e) 
finally:
    print(&#39;finally...&#39;) 
print(&#39;END&#39;)
</code></pre>

<p>int()函数可能会抛出ValueError，所以我们用一个except捕获ValueError，用另一个except捕获ZeroDivisionError。</p>

<p>此外，如果没有错误发生，可以在except语句块后面加一个else，当没有错误发生时，会自动执行else语句：</p>

<pre><code class="language-text">try:
    print(&#39;try...&#39;) 
    r = 10 / int(&#39;2&#39;)
    print(&#39;result:&#39;, r) 
except ValueError as e:
    print(&#39;ValueError:&#39;, e) 
except ZeroDivisionError as e:
    print(&#39;ZeroDivisionError:&#39;, e) 
else:
    print(&#39;no error!&#39;) 
finally:
    print(&#39;finally...&#39;) 
print(&#39;END&#39;)
</code></pre>

<p>Python的错误其实也是class，所有的错误类型都继承自BaseException，所以在使用except时需要注意的是，  它不但捕获该类型的错误，还把其子类也“一网打尽”。比如：</p>

<pre><code class="language-text">try:
    foo()
except ValueError as e: 
    print(&#39;ValueError&#39;)
except UnicodeError as e: 
    print(&#39;UnicodeError&#39;)
</code></pre>

<p>第二个except永远也捕获不到UnicodeError，因为UnicodeError是ValueError的子类，如果有，也被第一个except给捕获了。</p>

<p>Python所有的错误都是从BaseException类派生的，<a href="https://docs.python.org/3/library/exceptions.html#exception-hierarchy">常见的错误类型和继承关系</a></p>

<p>使用try...except捕获错误还有一个巨大的好处，就是可以跨越多层调用，比如函数main()调用foo()，foo() 调用bar()，结果bar()出错了，这时，只要main()捕获到了，就可以处理：</p>

<pre><code class="language-text">def foo(s):
    return 10 / int(s)

def bar(s):
    return foo(s) * 2

def main():
    try:
        bar(&#39;0&#39;)
    except Exception as e: 
        print(&#39;Error:&#39;, e)
    finally:
        print(&#39;finally...&#39;)
</code></pre>

<p>也就是说，不需要在每个可能出错的地方去捕获错误，只要在合适的层次去捕获错误就可以了。这样一来，就大大减少了写try...except...finally的麻烦。</p>

<p><strong>python所有的标准异常类：</strong></p>

<table>
<thead>
<tr>
<th>异常名称</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>BaseException</td>
<td>所有异常的基类</td>
</tr>
<tr>
<td>SystemExit</td>
<td>解释器请求退出</td>
</tr>
<tr>
<td>KeyboardInterrupt</td>
<td>用户中断执行(通常是输入<sup>C)</sup></td>
</tr>
<tr>
<td>Exception</td>
<td>常规错误的基类</td>
</tr>
<tr>
<td>StopIteration</td>
<td>迭代器没有更多的值</td>
</tr>
<tr>
<td>GeneratorExit</td>
<td>生成器(generator)发生异常来通知退出</td>
</tr>
<tr>
<td>SystemExit</td>
<td>Python 解释器请求退出</td>
</tr>
<tr>
<td>StandardError</td>
<td>所有的内建标准异常的基类</td>
</tr>
<tr>
<td>ArithmeticError</td>
<td>所有数值计算错误的基类</td>
</tr>
<tr>
<td>FloatingPointError</td>
<td>浮点计算错误</td>
</tr>
<tr>
<td>OverflowError</td>
<td>数值运算超出最大限制</td>
</tr>
<tr>
<td>ZeroDivisionError</td>
<td>除(或取模)零 (所有数据类型)</td>
</tr>
<tr>
<td>AssertionError</td>
<td>断言语句失败</td>
</tr>
<tr>
<td>AttributeError</td>
<td>对象没有这个属性</td>
</tr>
<tr>
<td>EOFError</td>
<td>没有内建输入,到达EOF 标记</td>
</tr>
<tr>
<td>EnvironmentError</td>
<td>操作系统错误的基类</td>
</tr>
<tr>
<td>IOError</td>
<td>输入/输出操作失败</td>
</tr>
<tr>
<td>OSError</td>
<td>操作系统错误</td>
</tr>
<tr>
<td>WindowsError</td>
<td>系统调用失败</td>
</tr>
<tr>
<td>ImportError</td>
<td>导入模块/对象失败</td>
</tr>
<tr>
<td>KeyboardInterrupt</td>
<td>用户中断执行(通常是输入<sup>C)</sup></td>
</tr>
<tr>
<td>LookupError</td>
<td>无效数据查询的基类</td>
</tr>
<tr>
<td>IndexError</td>
<td>序列中没有没有此索引(index)</td>
</tr>
<tr>
<td>KeyError</td>
<td>映射中没有这个键</td>
</tr>
<tr>
<td>MemoryError</td>
<td>内存溢出错误(对于Python 解释器不是致命的)</td>
</tr>
<tr>
<td>NameError</td>
<td>未声明/初始化对象 (没有属性)</td>
</tr>
<tr>
<td>UnboundLocalError</td>
<td>访问未初始化的本地变量</td>
</tr>
<tr>
<td>ReferenceError</td>
<td>弱引用(Weak  reference)试图访问已经垃圾回收了的对象</td>
</tr>
<tr>
<td>RuntimeError</td>
<td>一般的运行时错误</td>
</tr>
<tr>
<td>NotImplementedError</td>
<td>尚未实现的方法</td>
</tr>
<tr>
<td>SyntaxError</td>
<td>Python 语法错误</td>
</tr>
<tr>
<td>IndentationError</td>
<td>缩进错误</td>
</tr>
<tr>
<td>TabError</td>
<td>Tab 和空格混用</td>
</tr>
<tr>
<td>SystemError</td>
<td>一般的解释器系统错误</td>
</tr>
<tr>
<td>TypeError</td>
<td>对类型无效的操作</td>
</tr>
<tr>
<td>ValueError</td>
<td>传入无效的参数</td>
</tr>
<tr>
<td>UnicodeError</td>
<td>Unicode 相关的错误</td>
</tr>
<tr>
<td>UnicodeDecodeError</td>
<td>Unicode 解码时的错误</td>
</tr>
<tr>
<td>UnicodeEncodeError</td>
<td>Unicode 编码时错误</td>
</tr>
<tr>
<td>UnicodeTranslateError</td>
<td>Unicode 转换时错误</td>
</tr>
<tr>
<td>Warning</td>
<td>警告的基类</td>
</tr>
<tr>
<td>DeprecationWarning</td>
<td>关于被弃用的特征的警告</td>
</tr>
<tr>
<td>FutureWarning</td>
<td>关于构造将来语义会有改变的警告</td>
</tr>
<tr>
<td>OverflowWarning</td>
<td>旧的关于自动提升为长整型(long)的警告</td>
</tr>
<tr>
<td>PendingDeprecationWarning</td>
<td>关于特性将会被废弃的警告</td>
</tr>
<tr>
<td>RuntimeWarning</td>
<td>可疑的运行时行为(runtime  behavior)的警告</td>
</tr>
<tr>
<td>SyntaxWarning</td>
<td>可疑的语法的警告</td>
</tr>
<tr>
<td>UserWarning</td>
<td>用户代码生成的警告</td>
</tr>
</tbody>
</table>

<h2 id="toc_1">模块</h2>

<p>模块：通俗理解一个.py文件就是一个模块，模块是管理功能代码的。</p>

<p>内置模块：就是python自己内部自带的不需要我们去下载的模块， 比如：time, random等。</p>

<h3 id="toc_2">自定义模块的使用</h3>

<p><strong>注意：</strong>自定义模块名字和变量名的定义很类似，都是由字母、数字、下划线组成，但是不能以数字开头，否则无法导入该模块。</p>

<h4 id="toc_3">创建名为first_module的自定义模块</h4>

<pre><code class="language-python">__all__= [&quot;g_num&quot;, &quot;show&quot;]
# 指定 all 表示 from 模块名 import * 只能使用指定的功能代码，而不是所有的功能代码
# 定义全局变量
g_num = 10
# 定义函数 
def show():
    print(&quot;我是一个函数&quot;)
# 定义类
class Student(object):
    def init (self, name, age): 
        self.name = name
        self.age = age 
    
    def show_msg(self):
        print(self.name, self.age)
# 解决导入的模块中方法没有调用就会执行
if __name__== &#39;__main__&#39;: 
    show()
</code></pre>

<pre><code class="language-text">我是一个函数
</code></pre>

<h4 id="toc_4">使用自定义的模块</h4>

<pre><code class="language-text"># 导入模块
import first_module
# 使用模块中的功能代码
print(first_module.g_num) first_module.show()
stu = first_module.Student(&quot;李四&quot;, 20)
stu.show_msg()
</code></pre>

<p><strong>注意：</strong>使用 name 查看模块名，执行哪个文件，哪个文件中的__name__输出__main__ , 其他导入模块中的__name__结果就是模块名字。</p>

<p>模块导入的注意点：</p>

<ol>
<li> 自定义的模块名不要和系统的模块名重名，</li>
<li> 导入的功能代码不要在当前模块定义否则使用不了导入模块的功能代码</li>
</ol>

<h2 id="toc_5">包的介绍</h2>

<p><strong>包：</strong>通俗理解包就是一个文件夹，只不过文件夹里面有一个init.py文件，包是管理模块的， 模块是管理功能代码的。</p>

<pre><code class="language-text"># -----import导入包里面的模块----
import first_package.first

#-----import导入包里面的模块设置别名----
import first_package.first as one

#----from导入包名 import 模块名----
from first_package import second

#--- from 包名.模块名 import 功能代码----
from first_package.first import show    # 需要保证当前模块没有导入模块的功能代码
# --- from 包名 import *, 默认不会导入包里面的所有模块，需要在init文件里面使用   all  去指定导入的模块
from first_package import *

__init__文件写法
# 如果外界使用from 包名 import * 不会导入包里面的所有模块，需要使用 all 指定
     all    = [&quot;first&quot;, &quot;second&quot;]
# 从当前包导入对应的模块
from . import first from . import second
</code></pre>

<h2 id="toc_6">文件基础操作</h2>

<h3 id="toc_7">文件简介</h3>

<p>文件包括文本文件和二进制文件（声音，图像，视频) 从存储方式来说，文件在磁盘上的存储方式都是二进制形式， 所以，文本文件其实也应该算二进制文件。先从他们的区别来说，虽然都是二进制文件，但是二进制代表的意思不一   样。打个比方，一个人，我们可以叫他的大名，以叫他的小名，但其实都是代表这个人。二进制读写是将内存里面的数据直接读写入文本中，而文本呢，则是将数据先转换成了字符串，再写入到文本中。</p>

<h3 id="toc_8">读文件</h3>

<p>要以读文件的模式打开一个文件对象，使用Python内置的open()函数，传入文件名和标示符：</p>

<pre><code class="language-text">f = open(&#39;/Users/michael/test.txt&#39;, &#39;r&#39;)
</code></pre>

<p>标示符&#39;r&#39;表示读，这样，我们就成功地打开了一个文件。</p>

<p>如果文件不存在，open()函数就会抛出一个IOError的错误，并且给出错误码和详细的信息告诉你文件不存在：</p>

<pre><code class="language-python">f=open(&#39;/Users/michael/notfound.txt&#39;, &#39;r&#39;)
</code></pre>

<pre><code class="language-text">---------------------------------------------------------------------------

FileNotFoundError                         Traceback (most recent call last)

&lt;ipython-input-115-56fe20145a26&gt; in &lt;module&gt;()
----&gt; 1 f=open(&#39;/Users/michael/notfound.txt&#39;, &#39;r&#39;)


FileNotFoundError: [Errno 2] No such file or directory: &#39;/Users/michael/notfound.txt&#39;
</code></pre>

<p>如果文件打开成功，接下来，调用read()方法可以一次读取文件的全部内容，Python把内容读到内存，用一个str 对象表示：</p>

<pre><code class="language-text">f.read() &#39;Hello, world!&#39;
</code></pre>

<p><strong>最后一步</strong>是调用close()方法关闭文件。文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操  作系统同一时间能打开的文件数量也是有限的：</p>

<pre><code class="language-text">f.close()
</code></pre>

<p>由于文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用try ... finally来实现：</p>

<pre><code class="language-text">try:
    f = open(&#39;/path/to/file&#39;, &#39;r&#39;) 
    print(f.read())
finally:
    if f:
        f.close()
</code></pre>

<p>但是每次都这么写实在太繁琐，所以，Python引入了with语句来自动帮我们调用close()方法：</p>

<pre><code class="language-text">with open(&#39;/path/to/file&#39;, &#39;r&#39;) as f:
    print(f.read())
</code></pre>

<p>这和前面的try ... finally是一样的，但是代码更佳简洁，并且不必调用f.close()方法。</p>

<p>调用read()会一次性读取文件的全部内容，如果文件有10G，内存就爆了，所以，要保险起见，可以反复调用read(size)方法，每次最多读取size个字节的内容。另外，调用readline()可以每次读取一行内容，调用readlines()一次读取所有内容并按行返回list。因此，要根据需要决定怎么调用。</p>

<p>如果<strong>文件很小</strong>，read()一次性读取最方便；如果不能确定文件大小，反复调用read(size)比较保险；如果是配置文件，调用readlines()<strong>最方便</strong>：</p>

<pre><code class="language-text">for line in f.readlines():
    print(line.strip()) # 把末尾的&#39;\n&#39;删掉
</code></pre>

<h3 id="toc_9">文件的打开方式</h3>

<table>
<thead>
<tr>
<th>模式</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>r</td>
<td>以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</td>
</tr>
<tr>
<td>rb</td>
<td>以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。</td>
</tr>
<tr>
<td>r+</td>
<td>打开一个文件用于读写。文件指针将会放在文件的开头。</td>
</tr>
<tr>
<td>rb+</td>
<td>以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。</td>
</tr>
<tr>
<td>w</td>
<td>打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该 文件不存在，创建新文件。</td>
</tr>
<tr>
<td>wb</td>
<td>以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td>
</tr>
<tr>
<td>w+</td>
<td>打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td>
</tr>
<tr>
<td>wb+</td>
<td>以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td>
</tr>
<tr>
<td>a</td>
<td>打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入 到已有内容之后。如果该文件不存在，创建新文件进行写入。</td>
</tr>
<tr>
<td>ab</td>
<td>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td>
</tr>
<tr>
<td>a+</td>
<td>打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</td>
</tr>
<tr>
<td>ab+</td>
<td>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</td>
</tr>
</tbody>
</table>

<h3 id="toc_10">字符编码</h3>

<p>要读取非UTF-8编码的文本文件，需要给open()函数传入encoding参数，例如，读取GBK编码的文件：</p>

<pre><code class="language-text"> f = open(&#39;/Users/michael/gbk.txt&#39;, &#39;r&#39;, encoding=&#39;gbk&#39;)
 f.read()
&#39;测试&#39;
</code></pre>

<p>遇到有些编码不规范的文件，你可能会遇到UnicodeDecodeError，因为在文本文件中可能夹杂了一些非法编码的   字符。遇到这种情况，open()函数还接收一个errors参数，表示如果遇到编码错误后如何处理。最简单的方式是直接忽略：</p>

<pre><code class="language-text">f = open(&#39;/Users/michael/gbk.txt&#39;, &#39;r&#39;, encoding=&#39;gbk&#39;, errors=&#39;ignore&#39;)
</code></pre>

<h4 id="toc_11">写文件</h4>

<p>写文件和读文件是一样的，唯一区别是调用open()函数时，传入标识符&#39;w&#39;或者&#39;wb&#39;表示写文本文件或写二进制文件：</p>

<pre><code class="language-text">f = open(&#39;/Users/michael/test.txt&#39;, &#39;w&#39;)
f.write(&#39;Hello, world!&#39;)
f.close()
</code></pre>

<p>你可以反复调用write()来写入文件，但是务必要调用f.close()来关闭文件。当我们写文件时，操作系统往往不  会立刻把数据写入磁盘，而是放到内存缓存起来，空闲的时候再慢慢写入。只有调用close()方法时，操作系统才保证把没有写入的数据全部写入磁盘。忘记调用close()的后果是数据可能只写了一部分到磁盘，剩下的丢失了。</p>

<p>所以，还是用with语句来得保险：</p>

<pre><code class="language-text">with open(&#39;/Users/michael/test.txt&#39;, &#39;w&#39;) as f: f.write(&#39;Hello, world!&#39;)
</code></pre>

<p>要写入特定编码的文本文件，请给open()函数传入encoding参数，将字符串自动转换成指定编码。</p>

<p>注意：以&#39;w&#39;模式写入文件时，如果文件已存在，会直接覆盖（相当于删掉后新写入一个文件）。如果我们希望追加到文件末尾怎么办？可以传入&#39;a&#39;以追加（append）模式写入。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[3. python数据类型]]></title>
    <link href="ryanhuo.github.io/15822327222539.html"/>
    <updated>2020-02-21T05:05:22+08:00</updated>
    <id>ryanhuo.github.io/15822327222539.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">字符串（str）</h2>

<h3 id="toc_1">字符串的定义</h3>

<p>我们在介绍数据类型的时候,简单介绍了一下字符串类型.因为字符串是Python语言中特别重要的概念(不仅是Python,在其他语言中也有着举重若轻的位置),我们详细的讲解一下字符串的用法。</p>

<p>我们已经知道了,单引号,双引号,包括三引号包围的字符组,就是字符串,例如</p>

<pre><code class="language-python">str = &#39;hello&#39;#定义字符串变量
str = &quot;helo&quot;#定义字符串变量
str = &quot;&quot;&quot;hello
hello&quot;&quot;&quot;#定义多行字符串变量
</code></pre>

<h3 id="toc_2">下标和切片</h3>

<h4 id="toc_3">下标索引</h4>

<p>下标在Python中的概念就是编号的意思, 字符串 元组 列表 都会经常用到下标的概念,我们可以根据下标找到它们所对应的元素.就好像生活中你要准备去看电影,电影票上的座位号找到对应的位置。</p>

<p>我们现在考虑这样⼀一个问题,例例如我们创建了一个字符串name = zhang ,我现在想取到名为 name 字符串里面的a字符.如何去取呢?,其实我们可以通过我们讲过的for循环来遍历这个字符串,通过这种方法来取出字符串里的字符,但是 Python 给我们提供了了更为简便的方法,我们就可以用下标来取出a 字符</p>

<pre><code class="language-python">name=&#39;zhangsan&#39;
print(name[2])
</code></pre>

<pre><code class="language-text">a
</code></pre>

<h4 id="toc_4">切片</h4>

<p>我们可以利用下表索引取到字符串里面对应的一个元素,但如果想要截取一段元素就要用到切片。</p>

<p>切片是指对操作的对象截取其中一部分的操作。<strong>字符串、列表、元组</strong>都支持切片操作。 <strong>切片的语法: [起始:结束:步长]</strong><br/>
我们以字符串为例例讲解。</p>

<p>如果取出一部分，则可以在中括号 [] 中，使用:</p>

<pre><code class="language-python">name = &#39;abcdef&#39;
print(name[0:3]) # 取 下标0~2 的字符
print(name[3:5]) # 取 下标为3、4 的字符
print(name[2:]) # 取 下标为2开始到最后的字符
#支持负数
name = &#39;abcdef&#39;
print(name[1:-1]) # 取  下标为1开始  到  最后第2个 之间的字符
</code></pre>

<pre><code class="language-text">abc
de
cdef
bcde
</code></pre>

<h3 id="toc_5">字符串的常见操作</h3>

<p>如有字符串mystr = &#39;hello world kkb&#39; ，以下是常见的操作</p>

<pre><code class="language-python">mystr = &#39;hello world kkb&#39;
</code></pre>

<h4 id="toc_6">find</h4>

<p>检测  是否包含在 mystr中，如果是返回开始的索引值，否则返回-1</p>

<pre><code class="language-text">mystr.find(str, start=0, end=len(mystr))

</code></pre>

<pre><code class="language-python">mystr.find(&#39;kkb&#39;)
</code></pre>

<pre><code class="language-text">12
</code></pre>

<pre><code class="language-python">mystr.find(&#39;kkb&#39;,0,10)#在mstr字符串串0-10下标范围查询
</code></pre>

<pre><code class="language-text">-1
</code></pre>

<h4 id="toc_7">index</h4>

<p>跟 find() 方法一样，只不过如果 str 不在 mystr中会报一个异常.</p>

<pre><code class="language-python">mystr.index(str, start=0, end=len(mystr))

</code></pre>

<pre><code class="language-python">mystr.index(&#39;ab&#39;)
</code></pre>

<pre><code class="language-text">---------------------------------------------------------------------------

ValueError                                Traceback (most recent call last)

&lt;ipython-input-9-46892962653f&gt; in &lt;module&gt;()
----&gt; 1 mystr.index(&#39;ab&#39;)


ValueError: substring not found
</code></pre>

<h4 id="toc_8">count</h4>

<p>返回str在start和end之间在mystr里面出现的次数。</p>

<pre><code class="language-python">mystr.count(str,start,end=len(mystr))
</code></pre>

<pre><code class="language-python">mystr.count(&#39;kkb&#39;)

</code></pre>

<pre><code class="language-text">1
</code></pre>

<h4 id="toc_9">replce</h4>

<p>把mystr中的str1替换成str2 ,如果count指定，则替换不超过count次。</p>

<pre><code class="language-python">mystr.replace(str1,str2,mystr.count(str1))

</code></pre>

<h4 id="toc_10">split</h4>

<p>以str为分隔符切片 mystr，如果maxsplit有指定值，则仅分隔maxsplit个子字符串。</p>

<pre><code class="language-text">mystr.split(str=&quot; &quot;, 2)

</code></pre>

<h4 id="toc_11">capitallize</h4>

<p>把字符串的第一个字母大写</p>

<pre><code class="language-python">mystr.capitalize()

</code></pre>

<pre><code class="language-text">&#39;Hello world kkb&#39;
</code></pre>

<h4 id="toc_12">title</h4>

<p>首字母大写</p>

<pre><code class="language-python">mystr.title()

</code></pre>

<pre><code class="language-text">&#39;Hello World Kkb&#39;
</code></pre>

<h4 id="toc_13">startswith</h4>

<p>检查字符串是否是以hello开头, 是则返回True，否则返False</p>

<pre><code class="language-python">mystr.startswith(&#39;hello&#39;)

</code></pre>

<pre><code class="language-text">True
</code></pre>

<h4 id="toc_14">endswith</h4>

<p>检查字符串是否以obj结尾，如果是则返回True，否则返False</p>

<pre><code class="language-python">mystr.endswith(&#39;obj&#39;)

</code></pre>

<pre><code class="language-text">False
</code></pre>

<h4 id="toc_15">lower</h4>

<p>转换mystr中所有大写字符为小写</p>

<pre><code class="language-text">mystr.lower()

</code></pre>

<h4 id="toc_16">upper</h4>

<p>转换mystr中所有小写字符为大写</p>

<pre><code class="language-text">mystr.upper()

</code></pre>

<h4 id="toc_17">ljust</h4>

<p>返回一个原字符串左对齐,并使用空格填充至长度width的新字符串</p>

<pre><code class="language-python">width=32
mystr.ljust(width)

</code></pre>

<pre><code class="language-text">&#39;hello world kkb                 &#39;
</code></pre>

<h4 id="toc_18">rjust</h4>

<p>返回一个原字符串右对齐,并使用空格填充至长度width的新字符串</p>

<pre><code class="language-python">mystr.rjust(width)

</code></pre>

<h4 id="toc_19">center</h4>

<p>返回一个原字符串居中对齐,并使用空格填充至长度width的新字符串</p>

<pre><code class="language-python">mystr.center()

</code></pre>

<h4 id="toc_20">lstrip</h4>

<p>删除mystr左边的空白字符串</p>

<pre><code class="language-python">mystr.lstrip()

</code></pre>

<h4 id="toc_21">rstrip</h4>

<p>删除mystr右边的空白字符串</p>

<pre><code class="language-python">mystr.rstrip()

</code></pre>

<h4 id="toc_22">strip</h4>

<p>删除mystr两端的空白字符串</p>

<pre><code class="language-python">mystr.strip()

</code></pre>

<pre><code class="language-python">a = &quot;\n\t kkb \t\n&quot; 
print(a)
a.strip()

</code></pre>

<pre><code class="language-text">     kkb    



&#39;kkb&#39;
</code></pre>

<h4 id="toc_23">rfind</h4>

<p>类似于 find() 函数，不不过是从右边开始查找.</p>

<pre><code class="language-python">mystr.find(str, start=0,end=len(mystr))

</code></pre>

<h4 id="toc_24">rindex</h4>

<p>类似于 index() ，不不过是从右边开始.</p>

<pre><code class="language-python">mystr.rindex(str, start=0,end=len(mystr))

</code></pre>

<h4 id="toc_25">partition</h4>

<p>把 mystr以str分割成三部分, str前， str和str后</p>

<pre><code class="language-text">mystr.partition(str)

</code></pre>

<h4 id="toc_26">rpartition</h4>

<p>类似于 partition()函数,不不过是从右边开始.</p>

<pre><code class="language-python">mystr.rpartition(str)

</code></pre>

<h4 id="toc_27">splitlines</h4>

<p>按照行分隔，返回一个包含各行作为元素的列表</p>

<pre><code class="language-python">mystr.splitlines()

</code></pre>

<h4 id="toc_28">join</h4>

<p>mystr中每个元素后面插入 str ,构造出⼀一个新的字符串</p>

<pre><code class="language-python">mystr.jion(str)

</code></pre>

<h2 id="toc_29">列表（list）</h2>

<h3 id="toc_30">列表简介</h3>

<p>Python内置的一种数据类型是列表： list 。 list 是一种有序的集合，可以随时添加和删除其中的元素，写在方括号之间、用逗号分隔开的数值列表。列表内的项目不必全是相同的类型。</p>

<p>例如：</p>

<pre><code class="language-python">list1= [&#39;spam&#39;,&#39;eggs&#39;,&#39;12&#39;,123]

</code></pre>

<p>注意：比C语言的数组强大的地方在于列表中的元素可以是<strong>不同类型的。</strong></p>

<h3 id="toc_31">列表的常见操作</h3>

<h4 id="toc_32">列表的长度</h4>

<pre><code class="language-python">#⽤用len()函数可以获得list元素的个数：
namesList = [&#39;xiaoWang&#39;,&#39;xiaoZhang&#39;,&#39;xiaoHua&#39;] 
len(namesList)

</code></pre>

<pre><code class="language-text">3
</code></pre>

<h4 id="toc_33">列表的访问</h4>

<p>用索引来访问 list 中每一个位置的元素，记得索引是<strong>从0开始的</strong>：</p>

<pre><code class="language-python">namesList = [&#39;xiaoWang&#39;,&#39;xiaoZhang&#39;,&#39;xiaoHua&#39;] 
print(namesList[0])
print(namesList[1]) 
print(namesList[2]) 
print(namesList[3])

</code></pre>

<pre><code class="language-text">xiaoWang
xiaoZhang
xiaoHua




---------------------------------------------------------------------------

IndexError                                Traceback (most recent call last)

&lt;ipython-input-42-c578a48b9b76&gt; in &lt;module&gt;()
      3 print(namesList[1])
      4 print(namesList[2])
----&gt; 5 print(namesList[3])



IndexError: list index out of range
</code></pre>

<p>注意：当索引超出了范围时，Python会报一个 IndexError 错误，所以，要确保索引不要越界，记得最后一个元素的索引是len(classmates) - 1 </p>

<p>如果要取最后一个元素，除了了计算索引位置外，还可以用-1做索引，直接获取最后一个元素：</p>

<pre><code class="language-python">print(namesList[-1])
#以此类推，可以获取倒数第2个、倒数第3个：
print(namesList[-2])
print(namesList[-3])

</code></pre>

<pre><code class="language-text">xiaoHua
xiaoZhang
xiaoWang
</code></pre>

<h4 id="toc_34">列表的切片</h4>

<p>切片: 根据下标的范围获取一部分数据，⽐比如: 列表，字符串可以使用切片。</p>

<p><strong>切片的使用格式</strong></p>

<p>数据[起始下标:结束下标:步长]</p>

<p>提示： 起始下标默认0， 结束下标是不包含， 步长默认是1</p>

<pre><code class="language-python"># 使用切片的方式获取一部分数据
my_str=[&#39;zhangsan&#39;,&#39;lisi&#39;,&#39;wangwu&#39;,45,781,&#39;erf&#39;]
result = my_str[1:4:1]
print(result)

#前三个
result = my_str[0:3] 
print(result)
result = my_str[:3] 
print(result)

</code></pre>

<pre><code class="language-text">[&#39;lisi&#39;, &#39;wangwu&#39;, 45]
[&#39;zhangsan&#39;, &#39;lisi&#39;, &#39;wangwu&#39;]
[&#39;zhangsan&#39;, &#39;lisi&#39;, &#39;wangwu&#39;]
</code></pre>

<h4 id="toc_35">添加元素( append , extend , insert )</h4>

<p>通过 append 可以向列列表添加元素</p>

<pre><code class="language-python">#定义变量量A，默认有3个元素
A = [&#39;xiaoWang&#39;,&#39;xiaoZhang&#39;,&#39;xiaoHua&#39;]

print(&quot;-----添加之前，列列表A的数据    &quot;)

for tempName in A: 
    print(tempName)
#提示、并添加元素
temp = input(&#39;请输入要添加的学生姓名:&#39;) 
A.append(temp)

print(&quot;-----添加之后，列列表A的数据    &quot;)
for tempName in A:
    print(tempName)


</code></pre>

<pre><code class="language-text">-----添加之前，列列表A的数据   
xiaoWang
xiaoZhang
xiaoHua
请输入要添加的学生姓名:huohuo
-----添加之后，列列表A的数据   
xiaoWang
xiaoZhang
xiaoHua
huohuo
</code></pre>

<p>通过 extend 可以将另⼀一个集合中的元素逐⼀一添加到列列表中</p>

<pre><code class="language-python">a = [1, 2]
b = [3, 4]
a.append(b)
print(a)
print(&#39;-----&#39;)
a.extend(b)
print(a)
print(&#39;-----&#39;)
# insert(index,object)` 在指定位置`index`前插入元素`object

a = [0, 1, 2]
a.insert(1, 3)
print(a)

</code></pre>

<pre><code class="language-text">[1, 2, [3, 4]]
-----
[1, 2, [3, 4], 3, 4]
-----
[0, 3, 1, 2]
</code></pre>

<h4 id="toc_36">修改元素</h4>

<p>修改元素的时候，要通过<strong>下标</strong>来确定要修改的是哪个元素，然后才能进行修改</p>

<pre><code class="language-python">#定义变量量A，默认有3个元素
A = [&#39;xiaoWang&#39;,&#39;xiaoZhang&#39;,&#39;xiaoHua&#39;]

print(&quot;-----修改之前，列列表A的数据    &quot;)
for tempName in A: print(tempName)

#修改元素
A[1] = &#39;xiaoLu&#39;

print(&quot;-----修改之后，列列表A的数据    &quot;)
for tempName in A: print(tempName)


</code></pre>

<pre><code class="language-text">-----修改之前，列列表A的数据   
xiaoWang
xiaoZhang
xiaoHua
-----修改之后，列列表A的数据   
xiaoWang
xiaoLu
xiaoHua
</code></pre>

<h4 id="toc_37">查找元素</h4>

<p>所谓的查找，就是看看指定的元素是否存在。</p>

<p>python中查找的常用方法为：</p>

<ul>
<li><p>in （存在）,如果存在那么结果为 true ，否则为 false</p></li>
<li><p>not in （不存在），如果不存在那么结果为 true ，否则 false</p></li>
</ul>

<pre><code class="language-python">#待查找的列表
nameList = [&#39;xiaoWang&#39;,&#39;xiaoZhang&#39;,&#39;xiaoHua&#39;]

#获取用户要查找的名字
findName = input(&#39;请输入要查找的姓名:&#39;)

#查找是否存在
if findName in nameList:
    print(&#39;在字典中找到了了相同的名字&#39;)
else:
    print(&#39;没有找到&#39;)

</code></pre>

<pre><code class="language-text">请输入要查找的姓名:Ryan
没有找到
</code></pre>

<p>index 和 count 与字符串中的用法相同</p>

<pre><code class="language-python">a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;, &#39;b&#39;]
a.index(&#39;a&#39;, 1, 3) # 注意左闭右开区间

</code></pre>

<pre><code class="language-text">---------------------------------------------------------------------------

ValueError                                Traceback (most recent call last)

&lt;ipython-input-2-5317aed0f6cc&gt; in &lt;module&gt;()
      1 a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;, &#39;b&#39;]
----&gt; 2 a.index(&#39;a&#39;, 1, 3) # 注意左闭右开区间



ValueError: &#39;a&#39; is not in list
</code></pre>

<pre><code class="language-python">a.index(&#39;a&#39;,1,4)

</code></pre>

<pre><code class="language-text">3
</code></pre>

<pre><code class="language-python">a.count(&#39;b&#39;)

</code></pre>

<pre><code class="language-text">2
</code></pre>

<h4 id="toc_38">删除元素</h4>

<p>列表元素的常用删除方法有：</p>

<ul>
<li><p>del：根据下标进行删除pop：</p></li>
<li><p>删除最后一个元素remove：</p></li>
<li><p>根据元素的值进行删除</p></li>
</ul>

<ol>
<li>del</li>
</ol>

<pre><code class="language-python">list1 = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;]

print(&#39;------删除之前&#39;)
for tempName in list1:
    print(tempName)

movieName=list1  
del movieName[2]

print(&#39;------ 删除之后 &#39;)
for tempName in list1:
    print(tempName)

</code></pre>

<pre><code class="language-text">------删除之前
a
b
c
d
e
f
------ 删除之后 
a
b
d
e
f
</code></pre>

<ol>
<li>pop</li>
</ol>

<pre><code class="language-python">list2 = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;]

print(&#39;------删除之前   &#39;)
for tempName in list2:
    print(tempName)

movieName=list2  
movieName.pop()


print(&#39;------删除之后   &#39;)
for tempName in list2:
    print(tempName)


</code></pre>

<pre><code class="language-text">------删除之前  
a
b
c
d
e
f
------删除之后  
a
b
c
d
e
</code></pre>

<ol>
<li>remove</li>
</ol>

<pre><code class="language-python">list2 = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;]

print(&#39;------删除之前   &#39;)
for tempName in list2:
    print(tempName)

movieName=list2  
movieName.remove(&#39;e&#39;)


print(&#39;------删除之后   &#39;)
for tempName in list2:
    print(tempName)

</code></pre>

<pre><code class="language-text">------删除之前  
a
b
c
d
e
f
------删除之后  
a
b
c
d
f
</code></pre>

<ol>
<li><p>排序<br/>
sort 方法是将 list 按特定顺序重新排列，默认为由小到大，参数 reverse=True 可改为倒序，由大到小。</p>
<p>reverse 方法是将 list 逆置。</p></li>
</ol>

<pre><code class="language-python">a=[1,4,3,2]
print(a)
a.sort()
print(a)

</code></pre>

<pre><code class="language-text">[1, 4, 3, 2]
[1, 2, 3, 4]
</code></pre>

<pre><code class="language-python">a=[1,4,3,2]
print(a)
a.reverse()
print(a)

</code></pre>

<pre><code class="language-text">[1, 4, 3, 2]
[2, 3, 4, 1]
</code></pre>

<pre><code class="language-python">a=[1,4,3,2]
print(a)
print(&#39;-----&#39;)
a.sort(reverse=True)
print(a)
print(&#39;-----&#39;)
a.sort(reverse=False)
print(a)

</code></pre>

<pre><code class="language-text">[1, 4, 3, 2]
-----
[4, 3, 2, 1]
-----
[1, 2, 3, 4]
</code></pre>

<h3 id="toc_39">列表的遍历</h3>

<h4 id="toc_40">使用for循环</h4>

<p>为了更有效率的输出<strong>列表的每个数据</strong>，可以使用循环来完成</p>

<pre><code class="language-python">namesList = [&#39;xiaoWang&#39;,&#39;xiaoZhang&#39;,&#39;xiaoHua&#39;] 
for name in namesList:
    print(name)

</code></pre>

<pre><code class="language-text">xiaoWang
xiaoZhang
xiaoHua
</code></pre>

<h4 id="toc_41">使用while循环</h4>

<p>为了更有效率的输出<strong>列表的每个数据</strong>，可以使用循环来完成</p>

<pre><code class="language-python">namesList = [&#39;xiaoWang&#39;,&#39;xiaoZhang&#39;,&#39;xiaoHua&#39;] 
lenth=len(namesList)
i=0
while i &lt; lenth:
    print(namesList[i])
    i+=1

</code></pre>

<pre><code class="language-text">xiaoWang
xiaoZhang
xiaoHua
</code></pre>

<h2 id="toc_42">元组（tuple）</h2>

<p>另一种有序列列表叫元组：tuple。 tuple和list非常类似，但是 tuple一旦初始化就不能修改，比如同样是列出同学的名字：</p>

<pre><code class="language-python">classmates = (&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;)

</code></pre>

<p>现在， classmates这个tuple不能变了，它也没有append()，insert( )这样的方法。其他获取元素的方法和list是一样的，你可以正常地使用 classmates[0] ， classmates[-1] ，但不能赋值成另外的元素。</p>

<p>不可变的tuple有什什么意义？因为tuple不不可变，所以代码更安全。如果可能，能用tuple代list就尽量用tuple。</p>

<p>如果要定义一个空的tuple，可以写成()：</p>

<pre><code class="language-python">t=()
print(t,type(t))

</code></pre>

<pre><code class="language-text">() &lt;class &#39;tuple&#39;&gt;
</code></pre>

<p>但是，要定义一个只有1个元素的tuple ，如果你这么定义：</p>

<pre><code class="language-python">t=(1)
print(t,type(t))

</code></pre>

<pre><code class="language-text">1 &lt;class &#39;int&#39;&gt;
</code></pre>

<p>定义的不是tuple，是1这个数！这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这 就产生了了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是1。</p>

<p>所以，只有1个元素的tuple定义时必须加一个逗号，来消除歧义：</p>

<pre><code class="language-python">t=(1,)
print(t,type(t))

</code></pre>

<pre><code class="language-text">(1,) &lt;class &#39;tuple&#39;&gt;
</code></pre>

<p>Python在显示只有1个元素的tuple时，也会加一个逗号，以免你误解成数学计算意义上的括号。</p>

<pre><code class="language-python">t = (&#39;a&#39;, &#39;b&#39;, [&#39;A&#39;, &#39;B&#39;])
t[2][0] = &#39;X&#39;
t[2][1] = &#39;Y&#39;
t

</code></pre>

<pre><code class="language-text">(&#39;a&#39;, &#39;b&#39;, [&#39;X&#39;, &#39;Y&#39;])
</code></pre>

<p>最后来看一个<strong>“可变的”</strong>tuple</p>

<h2 id="toc_43">字典（dict）</h2>

<h3 id="toc_44">字典简介</h3>

<p>字典是另一种可变容器器模型，且可存储任意类型对象。</p>

<p>字典的每个键值(<strong>key=&gt;value</strong>)对用冒号(:)分割，每个对之间用逗号(,)分割，整个字典包括在花括号{}中</p>

<p>举个例子，假设要根据同学的名字查找对应的成绩，如果用 list 实现，需要两个 list ：</p>

<pre><code class="language-text">names = [&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;]
scores = [95, 75, 85]

</code></pre>

<p>给定一个名字，要查找对应的成绩，就先要在 names 中找到对应的位置，再从 scores 取出对应的成绩， list 越长，耗时越长。</p>

<p>如果用 dict 实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大， 查找速度都不不会变慢。用Python写一个 dict 如下：</p>

<pre><code class="language-python">d = {&#39;Michael&#39;: 95, &#39;Bob&#39;: 75, &#39;Tracy&#39;: 85}
d[&#39;Michael&#39;]

</code></pre>

<pre><code class="language-text">95
</code></pre>

<p>由于一个 key 只能对应⼀一个 value ，所以，多次对一个 key 放入 value ，后面的值会把前面的值冲掉：</p>

<pre><code class="language-python">d[&#39;Ryan&#39;]=100
d[&#39;Ryan&#39;]

</code></pre>

<pre><code class="language-text">100
</code></pre>

<pre><code class="language-python">d[&#39;Ryan&#39;]=99
d[&#39;Ryan&#39;]

</code></pre>

<pre><code class="language-text">99
</code></pre>

<p>如果key不不存在，dict就会报错：</p>

<pre><code class="language-python">d[&#39;Thomas&#39;]

</code></pre>

<pre><code class="language-text">---------------------------------------------------------------------------

KeyError                                  Traceback (most recent call last)

&lt;ipython-input-40-bf27a9c462ee&gt; in &lt;module&gt;()
----&gt; 1 d[&#39;Thomas&#39;]



KeyError: &#39;Thomas&#39;
</code></pre>

<h3 id="toc_45">字典的常见操作</h3>

<h4 id="toc_46">修改元素</h4>

<p>字典的每个元素中的数据是可以修改的，只要通过 key 找到，即可修改</p>

<pre><code class="language-python">info = {&#39;name&#39;:&#39;kkb&#39;, &#39;id&#39;:100, &#39;sex&#39;:&#39;f&#39;, &#39;address&#39;:&#39;中国北北京&#39;}
new_id = input(&#39;请输入新的学号:&#39;)
info[&#39;id&#39;] = int(new_id)
print(&#39;修改之后的id为: %d&#39; % info[&#39;id&#39;])

</code></pre>

<pre><code class="language-text">请输入新的学号:12
修改之后的id为: 12
</code></pre>

<h4 id="toc_47">添加元素</h4>

<ol>
<li>访问不不存在的元素</li>
</ol>

<pre><code class="language-python">info = {&#39;name&#39;:&#39;kkb&#39;, &#39;sex&#39;:&#39;f&#39;, &#39;address&#39;:&#39;中国北北京&#39;}
print(&#39;id为:%d&#39; % info[&#39;id&#39;])

</code></pre>

<pre><code class="language-text">---------------------------------------------------------------------------

KeyError                                  Traceback (most recent call last)

&lt;ipython-input-43-0f8e22620be6&gt; in &lt;module&gt;()
      1 #访问不不存在的元素
      2 info = {&#39;name&#39;:&#39;kkb&#39;, &#39;sex&#39;:&#39;f&#39;, &#39;address&#39;:&#39;中国北北京&#39;}
----&gt; 3 print(&#39;id为:%d&#39; % info[&#39;id&#39;])



KeyError: &#39;id&#39;
</code></pre>

<p>如果在使用变量量名[&#39;键&#39;] = 数据 时，这个“键”在字典中，不存在，那么就会新增这个元素。</p>

<ol>
<li>添加新的元素</li>
</ol>

<pre><code class="language-python">info = {&#39;name&#39;:&#39;kkb&#39;, &#39;sex&#39;:&#39;f&#39;, &#39;address&#39;:&#39;中国北北京&#39;}
# print(&#39;id为:%d&#39;%info[&#39;id&#39;])#程序会终端运⾏行行，因为访问了了不不存在的键
newId = input(&#39;请输入新的学号：&#39;)
info[&#39;id&#39;] =int(newId)

print(&#39;添加之后的id为:%d&#39; % info[&#39;id&#39;])

</code></pre>

<pre><code class="language-text">请输入新的学号：345
添加之后的id为:345
</code></pre>

<ol>
<li><p>删除元素<br/>
对字典进行删除操作，有以一下几种：</p></li>
</ol>

<ul>
<li>del</li>
<li>clear()</li>
</ul>

<p><strong>del删除指定的元素</strong></p>

<pre><code class="language-python">info = {&#39;name&#39;:&#39;kkb&#39;, &#39;sex&#39;:&#39;f&#39;, &#39;address&#39;:&#39;中国北北京&#39;}

print(&#39;删除前,%s&#39; % info[&#39;name&#39;])

del info[name]

print(&#39;删除后,%s&#39; % info[&#39;name&#39;])
#删除后不存在name字段

</code></pre>

<pre><code class="language-text">删除前,kkb


---------------------------------------------------------------------------

KeyError                                  Traceback (most recent call last)

&lt;ipython-input-55-02d163400996&gt; in &lt;module&gt;()
      3 print(&#39;删除前,%s&#39; % info[&#39;name&#39;])
      4 
----&gt; 5 del info[name]
      6 
      7 print(&#39;删除后,%s&#39; % info[&#39;name&#39;])



KeyError: &#39;xiaoHua&#39;
</code></pre>

<p><strong>del删除整个字典</strong></p>

<pre><code class="language-text">info = {&#39;name&#39;:&#39;monitor&#39;, &#39;sex&#39;:&#39;f&#39;, &#39;address&#39;:&#39;China&#39;}
print(&#39;删除前,%s&#39; % info)
del info
print(&#39;删除后,%s&#39; % info)

</code></pre>

<p><strong>clear清空整个字典</strong></p>

<pre><code class="language-text">info = {&#39;name&#39;:&#39;monitor&#39;, &#39;sex&#39;:&#39;f&#39;, &#39;address&#39;:&#39;China&#39;}
print(&#39;清空前,%s&#39; % info)
info.clear()
print(&#39;删除后,%s&#39; % info)

</code></pre>

<p><strong>keys</strong></p>

<p>返回一个包含字典所有key的列列表</p>

<pre><code class="language-python">d1 = {&#39;name&#39;:&#39;abc&#39;,&#39;age&#39;:&#39;18&#39;, &#39;class&#39;:&#39;cnh&#39;} 
print(list(d1.keys()))

</code></pre>

<pre><code class="language-text">[&#39;name&#39;, &#39;age&#39;, &#39;class&#39;]
</code></pre>

<p><strong>values</strong></p>

<p>返回一个包含字典所有value的列表</p>

<pre><code class="language-python">d1 = {&#39;name&#39;:&#39;abc&#39;,&#39;age&#39;:&#39;18&#39;, &#39;class&#39;:&#39;cnh&#39;} 
print(list(d1.values()))

</code></pre>

<pre><code class="language-text">[&#39;abc&#39;, &#39;18&#39;, &#39;cnh&#39;]
</code></pre>

<p><strong>items</strong><br/>
返回一个包含<strong>所有（值，键）</strong>元祖的列表</p>

<pre><code class="language-python">d1 = {&#39;name&#39;:&#39;abc&#39;,&#39;age&#39;:&#39;18&#39;, &#39;class&#39;:&#39;cnh&#39;} 
print(list(d1.items()))

</code></pre>

<pre><code class="language-text">[(&#39;name&#39;, &#39;abc&#39;), (&#39;age&#39;, &#39;18&#39;), (&#39;class&#39;, &#39;cnh&#39;)]
</code></pre>

<h2 id="toc_48">集合（set）</h2>

<p>集合（set）是一个无序的<strong>不重复元素</strong>序列。<br/>
可以使用大括号 { } 或者 set() 函数创建集合，注意：创建一个空集合必须用 set() 而不不是 { }，因为 { }是用来创建⼀一个空字典。</p>

<pre><code class="language-python">my_set = {1, 4, &#39;abc&#39;, &#39;hello&#39;}
# 不支持下标赋值和取值
# my_set[0] = 3
# value = my_set[0] # print(value)
# print(value)

#支持通过遍历获取数据
for value in my_set:
    print(value)

</code></pre>

<pre><code class="language-text">1
hello
4
abc
</code></pre>

<pre><code class="language-python">my_set2={1,4,7}
for index,value in enumerate(my_set2):
    print(index,value)

</code></pre>

<pre><code class="language-text">0 1
1 4
2 7
</code></pre>

<pre><code class="language-python"># 定义空的集合的时候不能直接使用{}
my_set = set()
my_set.add(1) 
my_set.add(1)
print(my_set, type(my_set))

# 集合可以对容器器类型数据去重
my_list = [1, 1, 3, 5, 3]
# 把列列表转成集合，会把数据去重
my_set = set(my_list)
print(my_set)

# 列列表，元组， 集合 三者之间可以相互转换
my_tuple = (5, 3)
print(my_tuple, type(my_tuple))


</code></pre>

<pre><code class="language-text">{1} &lt;class &#39;set&#39;&gt;
{1, 3, 5}
(5, 3) &lt;class &#39;tuple&#39;&gt;
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[5.python面向对象]]></title>
    <link href="ryanhuo.github.io/15822327222566.html"/>
    <updated>2020-02-21T05:05:22+08:00</updated>
    <id>ryanhuo.github.io/15822327222566.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">匿名函数</h2>

<p>顾名思义就是函数没有名字，使用lambda关键字定义的函数就是匿名函数,简化代码，增加运行效率。 特点： 匿名函数只适合做一下简单的操作，返回值不需要加上return。</p>

<pre><code class="language-python">#普通函数
def func(a,b,c):
    return a+b+c
print(func(1,3,4))
</code></pre>

<pre><code class="language-text">8
</code></pre>

<pre><code class="language-python">#匿名函数
result=(lambda a,b,c:a+b+c)(1,3,4)
# 匿名函数也是函数
print(result)
</code></pre>

<pre><code class="language-text">8
</code></pre>

<pre><code class="language-python"># 对字典列表排序的时候还可以使用匿名函数
my_list={&#39;age&#39;:23,&#39;name&#39;:&#39;张三&#39;}
def get_value(item):
    return item[&#39;age&#39;]

get_value(my_list)

# my_list.sort(key=get_value,reverse=True)print(my_list)
</code></pre>

<pre><code class="language-text">23
</code></pre>

<h2 id="toc_1">面向对象的编程</h2>

<p>面向对象编程——Object Oriented Programming，简称<strong>OOP</strong>，是一种程序设计思想。OOP把对象作为程序的<strong>基本单元</strong>，一个对象包含了数据和操作数据的函数。</p>

<p><strong>面向过程</strong>的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。</p>

<p>而<strong>面向对象</strong>的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。</p>

<p>在Python中，<strong>所有数据类型都可以视为对象</strong>，当然也可以自定义对象。自定义的对象数据类型就是面向对象中的类（Class）的概念。</p>

<p>我们以一个例子来说明面向过程和面向对象在程序流程上的不同之处。</p>

<p>假设我们要处理学生的成绩表，为了表示一个学生的成绩，面向过程的程序可以用一个dict表示：</p>

<pre><code class="language-python">std1 = { &#39;name&#39;: &#39;Curry&#39;, &#39;score&#39;: 98 }
std2 = { &#39;name&#39;: &#39;James&#39;, &#39;score&#39;: 81 }
</code></pre>

<p>而处理学生成绩可以通过函数实现，比如打印学生的成绩：</p>

<pre><code class="language-python">def print_score(std):
    print(&#39;%s: %s&#39; % (std[&#39;name&#39;], std[&#39;score&#39;]))
</code></pre>

<p>如果采用<strong>面向对象的程序设计思想</strong>，我们首选思考的不是程序的执行流程，而是Student这种数据类型应该被视为一个对象，这个对象拥有name和score这两个<strong>属性</strong>（Property）。如果要打印一个学生的成绩，首先必须创建出这 个学生对应的对象，然后，给对象发一个print_score消息，让对象自己把自己的数据打印出来。</p>

<pre><code class="language-python">class Student(object):
    def init (self, name, score): 
        self.name = name
        self.score = score

    def print_score(self):
        print(&#39;%s: %s&#39; % (self.name, self.score))
</code></pre>

<p>给对象发消息实际上就是调用对象对应的关联函数，我们称之为对象的<strong>方法</strong>（Method）。面向对象的程序写出来就像这样：</p>

<pre><code class="language-text">bart = Student(&#39;Bart Simpson&#39;, 59) 
lisa = Student(&#39;Lisa Simpson&#39;, 87) 
bart.print_score() 
lisa.print_score()
</code></pre>

<p>面向对象的设计思想是从自然界中来的，因为在自然界中，<strong>类</strong>（Class）和<strong>实例</strong>（Instance）的概念是很自然的。</p>

<p>Class是一种抽象概念，比如我们定义的Class——Student，是指学生这个概念，而<strong>实例（</strong><strong>Instance</strong><strong>）</strong>则是一个个具  体的Student，比如，Bart Simpson和Lisa Simpson是两个具体的Student。</p>

<p>所以，面向对象的设计思想是抽象出Class，根据Class创建Instance。</p>

<p>面向对象的抽象程度又比函数要高，因为一个Class既包含数据，又包含操作数据的方法。</p>

<h2 id="toc_2">类和对象</h2>

<p><strong>面向对象编程</strong>的2个非常重要的概念：<strong>类和对象</strong></p>

<p><strong>对象</strong>是面向对象编程的核心，在使用对象的过程中，为了将具有共同特征和行为的一组对象抽象定义，提出了另外一个新的概念——<strong>类</strong></p>

<p><strong>类</strong>就相当于制造飞机时的图纸，用它来进行创建的飞机就相当于<strong>对象</strong>。</p>

<blockquote>
<p><strong>补充：</strong></p>

<ul>
<li>需求：做一道西红柿炒鸡蛋</li>
</ul>

<p><strong>方法1</strong>：按步骤一步一步制作（面向过程）——<strong>[将每个过程打包成函数，需要时依次调用]</strong></p>

<p><strong>方法2</strong>：制作一台机器人，告诉机器人炒菜（面向对象）——<strong>[打包成类与对象]</strong></p>

<p><strong>类</strong>作为母版制作出很多<strong>对象</strong></p>
</blockquote>

<h3 id="toc_3">类</h3>

<p>人以类聚物以群分。 具有相似内部状态和运动规律的实体的集合(或统称为抽象)。 具有相同<strong>属性</strong>和<strong>行为</strong>事物的统称类是抽象的,在使用的时候通常会找到这个类的一个具体的存在,使用这个具体的存在。<strong>一个类可以找到多个对象</strong></p>

<p><img src="media/15822327222566/1.13.jpg" alt=""/></p>

<h3 id="toc_4">对象</h3>

<p>某一个具体事物的存在 ,在现实世界中可以是看得见摸得着的。 可以是直接使用的</p>

<p><img src="media/15822327222566/1.14.jpg" alt=""/></p>

<h3 id="toc_5">类和对象之间的关系</h3>

<p><img src="media/15822327222566/1.15.jpg" alt=""/></p>

<h3 id="toc_6">定义类和创建对象</h3>

<p>定义一个类，格式如下：</p>

<pre><code class="language-text">class 类名:

方法列表

# class Hero: # 经典类（旧式类）定义形式
# class Hero():

class Hero(object): # 新式类定义形式
    def info(self): 
        print(&quot;hero&quot;)
</code></pre>

<p><strong>说明：</strong></p>

<ul>
<li><p>定义类时有2种形式：<strong>新式类和经典类</strong>，上面代码中的Hero为新式类，前两行注释部分则为经典类；</p></li>
<li><p>object 是Python 里所有类的最顶级父类； 类名 的命名规则按照&quot;大驼峰命名法&quot;；</p></li>
<li><p>info 是一个实例方法，第一个参数一般是self，表示实例对象本身，当然了可以将self换为其它的名字，其作用是一个变量 这个变量指向了实例对象.</p></li>
<li><p>python中，可以根据已经定义的类去创建出一个或多个对象。</p></li>
</ul>

<p><strong>创建对象的格式为</strong></p>

<p>对象名1 = 类名() </p>

<p>对象名2 = 类名() </p>

<p>对象名3 = 类名()</p>

<pre><code class="language-python">class Hero(object): # 新式类定义形式
    &#39;&#39;&#39;info 是一个实例方法，类对象可以调用实例方法，实例方法的第一个参数一定是self&#39;&#39;&#39;
    def info(self):
        &#39;&#39;&#39;当对象调用实例方法时，Python会自动将对象本身的引用做为参数， 传递到实例方法的第一个参数self里&#39;&#39;&#39;
        print(self)
        print(&quot;self各不同，对象是出处。&quot;)

# Hero这个类 实例化了一个对象
hero = Hero()

# 对象调用实例方法info()，执行info()里的代码
# . 表示选择属性或者方法
hero.info()
print(hero) # 打印对象，则默认打印对象在内存的地址，结果等同于info里的print(self)
</code></pre>

<pre><code class="language-text">&lt;__main__.Hero object at 0x0000000005413EF0&gt;
self各不同，对象是出处。
&lt;__main__.Hero object at 0x0000000005413EF0&gt;
</code></pre>

<h3 id="toc_7">补充：类与对象</h3>

<pre><code class="language-python">#类的使用
class 成绩单():
    @classmethod#类的方法（函数）同类的属性（变量）结合
    #类的属性作为类方法的参数
    def 录入成绩单(cls):
        cls.学生姓名=input(&#39;请输入学生姓名：&#39;)
        cls.语文_成绩=int(input(&#39;请输入语文成绩：&#39;))
        cls.数学_成绩=int(input(&#39;请输入数学成绩：&#39;))
    @classmethod
    def 打印成绩单(cls):
        print(cls.学生姓名+&#39;的成绩如下：&#39;)
        print(&#39;语文成绩：&#39;+str(cls.语文_成绩))
        print(&#39;语文成绩：&#39;+str(cls.语文_成绩))
    
成绩单.录入成绩单()
成绩单.打印成绩单()
</code></pre>

<pre><code class="language-text">请输入学生姓名：Ryan
请输入语文成绩：100
请输入数学成绩：99
Ryan的成绩如下：
语文成绩：100
语文成绩：100
</code></pre>

<pre><code class="language-python">#实例化
class 成绩单():
    #①
    def 录入成绩单(self):#②
        self.学生姓名=input(&#39;请输入学生姓名：&#39;)
        self.语文_成绩=int(input(&#39;请输入语文成绩：&#39;))
        self.数学_成绩=int(input(&#39;请输入数学成绩：&#39;))
#③
    def 打印成绩单(self):
        print(self.学生姓名+&#39;的成绩如下：&#39;)
        print(&#39;语文成绩：&#39;+str(self.语文_成绩))
        print(&#39;语文成绩：&#39;+str(self.语文_成绩))

#④
成绩单1=成绩单()#实例化得到成绩单1
#调用实例化变量
成绩单1.录入成绩单()
成绩单1.打印成绩单()
</code></pre>

<pre><code class="language-text">请输入学生姓名：Ryan
请输入语文成绩：34
请输入数学成绩：53
Ryan的成绩如下：
语文成绩：34
语文成绩：34
</code></pre>

<p><strong>对比分析</strong>：</p>

<ul>
<li><p>①是空着的，意思是这里不再需要@classmethod的声明</p></li>
<li><p>第②处，把cls替换成了 self.</p></li>
<li><p>实例化后再使用的格式，需要先赋值然后再调用(第③处)在第④步骤， 我们需要用实例名=类(的方式(实例名其实就是任取一个变量名)，为类创建一个实例， 然后再使用实例名函数0的方式调用对应的方法。</p></li>
</ul>

<h2 id="toc_8">对象的属性和方法</h2>

<h3 id="toc_9">添加和获取对象的属性</h3>

<pre><code class="language-python">class Hero(object):
    &quot;&quot;&quot;定义了一个英雄类，可以移动和攻击&quot;&quot;&quot; 
    def move(self):
        &quot;&quot;&quot;实例方法&quot;&quot;&quot;
        print(&quot;正在前往事发地点...&quot;)
# 实例化了一个英雄对象

hero = Hero()
# 给对象添加属性，以及对应的属性值
hero.name = &quot;德玛西亚&quot; # 姓名
hero.hp = 2600 # 生 命 值
# 通过.成员选择运算符，获取对象的属性值
print(&quot;英雄 %s 的生命值 :%d&quot; % (hero.name, hero.hp))

# 通过.成员选择运算符，获取对象的实例方法
hero.move()

</code></pre>

<pre><code class="language-text">英雄 德玛西亚 的生命值 :2600
正在前往事发地点...
</code></pre>

<h3 id="toc_10">通过self获取对象属性</h3>

<pre><code class="language-python"> class Hero(object):
    &quot;&quot;&quot;定义了一个英雄类，可以移动和攻击&quot;&quot;&quot;
    def move(self):
        &quot;&quot;&quot;实例方法&quot;&quot;&quot;
        print(&quot;正在前往事发地点...&quot;)

    def info(self):
        &quot;&quot;&quot;在类的实例方法中，通过self获取该对象的属性&quot;&quot;&quot;
        print(&quot;英雄 %s 的生命值 :%d&quot; % (self.name, self.hp))

# 实例化了一个英雄对象
 hero = Hero()

# 给对象添加属性，以及对应的属性值
hero.name = &quot;德玛西亚&quot; # 姓名
hero.hp = 2600 # 生 命 值

# 通过.成员选择运算符，获取对象的实例方法

hero.info() # 只需要调用实例方法info()，即可获取英雄的属性
hero.move()

</code></pre>

<pre><code class="language-text">英雄 德玛西亚 的生命值 :2600
正在前往事发地点...
</code></pre>

<h3 id="toc_11">init魔法方法</h3>

<h4 id="toc_12">init方法</h4>

<pre><code class="language-text">class Hero(object):
    &quot;&quot;&quot;定义了一个英雄类，可以移动和攻击&quot;&quot;&quot;
#Python 的类里提供的，两个下划线开始，两个下划线结束的方法，就是魔法方法， init ()就是一个魔法方法， 通常用来做属性初始化 或 赋值 操作。

# 如果类面没有写__init__方法，Python会自动创建，但是不执行任何操作，

# 如果为了能够在完成自己想要的功能，可以自己定义__init__方法，

# 所以一个类里无论自己是否编写 __init__方法 一定有__init__方法。

    def __init__(self):
        &quot;&quot;&quot; 方法，用来做变量初始化 或 赋值 操作，在类实例化对象的时候，会被自动调用&quot;&quot;&quot; 
        self.name = &quot;hero&quot; # 姓 名
        self.hp = 2600 # 生命值
    def move(self):
        &quot;&quot;&quot;实例方法&quot;&quot;&quot;
        print(&quot;正在前往事发地点...&quot;)


# 实例化了一个英雄对象，并自动调用 init ()方法
hero = Hero()

# 通过.成员选择运算符，获取对象的实例方法
hero.info() # 只需要调用实例方法info()，即可获取英雄的属性
hero.move()

</code></pre>

<p><strong>总结</strong></p>

<ul>
<li>__init__()方法，在创建一个对象时默认被调用，不需要手动调用</li>
<li>__init__(self)中的self参数，不需要开发者传递，python解释器会自动把当前的对象引用传递过去。</li>
</ul>

<h4 id="toc_13">有参数的init（）方法</h4>

<pre><code class="language-python">class Hero(object):
    &quot;&quot;&quot;定义了一个英雄类，可以移动和攻击&quot;&quot;&quot;
    def __init__(self, name, hp):
        &quot;&quot;&quot; init () 方法，用来做变量初始化 或 赋值操作&quot;&quot;&quot;
# 英雄名
        self.name = name
# 生命值：
        self.hp = hp

    def move(self):
        &quot;&quot;&quot;实例方法&quot;&quot;&quot;
        print(&quot;%s 正在前往事发地点...&quot; % self.name)
    def info(self):
        print(&quot;英雄 %s 的生命值 :%d&quot; % (self.name, self.hp))



#实例化英雄对象时，参数会传递到对象的 init()方法里
blind = Hero(&#39;瞎哥&#39;,2600) 
gailun = Hero(&quot;盖伦&quot;,4200)

#print(gailun)

#print(blind)

  

# 不同对象的属性值的单独保存
print(id(blind.name)) 
print(id(gailun.name))

# 同一个类的不同对象，实例方法共享
print(id(blind.move())) 
print(id(gailun.move()))


</code></pre>

<pre><code class="language-text">87554072
87555744
瞎哥 正在前往事发地点...
2004853904
盖伦 正在前往事发地点...
2004853904
</code></pre>

<p><strong>注意：</strong></p>

<ul>
<li>通过一个类，可以创建多个对象，就好比 通过一个模具创建多个实体一样</li>
<li>__init__(self)中，默认有1个参数名字为self，如果在创建对象时传递了2个实参，那么init (self)中出了self作为第一个形参外还需要2个形参，例如 init (self,x,y)</li>
<li>在类内部获取 属性 和 实例方法，通过self获取；</li>
<li>在类外部获取 属性 和 实例方法，通过对象名获取。</li>
<li>如果一个类有多个对象，每个对象的属性是各自保存的，都有各自独立的地址；</li>
<li>但是实例方法是所有对象共享的，只占用一份内存空间。类会通过self来判断是哪个对象调用了实例方法。</li>
</ul>

<h2 id="toc_14">继承</h2>

<ul>
<li>在程序中，<strong>继承</strong>描述的是多个类之间的所属关系。</li>
<li>如果一个类A里面的属性和方法可以复用，则可以通过继承的方式，<strong>传递</strong>到类B里。 </li>
<li>那么类A就是<strong>基类</strong>，也叫做<strong>父类</strong>；类B就是<strong>派生类</strong>，也叫做<strong>子类</strong>。</li>
</ul>

<pre><code class="language-python"># 父 类
class A(object):
    def __init__(self):
        self.num = 10
        
    def print_num(self):
        print(self.num + 10)

# 子 类
class B(A): 
    pass

b = B()
print(b.num) 
b.print_num()

</code></pre>

<pre><code class="language-text">10
20
</code></pre>

<h3 id="toc_15">单继承</h3>

<p>子类只能继承一个父类</p>

<pre><code class="language-python">#定义一个Person类
class Person(object): 
    def __init__(self):
# 属 性
        self.name = &quot;女娲&quot;

    # 实例方法
    def make_person(self):
        print(&quot; &lt;%s&gt; 造了一个人...&quot; % self.name)

# 定义Teacher类，继承了 Person，则Teacher是子类，Person是父类。
class Teacher(Person):
# 子类可以继承父类所有的属性和方法，哪怕子类没有自己的属性和方法，也可以使用父类的属性和方法。
    pass

panda = Teacher() 
    # 创建子类实例对象
print(panda.name) 
    # 子类对象可以直接使用父类的属性
panda.make_person() 
    # 子类对象可以直接使用父类的方法
    

</code></pre>

<pre><code class="language-text">女娲
 &lt;女娲&gt; 造了一个人...
</code></pre>

<p><strong>总结</strong></p>

<ul>
<li>虽然子类没有定义 init 方法初始化属性，也没有定义实例方法，但是父类有。所以只要创建子类的对象，就默认执行了那个继承过来的 init 方法</li>
<li>子类在继承的时候，在定义类时，小括号()中为父类的名字</li>
<li>父类的<strong>属性、方法</strong>，会被继承给子类</li>
</ul>

<h3 id="toc_16">多继承</h3>

<p>子类继承多个父类</p>

<pre><code class="language-python">class Women(object): 
    def __init__(self):
        self.name = &quot;女娲&quot; # 实例变量，属性

    def make_person(self):          # 实例方法，方法
        print(&quot; &lt;%s&gt; 造了一个人...&quot; % self.name)
    
    def move(self):
        print(&quot;移动..&quot;)

class Man(object):
    def __init__(self):
        self.name = &quot;亚当&quot;

    def make_person(self):
        print(&quot;&lt;%s&gt; 造了一个人...&quot; % self.name)

    def run(self):
        print(&quot;跑..&quot;)

class Person(Women, Man): # 多继承，继承了多个父类
    pass

ls = Person() 
print(ls.name) 
ls.make_person()

# 子类的魔法属性 mro 决定了属性和方法的查找顺序
print(Person. mro)

</code></pre>

<pre><code class="language-text">女娲
 &lt;女娲&gt; 造了一个人...
&lt;built-in method mro of type object at 0x0000000004376698&gt;
</code></pre>

<p><strong>结论：</strong></p>

<ul>
<li><p>多继承可以继承多个父类，也继承了所有父类的属性和方法</p></li>
<li><p><strong>注意：</strong>如果多个父类中有同名的 属性和方法，则默认使用第一个父类的属性和方法（根据类的魔法属性mro 的顺序来查找）</p></li>
<li><p>多个父类中，不重名的属性和方法，不会有任何影响。</p></li>
</ul>

<h3 id="toc_17">重写父类方法</h3>

<p>子类继承父类，父类的方法满足不了子类的需要可以对父类的方法进行重写</p>

<p>**重写的特点: **</p>

<ol>
<li>继承关系，</li>
<li>方法名相同</li>
</ol>

<pre><code class="language-python">class Person(object): 
    def run(self):
        print(&quot;跑起来了&quot;)

class Student(Person):
    def __init__(self, name, age): 
        self.name = name
        self.age = age

# 因为父类的方法满足不了子类的需要，对其进行重写
    def run(self):
        print(&quot;%s跑起来了&quot; % self.name)

stu = Student(&quot;王五&quot;, 10)

# 调用方法的时候先从本类去找，如果本来没有再去父类去找，会遵循mro的特点

stu.run()

</code></pre>

<pre><code class="language-text">王五跑起来了
</code></pre>

<h3 id="toc_18">属性方法</h3>

<h4 id="toc_19">类属性和实例属性</h4>

<p><strong>类属性</strong>就是类对象所拥有的属性，它被所有类对象的实例对象所共有，在内存中只存在一个副本，这个和C++中类的静态成员变量有点类似。对于公有的类属性，在类外可以通过类对象和实例对象访问</p>

<pre><code class="language-python">class People(object):
    name = &#39;Tom&#39;# 公有的类属性
    __age = 12# 私有的类属性

p = People() 
print(p.name)   # 正 确
print(People.name)  # 正 确
# print(p.__age)    # 错误，不能在类外通过实例对象访问私有的类属性
# print(People.__age) # 错误，不能在类外通过类对象访问私有的类属性实例属性(对象属性)

class People(object):
    address = &#39;山东&#39;  # 类属性
    def __init__(self):
        self.name = &#39;xiaowang&#39;  # 实例属性
        self.age = 20   # 实例属性

p = People()
p.age = 12  # 实例属性
print(p.address)    # 正 确
print(p.name)       # 正 确
print(p.age)    # 正 确
print(People.address)   # 正 确
#print(People.name)     # 错 误
#print(People.age)  # 错 误

#通过实例(对象)去修改类属性
class People(object):
    country = &#39;china&#39; #类属性

    
print(People.country) 
p = People() 
print(p.country) 

p.country = &#39;japan&#39;
print(p.country)    # 实例属性会屏蔽掉同名的类属性
print(People.country)

del p.country # 删除实例属性
print(p.country)

</code></pre>

<pre><code class="language-text">Tom
Tom
山东
xiaowang
12
山东
china
china
japan
china
china
</code></pre>

<p><strong>总结</strong><br/>
如果需要在类外修改类属性，必须通过类对象去引用然后进行修改。如果通过实例对象去引用，会产生一个同名的实例属性，这种方式修改的是实例属性，不会影响到类属性，并且之后如果通过实例对象去引用该名称的属性，实例属性会强制屏蔽掉类属性，即引用的是实例属性，除非删除了该实例属性。</p>

<h4 id="toc_20">静态方法和类方法</h4>

<p><strong>1.类方法</strong></p>

<p>是类对象所拥有的方法，需要用修饰器@classmethod来标识其为类方法，对于类方法，第一个参数必须是类对象，  一般以cls作为第一个参数（当然可以用其他名称的变量作为其第一个参数，但是大部分人都习惯以&#39;cls&#39;作为第一个参数的名字，就最好用&#39;cls&#39;了），能够通过实例对象和类对象去访问。</p>

<pre><code class="language-python">class People(object): 
    country = &#39;china&#39;
#类方法，用classmethod来进行修饰
    @classmethod
    def get_country(cls): 
        return cls.country

p = People()
print(p.get_country())  #可以用过实例对象引用print(People.get_country())  #可以通过类对象引用类方法还有一个用途就是可以对类属性进行修改：

class People(object): 
    country = &#39;china&#39;
#类方法，用classmethod来进行修饰
    @classmethod
    def get_country(cls): 
        return cls.country

    @classmethod
    def set_country(cls,country): 
        cls.country = country

p = People()
print(p.get_country())  #可以用过实例对象访问print(People.get_country())  #可以通过类访问

p.set_country(&#39;japan&#39;)

print(p.get_country()) 
print(People.get_country())
#结果显示在用类方法对类属性修改之后，通过类对象和实例对象访问都发生了改变

</code></pre>

<pre><code class="language-text">china
china
japan
japan
</code></pre>

<p><strong>2. 静态方法</strong></p>

<p>需要通过修饰器@staticmethod来进行修饰，静态方法不需要多定义参数，可以通过对象和类来访问。</p>

<pre><code class="language-python">class People(object): 
    country = &#39;china&#39;
    @staticmethod #静态方法
    def get_country():
        return People.country

p = People()
# 通过对象访问静态方法
p.get_country()
# 通过类访问静态方法
print(People.get_country())

</code></pre>

<pre><code class="language-text">china
</code></pre>

<p><strong>总结</strong><br/>
从类方法和实例方法以及静态方法的定义形式就可以看出来，类方法的第一个参数是类对象cls，那么通过cls引用的   必定是类对象的属性和方法；  实例方法的第一个参数是实例对象self，那么通过self引用的可能是类属性、也有可能是实例属性（这个需要具体分析），不过在存在相同名称的类属性和实例属性的情况下，实例属性优先级更高。  静态方法中不需要额外定义参数，因此在静态方法中引用类属性的话，必须通过类实例对象来引用</p>

<h2 id="toc_21">多态</h2>

<ul>
<li>多态, 不同的子类对象调用相同的父类方法，产生不同的执行结果，可以增加代码的外部调用灵活度</li>
<li>多态以继承和重写父类方法为前提</li>
<li>多态是调用方法的技巧，不会影响到类的内部设计</li>
</ul>

<pre><code class="language-python">class Animal(object): 
    def run(self):
        print(&#39;Animal is running...&#39;) 

        
class Dog(object):
    def run(self):
        print(&#39;Dog is running...&#39;) 
    
    
class Cat(object):
    def run(self):
        print(&#39;Cat is running...&#39;)

# 定义一个方法
def run_twice(animal): 
    animal.run() 
    animal.run()

dog = Dog() 
cat = Cat()

run_twice(dog) 
run_twice(cat)

</code></pre>

<pre><code class="language-text">Dog is running...
Dog is running...
Cat is running...
Cat is running...
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[4. python函数]]></title>
    <link href="ryanhuo.github.io/15822327222611.html"/>
    <updated>2020-02-21T05:05:22+08:00</updated>
    <id>ryanhuo.github.io/15822327222611.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">函数的简介</h2>

<p>如果在开发程序时，需要某块代码多次，但是为了提高编写的效率以及代码的重用，所以把具有独立功能的代码块组织为一个小模块，这就是函数。你已经知道Python提供了许多内建函数，比如print()。但你也可以自己创建函数，这被叫做用户自定义函数。</p>

<p>例如：我们知道圆的面积计算公式为：\(S = πr^2\)</p>

<p>当我们知道半径r的值时，就可以根据公式计算出面积。假设我们需要计算3个不同大小的圆的面积：</p>

<pre><code class="language-text">r1 = 12.34
r2 = 9.08
r3 = 73.1
s1 = 3.14 * r1 * r1 s2 = 3.14 * r2 * r2 s3 = 3.14 * r3 * r3
</code></pre>

<p>当代码出现有规律的重复的时候，你就需要当心了，每次写3.14 * x * x不仅很麻烦，而且，如果要把3.14改成3.14159265359的时候，得全部替换。</p>

<p>有了函数，我们就不再每次写s = 3.14 * x * x，而是写成更有意义的函数调用s = area_of_circle(x)， 而函数area_of_circle本身只需要写一次，就可以多次调用。</p>

<p>基本上所有的高级语言都支持函数，Python也不例外。Python不但能非常灵活地定义函数，而且本身内置了很多有用的函数，可以直接调用。</p>

<h2 id="toc_1">函数定义和调用</h2>

<h3 id="toc_2">定义函数</h3>

<pre><code class="language-text">def 函数名(): 代码
# 定义一个函数，能够完成打印信息的功能
def printInfo():
print(&#39; &#39;)
print(&#39; 人生苦短，我用Python&#39;)
print(&#39; &#39;)
</code></pre>

<h3 id="toc_3">调用函数</h3>

<p>定义了函数之后，就相当于有了一个具有某些功能的代码，想要让这些代码能够执行，需要调用它调用函数很简单的，通过 函数名() 即可完成调用</p>

<pre><code class="language-text"># 定义完函数后，函数是不会自动执行的，需要调用它才可以
printInfo()
</code></pre>

<p><strong>注意:</strong></p>

<ul>
<li>每次调用函数时，函数都会从头开始执行，当这个函数中的代码执行完毕后，意味着调用结束了<br/></li>
<li>当然了如果函数中执行到了return也会结束函数</li>
</ul>

<h2 id="toc_4">函数的文档说明</h2>

<pre><code class="language-python">def test(a,b):
    &#39;&#39;&#39;用来完成对2个数求和&#39;&#39;&#39;
    print(&quot;%d&quot;%(a+b))

test(11,22) 

help(test)
</code></pre>

<pre><code class="language-text">33
Help on function test in module __main__:

test(a, b)
    用来完成对2个数求和
</code></pre>

<p>还可以用test. doc 直接查看文档说明</p>

<pre><code class="language-python">def test(a,b):
    &quot;用来完成对2个数求和&quot;
    print(&quot;%d&quot;%(a+b))

    print(test. doc )
</code></pre>

<p>来完成对两个数的求和</p>

<h2 id="toc_5">函数的参数</h2>

<p>Python的函数定义非常简单，但灵活度却非常大。除了正常定义的必选参数外，还可以使用默认参数、可变参数和关   键字参数，使得函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码。</p>

<h3 id="toc_6">位置参数</h3>

<p>我们先写一个计算x<sup>2</sup> 的函数：</p>

<pre><code class="language-python">def power(x):
    return x * x
</code></pre>

<p>对于power(x)函数，参数x就是一个位置参数。<br/>
当我们调用power函数时，必须传入有且仅有的一个<strong>参数x</strong>：</p>

<pre><code class="language-python">power(5)
</code></pre>

<pre><code class="language-text">25
</code></pre>

<p>现在，如果我们要计算\(x^3\)怎么办？可以再定义一个power3函数，但是如果要计算 \(x^4\) 、 \(x^5\) ……怎么办？我们不可能定义无限多个函数。<br/>
你也许想到了，可以把power(x)修改为power(x, n)，用来计\(x^n\) ，说干就干：</p>

<pre><code class="language-python">def power(x, n): 
    s = 1
    while n &gt; 0:
        n = n - 1 
        s = s * x
    return s
</code></pre>

<p>对于这个修改后的power(x, n)函数，可以计算任意n次方：</p>

<pre><code class="language-python">power(5,2)
</code></pre>

<pre><code class="language-text">25
</code></pre>

<p>修改后的power(x, n)函数有两个参数：x和n，这两个参数都是位置参数，调用函数时，传入的两个值按照位置顺序依次赋给参数x和n。</p>

<h3 id="toc_7">默认参数</h3>

<p>新的power(x, n)函数定义没有问题，但是，旧的调用代码失败了，原因是我们增加了一个参数，导致旧的代码因为缺少一个参数而无法正常调用：</p>

<pre><code class="language-python">power(5)
</code></pre>

<pre><code class="language-text">---------------------------------------------------------------------------

TypeError                                 Traceback (most recent call last)

&lt;ipython-input-89-4cd340f296c6&gt; in &lt;module&gt;()
----&gt; 1 power(5)


TypeError: power() missing 1 required positional argument: &#39;n&#39;
</code></pre>

<p>Python的错误信息很明确：调用函数power()缺少了一个位置参数n。<br/>
这个时候，默认参数就排上用场了。由于我们经常计算 x<sup>2</sup> ，所以，完全可以把第二个参数n的默认值设定为2：</p>

<pre><code class="language-python">def power(x, n=2): 
    s = 1
    while n &gt; 0:
        n = n - 1 
        s = s * x
    return s
</code></pre>

<p>这样，当我们调用power(5)时，相当于调用power(5, 2)：</p>

<pre><code class="language-python">power(5)

</code></pre>

<pre><code class="language-text">25
</code></pre>

<p>而对于n &gt; 2的其他情况，就必须明确地传入n，比如power(5, 3)。</p>

<pre><code class="language-python">power(5,3)

</code></pre>

<pre><code class="language-text">125
</code></pre>

<p>从上面的例子可以看出，默认参数可以简化函数的调用。设置默认参数时，有几点要注意： </p>

<ul>
<li>一是必选参数在前，默认参数在后，否则Python的解释器会报错；</li>
<li>二是当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。</li>
</ul>

<h3 id="toc_8">使用默认参数有什么好处？</h3>

<p>举个例子，我们写个一年级小学生注册的函数，需要传入name和gender两个参数：</p>

<pre><code class="language-python">def enroll(name, gender): 
    print(&#39;name:&#39;, name) 
    print(&#39;gender:&#39;, gender)

</code></pre>

<pre><code class="language-python"># 调用
enroll(&#39;张三&#39;,&#39;M&#39;)

</code></pre>

<pre><code class="language-text">name: 张三
gender: M
</code></pre>

<p>如果要继续传入年龄、城市等信息怎么办？这样会使得调用函数的复杂度大大增加。 我们可以把年龄和城市设为默认参数：</p>

<pre><code class="language-python">def enroll(name, gender,city=&#39;amoy&#39;): 
    print(&#39;name:&#39;, name) 
    print(&#39;gender:&#39;, gender)
    print(&#39;city:&#39;, city)
    
enroll(&#39;李四&#39;,&#39;F&#39;)

</code></pre>

<pre><code class="language-text">name: 李四
gender: F
city: amoy
</code></pre>

<p>这样，大多数学生注册时不需要提供年龄和城市，只提供必须的两个参数,只有与默认参数不符的学生才需要提供额外的信息.</p>

<pre><code class="language-python">enroll(&#39;李四&#39;,&#39;F&#39;,&#39;chengdu&#39;)

</code></pre>

<pre><code class="language-text">name: 李四
gender: F
city: chengdu
</code></pre>

<p>可见，默认参数降低了<strong>函数调用的难度</strong>，而一旦需要更复杂的调用时，又可以传递更多的参数来实现。无论是简单调用还是复杂调用，函数只需要定义一个。</p>

<p>有多个默认参数时，调用的时候，既可以按顺序提供默认参数，比如调用enroll(&#39;Bob&#39;, &#39;M&#39;,  7)，意思是，除了name，gender这两个参数外，最后1个参数应用在参数age上，city参数由于没有提供，仍然使用默认值。</p>

<p>也可以不按顺序提供部分默认参数。当不按顺序提供部分默认参数时，需要把参数名写上。比如调用enroll(&#39;Adam&#39;, &#39;M&#39;,  city=&#39;Tianjin&#39;)，意思是，city参数用传进去的值，其他默认参数继续使用默认值。</p>

<p><strong>注意</strong>：默认参数有个最大的坑，演示如下：</p>

<p>先定义一个函数，传入一个list，添加一个END再返回：</p>

<pre><code class="language-python">def add_end(L=[]): 
    L.append(&#39;END&#39;)
    return L

#调用
add_end([1,24,4])

</code></pre>

<pre><code class="language-text">[1, 24, 4, &#39;END&#39;]
</code></pre>

<pre><code class="language-python">#默认参数调用的时候
add_end()
add_end()
add_end()

</code></pre>

<pre><code class="language-text">[&#39;END&#39;, &#39;END&#39;, &#39;END&#39;, &#39;END&#39;]
</code></pre>

<p>很多初学者很疑惑，默认参数是[]，但是函数似乎每次都“记住了”上次添加了&#39;END&#39;后的list。 原因解释如下：</p>

<p>Python函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L也是一个变量，它指向对象[]，  每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。</p>

<p>定义默认参数要牢记一点：<strong>默认参数必须指向不变对象！</strong></p>

<p>要修改上面的例子，我们可以用None这个不变对象来实现：</p>

<pre><code class="language-python">def add_end(L=None): 
    if L is None:
        L = []
    L.append(&#39;END&#39;) 
    return L
#调用
add_end()
add_end()
add_end()

</code></pre>

<pre><code class="language-text">[&#39;END&#39;]
</code></pre>

<p>为什么要设计str、None这样的不变对象呢？因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。</p>

<h3 id="toc_9">可变参数</h3>

<p>在Python函数中，还可以定义可变参数。顾名思义，可变参数就是传入的参数个数是可变的，可以是1个、2个到任意个，还可以是0个。<br/>
我们以数学题为例子，给定一组数字a，b，c……，请计算\(a^2 + b^2 + c^2 +....\)。</p>

<p>要定义出这个函数，我们必须确定输入的参数。由于参数个数不确定，我们首先想到可以把a，b，c……作为一个list或tuple传进来，这样，函数可以定义如下：</p>

<pre><code class="language-python">def calc(numbers): 
    sum = 0
    for n in numbers:
        sum = sum + n * n 
    return sum

#调用
calc([1,3,5])

</code></pre>

<pre><code class="language-text">35
</code></pre>

<p>所以，我们把函数的参数改为可变参数：</p>

<pre><code class="language-python">def calc(*numbers): 
    sum = 0
    for n in numbers:
        sum = sum + n * n 
    return sum

</code></pre>

<p>定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个号。在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数：</p>

<pre><code class="language-python">calc(1,2)

</code></pre>

<pre><code class="language-text">5
</code></pre>

<pre><code class="language-python">calc()

</code></pre>

<pre><code class="language-text">0
</code></pre>

<p>如果已经有一个list或者tuple，要调用一个可变参数怎么办？可以这样做：</p>

<pre><code class="language-python">nums = [1, 2, 3]
calc(nums[0], nums[1], nums[2])

</code></pre>

<pre><code class="language-text">14
</code></pre>

<p>这种写法当然是可行的，问题是太繁琐，所以Python允许你在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去：</p>

<pre><code class="language-python">nums=[1,2,3]
calc(*nums)

</code></pre>

<pre><code class="language-text">14
</code></pre>

<p>*nums表示把nums这个list的所有元素作为可变参数传进去。这种写法相当有用，而且很常见。</p>

<h3 id="toc_10">命名关键字参数</h3>

<p>对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数。至于到底传入了哪些，就需要在函数内部通过kw检查。</p>

<p>仍以person()函数为例，我们希望检查是否有city和job参数：</p>

<pre><code class="language-python">def person(name, age, **kw): 
    if &#39;city&#39; in kw:# 有city参数
        pass
    if &#39;job&#39; in kw:# 有job参数
        pass
    print(&#39;name:&#39;, name, &#39;age:&#39;, age, &#39;other:&#39;, kw)

</code></pre>

<p>但是调用者仍可以传入不受限制的关键字参数：</p>

<pre><code class="language-python">person(&#39;Jack&#39;, 24, city=&#39;Beijing&#39;, addr=&#39;Chaoyang&#39;, zipcode=123456)

</code></pre>

<pre><code class="language-text">name: Jack age: 24 other: {&#39;city&#39;: &#39;Beijing&#39;, &#39;addr&#39;: &#39;Chaoyang&#39;, &#39;zipcode&#39;: 123456}
</code></pre>

<p>如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义的函数如下：</p>

<pre><code class="language-python">def person(name, age, *, city, job): 
    print(name, age, city, job)

</code></pre>

<p>和关键字参数kw不同，命名关键字参数需要一个特殊分隔符<em>，</em>后面的参数被视为命名关键字参数。调用方式如下：</p>

<pre><code class="language-python"> person(&#39;Jack&#39;, 24, city=&#39;Beijing&#39;, job=&#39;Engineer&#39;)

</code></pre>

<pre><code class="language-text">Jack 24 Beijing Engineer
</code></pre>

<p>如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了：</p>

<pre><code class="language-python">def person(name, age, *args, city, job):
    print(name, age, args, city, job)

</code></pre>

<p>命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错：</p>

<pre><code class="language-python"> person(&#39;Jack&#39;, 24, &#39;Beijing&#39;,&#39;Engineer&#39;)

</code></pre>

<pre><code class="language-text">---------------------------------------------------------------------------

TypeError                                 Traceback (most recent call last)

&lt;ipython-input-17-7465e072842a&gt; in &lt;module&gt;()
----&gt; 1 person(&#39;Jack&#39;, 24, &#39;Beijing&#39;,&#39;Engineer&#39;)



TypeError: person() missing 2 required keyword-only arguments: &#39;city&#39; and &#39;job&#39;
</code></pre>

<p>由于调用时缺少参数名city和job，Python解释器把这4个参数均视为位置参数，但person()函数仅接受2个位置参数。</p>

<p>命名关键字参数可以有缺省值，从而简化调用：</p>

<pre><code class="language-python">def person(name, age, *, city=&#39;Beijing&#39;, job): 
    print(name, age, city, job)
   

# 利用默认值，调用时可以不用传入
person(&#39;Jack&#39;, 24, job=&#39;Engineer&#39;)

</code></pre>

<pre><code class="language-text">Jack 24 Beijing Engineer
</code></pre>

<p>使用命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个<em>作为特殊分隔符。如果缺少</em>，Python解释器将无法识别位置参数和命名关键字参数：</p>

<pre><code class="language-text">def person(name, age, city, job):

# 缺少 *，city和job被视为位置参数 pass

</code></pre>

<h3 id="toc_11">参数组合</h3>

<p>在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：<strong>必选参数</strong>、<strong>默认参数</strong>、<strong>可变参数</strong>、<strong>命名关键字参数</strong>和<strong>关键字参数</strong>。</p>

<p>比如定义一个函数，包含上述若干种参数：</p>

<pre><code class="language-python">def f1(a, b, c=0, *args, **kw):
    print(&#39;a =&#39;, a, &#39;b =&#39;, b, &#39;c =&#39;, c, &#39;args =&#39;, args, &#39;kw =&#39;, kw)
    
def f2(a, b, c=0, *, d, **kw):
    print(&#39;a =&#39;, a, &#39;b =&#39;, b, &#39;c =&#39;, c, &#39;d =&#39;, d, &#39;kw =&#39;, kw)

#调用
f1(1,2)

</code></pre>

<pre><code class="language-text">a = 1 b = 2 c = 0 args = () kw = {}
</code></pre>

<pre><code class="language-python">f1(1,2,c=3)

</code></pre>

<pre><code class="language-text">a = 1 b = 2 c = 3 args = () kw = {}
</code></pre>

<pre><code class="language-python">f1(1,2,3,&#39;a&#39;,&#39;b&#39;)

</code></pre>

<pre><code class="language-text">a = 1 b = 2 c = 3 args = (&#39;a&#39;, &#39;b&#39;) kw = {}
</code></pre>

<pre><code class="language-python">f1(1,2,3,&#39;a&#39;,&#39;b&#39;,x=99)

</code></pre>

<pre><code class="language-text">a = 1 b = 2 c = 3 args = (&#39;a&#39;, &#39;b&#39;) kw = {&#39;x&#39;: 99}
</code></pre>

<pre><code class="language-python">f2(1, 2, d=99, ext=None)

</code></pre>

<pre><code class="language-text">a = 1 b = 2 c = 0 d = 99 kw = {&#39;ext&#39;: None}
</code></pre>

<p>最神奇的是通过一个tuple和dict，你也可以调用上述函数：</p>

<pre><code class="language-python">args = (1, 2, 3, 4)
kw = {&#39;d&#39;: 99, &#39;x&#39;: &#39;#&#39;}
f1(*args, **kw)

</code></pre>

<pre><code class="language-text">a = 1 b = 2 c = 3 args = (4,) kw = {&#39;d&#39;: 99, &#39;x&#39;: &#39;#&#39;}
</code></pre>

<pre><code class="language-python">args = (1, 2, 3)
kw = {&#39;d&#39;: 88, &#39;x&#39;: &#39;#&#39;}
f2(*args, **kw)

</code></pre>

<pre><code class="language-text">a = 1 b = 2 c = 3 d = 88 kw = {&#39;x&#39;: &#39;#&#39;}
</code></pre>

<p>所以，对于任意函数，都可以通过类似func(<em>args, *</em>kw)的形式调用它，无论它的参数是如何定义的。虽然可以组合多达5种参数，但不要同时使用太多的组合，否则函数接口的可理解性很差。</p>

<h2 id="toc_12">函数返回值</h2>

<h3 id="toc_13">“返回值”介绍</h3>

<ul>
<li>现实生活中的场景:</li>
</ul>

<p>我给儿子10块钱，让他给我买包烟。这个例子中，10块钱是我给儿子的，就相当于调用函数时传递到参数，让儿子买烟这个事情最终的目标是，让他把烟给你带回来然后给你对么，此时烟就是返回值</p>

<ul>
<li>开发中的场景：</li>
</ul>

<p>定义了一个函数，完成了获取室内温度，想一想是不是应该把这个结果给调用者，只有调用者拥有了这个返回值，才能够根据当前的温度做适当的调整所谓“<strong>返回值</strong>”，就是程序中函数完成一件事情后，最后给调用者的结果</p>

<h3 id="toc_14">带有返回值的函数</h3>

<p>想要在函数中把结果返回给调用者，需要在函数中使用return如下示例:</p>

<pre><code class="language-python">   def add2num(a, b): 
   c = a+b
   return c

</code></pre>

<p>或者</p>

<pre><code class="language-text">   def add2num(a, b): 
   return a+b

</code></pre>

<h3 id="toc_15">保存函数的返回值</h3>

<p>在“买烟”的例子中，最后儿子给你烟时，你一定是从儿子手中接过来 对么，程序也是如此，如果一个函数返回了一个数据，那么想要用这个数据，那么就需要保存.</p>

<p>保存函数的返回值示例如下:</p>

<pre><code class="language-python">#定义函数

def add2num(a, b):
    return a+b
#调用函数，顺便保存函数的返回值 

result = add2num(100,98)
print(result)

</code></pre>

<pre><code class="language-text">198
</code></pre>

<h3 id="toc_16">如何返回多个值</h3>

<h4 id="toc_17">多个ruturn？</h4>

<pre><code class="language-python">def create_nums(): 
    print(&quot;---1---&quot;)
    return 1 # 函数中下面的代码不会被执行，因为return除了能够将数据返回之外，还有一个隐藏的功能：结束函数
    print(&quot;---2---&quot;) 
    return 2
    print(&quot;---3---&quot;)

</code></pre>

<p><strong>总结1</strong>一个函数中可以有多个return语句，但是只要有一个return语句被执行到，那么这个函数就会结束了，因此后面的return没有什么用处 如果程序设计为如下，是可以的因为不同的场景下执行不同的return</p>

<pre><code class="language-python">def create_nums(num): 
    print(&quot;---1---&quot;) 
    if num == 100:
        print(&quot;---2---&quot;)
        return num+1 # 函数中下面的代码不会被执行，因为return除了能够将数据返回之外，还有一个隐藏的功能：结束函数
    else:
        print(&quot;---3---&quot;) 
        return num+2
    print(&quot;---4---&quot;)



result1 = create_nums(100)
print(result1) # 打印101 
result2 = create_nums(200) 
print(result2) # 打印202

</code></pre>

<pre><code class="language-text">---1---
---2---
101
---1---
---3---
202
</code></pre>

<h4 id="toc_18">一个函数返回多个数据的方式</h4>

<pre><code class="language-python">def divid(a, b):
    shang = a//b 
    yushu = a%b
    return shang, yushu #默认是元组


result = divid(5, 2) 
print(result) # 输 出 (2, 1)

</code></pre>

<pre><code class="language-text">(2, 1)
</code></pre>

<p><strong>总结2</strong>： return后面可以是元组，列表、字典等，只要是能够存储多个数据的类型，就可以一次性返回多个数据</p>

<pre><code class="language-python">def function():
# return [1, 2, 3]
# return (1, 2, 3)
    return {&quot;num1&quot;: 1, &quot;num2&quot;: 2, &quot;num3&quot;: 3}

</code></pre>

<p>如果return后面有多个数据，那么默认是元组</p>

<pre><code class="language-text">In [1]: a = 1, 2

In [2]: a

Out[2]: (1, 2)



In [3]:

In [3]: b = (1, 2)

In [4]: b

Out[4]: (1, 2)


</code></pre>

<h2 id="toc_19">递归函数</h2>

<p>在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是<strong>递归函数</strong>。</p>

<p>举个例子，我们来计算阶乘n! = 1 x 2 x 3 x ... x n，用函数fact(n)表示，可以看出：</p>

<p>\(fact(n) = n! = 1 x 2 x 3 x ... x (n-1) x n = (n-1)! x n = fact(n-1) x n\)</p>

<p>所以，fact(n)可以表示为n x fact(n-1)，只有n=1时需要特殊处理。于是，fact(n)用递归的方式写出来就是：</p>

<pre><code class="language-python">def fact(n):
    if n==1:
        return 1
    return n * fact(n - 1)

</code></pre>

<pre><code class="language-python">fact(2)

</code></pre>

<pre><code class="language-text">2
</code></pre>

<pre><code class="language-python">fact(4)

</code></pre>

<pre><code class="language-text">24
</code></pre>

<pre><code class="language-python">fact(1)

</code></pre>

<pre><code class="language-text">1
</code></pre>

<p>递归函数的<strong>优点</strong>是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。</p>

<p>使用递归函数需要<strong>注意</strong>防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试</p>

<pre><code class="language-python">fact(10000)

</code></pre>

<pre><code class="language-text">---------------------------------------------------------------------------

RecursionError                            Traceback (most recent call last)

&lt;ipython-input-37-0b1842e84853&gt; in &lt;module&gt;()
----&gt; 1 fact(10000)



&lt;ipython-input-32-6cee500c0290&gt; in fact(n)
      2     if n==1:
      3         return 1
----&gt; 4     return n * fact(n - 1)



... last 1 frames repeated, from the frame below ...



&lt;ipython-input-32-6cee500c0290&gt; in fact(n)
      2     if n==1:
      3         return 1
----&gt; 4     return n * fact(n - 1)



RecursionError: maximum recursion depth exceeded in comparison
</code></pre>

<p>解决递归调用栈溢出的方法是通过<strong>尾递归</strong>优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。</p>

<p><strong>尾递归</strong>是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。</p>

<p>上面的fact(n)函数由于return n * fact(n - 1)引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中：</p>

<pre><code class="language-python">def fact(n):
    return fact_iter(n, 1)

def fact_iter(num, product): 
    if num == 1:
        return product
    return fact_iter(num - 1, num * product)

</code></pre>

<p>可以看到，return fact_iter(num - 1, num * product)仅返回递归函数本身，num - 1和num*product在函数调用前就会被计算，不影响函数调用。</p>

<p>尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。</p>

<p>遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化，所以，即使把上面的fact(n)函数改成尾递归方式，也会导致栈溢出<br/>
<strong>小结</strong></p>

<ul>
<li><p>使用递归函数的优点是逻辑简单清晰，缺点是过深的调用会导致栈溢出。</p></li>
<li><p>针对尾递归优化的语言可以通过尾递归防止栈溢出。尾递归事实上和循环是等价的，没有循环语句的编程语言只能通过尾递归实现循环。</p></li>
<li><p>Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题。</p></li>
</ul>

<h2 id="toc_20">局部变量</h2>

<ul>
<li> 局部变量，就是在函数内部定义的变量。</li>
<li> <strong>作用范围</strong>是这个函数内部，即只能在这个函数中使用，在函数的外部是不能使用的。因为其作用范围只是在自己的函数内部，所以不同的函数可以定义相同名字的局部变量（打个比方，把你、我是当做成函数，把局部变量理解为每个人手里的手机，你可有个iPhone8，我当然也可以有个iPhone8了， 互不相关）</li>
<li> 局部变量的作用，为了临时保存数据需要在函数中定义变量来进行存储。</li>
<li> 当函数调用时，局部变量被创建，当函数调用完成后这个变量就不能够使用了。函数调用时，局部变量被创建，当函数调用完成后这个变量就不能够使用了。</li>
</ul>

<pre><code class="language-python">def show():
# 局部变量
    score = 100
    print(&quot;分数:&quot;, score) 
show()

</code></pre>

<pre><code class="language-text">分数: 100
</code></pre>

<pre><code class="language-python">print(score)

</code></pre>

<pre><code class="language-text">---------------------------------------------------------------------------

NameError                                 Traceback (most recent call last)

&lt;ipython-input-41-4405d376f933&gt; in &lt;module&gt;()
----&gt; 1 print(score)



NameError: name &#39;score&#39; is not defined
</code></pre>

<h2 id="toc_21">全局变量</h2>

<p>如果一个变量，既能在一个函数中使用，也能在其他的函数中使用，这样的变量就是<strong>全局变量</strong>。</p>

<p><strong>例如</strong>：有2个兄弟 各自都有手机，各自有自己的小秘密在手机里，不让另外一方使用（可以理解为<strong>局部变量</strong>）；但是家里的电话是2个兄弟都可以随便使用的（可以理解为<strong>全局变量</strong>）</p>

<pre><code class="language-python"># 定义全局变量

a = 100

def test1():

    print(a) # 虽然没有定义变量a但是依然可以获取其数据



def test2():

    print(a) # 虽然没有定义变量a但是依然可以获取其数据

# 调用函数

test1()
test2()

</code></pre>

<pre><code class="language-text">100
100
</code></pre>

<p><strong>总结</strong>:</p>

<ul>
<li>在函数外边定义的变量叫做全局变量</li>
<li>全局变量能够在所有的函数中进行访问</li>
</ul>

<h3 id="toc_22">全局变量和局部变量名字相同问题</h3>

<pre><code class="language-python"># 定义全局变量
a = 100
def test1():
# 定义局部变量
    a = 300
    print(&#39;---test1---%d&#39;%a)
test1()
#修改
a = 200
print(&#39;修改后的%d&#39;%a)

def test2():
    print(&#39;a = %d&#39;%a)

test2()

</code></pre>

<pre><code class="language-text">---test1---300
修改后的200
a = 200
</code></pre>

<p><strong>总结</strong>:</p>

<ul>
<li>当函数内出现局部变量和全局变量相同名字时，函数内部中的 变量名 = 数据 此时理解为定义了一个局部变量，而不是修改全局变量的值</li>
</ul>

<h3 id="toc_23">修改全局变量</h3>

<p>函数中进行使用<strong>全局变量</strong>时可否进行修改呢？</p>

<pre><code class="language-python"># 定义全局变量
a = 100
def test1():
# 定义局部变量
    global a
    print(&#39;修改之前：%d&#39;%a)

#修改
a = 200
print(&#39;修改后的%d&#39;%a)


def test2():
    print(&#39;a = %d&#39;%a)

test1() 
test2()

</code></pre>

<pre><code class="language-text">修改后的200
修改之前：200
a = 200
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0.Python 速查]]></title>
    <link href="ryanhuo.github.io/15822327222638.html"/>
    <updated>2020-02-21T05:05:22+08:00</updated>
    <id>ryanhuo.github.io/15822327222638.html</id>
    <content type="html"><![CDATA[
<p><a href="media/15822327222638/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E9%80%9F%E6%9F%A5%E8%A1%A8.pdf">Python数据科学速查表</a></p>

<p><a href="media/15822327222638/0.%E9%A3%8E%E5%8F%98%E7%BC%96%E7%A8%8B-Python%E5%9F%BA%E7%A1%80%EF%BC%88%E6%95%B4%E7%90%86%E7%89%88%EF%BC%89.pdf">0.风变编程-Python基础（整理版）</a></p>

<h1 id="toc_0">Python基础速查</h1>

<h2 id="toc_1">常规</h2>

<ul>
<li>Python 对大小写敏感</li>
<li>Python 的索引从 0 开始</li>
<li>Python 使用空白符（制表符或空格）来缩进代码，而不是使用花括号</li>
</ul>

<h3 id="toc_2">获取帮助</h3>

<ul>
<li>获取主页帮助：<code>help()</code></li>
<li>获取函数帮助：<code>help(str.replace)</code></li>
<li>获取模块帮助：<code>help(re)</code></li>
</ul>

<h3 id="toc_3">模块(库)</h3>

<p>Python的模块只是一个简单地以 <code>.py</code> 为后缀的文件。</p>

<ul>
<li>列出模块内容：<code>dir(module1)</code></li>
<li>导入模块：<code>import module</code></li>
<li>调用模块中的函数：<code>module1.func1()</code></li>
</ul>

<blockquote>
<p><strong>注</strong>：<code>import</code>语句会创建一个新的命名空间(namespace)，并且在该命名空间内执行<code>.py</code>文件中的所有语句。如果你想把模块内容导入到当前命名空间，请使用<code>from module1 import *</code>语句。</p>
</blockquote>

<h2 id="toc_4">数值类类型</h2>

<p>查看变量的数据类型：<code>type(variable)</code></p>

<h3 id="toc_5">六种经常使用的数据类型</h3>

<ol>
<li><strong>int/long</strong>：过大的 <code>int</code> 类型会被自动转化为 <code>long</code> 类型</li>
<li><strong>float</strong>：64 位，Python 中没有 <code>double</code> 类型</li>
<li><strong>bool</strong>：真或假</li>
<li><p><strong>str</strong>：在 Python 2 中默认以 ASCII 编码，而在 Python 3 中默认以 Unicode 编码</p>
<ul>
<li>字符串可置于单/双/三引号中</li>
<li>字符串是字符的序列，因此可以像处理其他序列一样处理字符串</li>
<li><p>特殊字符可通过 <code>\</code> 或者前缀 <code>r</code> 实现：</p>
<pre><code class="language-python">str1 = r&#39;this\f?ff&#39;
</code></pre></li>
<li><p>字符串可通过多种方式格式化：</p>
<pre><code class="language-python">template = &#39;%.2f %s haha $%d&#39;;
str1 = template % (4.88, &#39;hola&#39;, 2)
</code></pre></li>
</ul></li>
<li><p><strong>NoneType(None)</strong>：Python “null”值（<code>None</code>对象<strong>只</strong>存在一个实例）</p>
<ul>
<li><code>None</code>不是一个保留关键字，而是<code>NoneType</code>的一个唯一实例</li>
<li><p><code>None</code>通常是可选函数参数的默认值：</p>
<pre><code class="language-python">def func1(a, b, c=None)
</code></pre></li>
<li><p><code>None</code>的常见用法：</p>
<pre><code class="language-python">if variable is None :
</code></pre></li>
</ul></li>
<li><p><strong>datetime</strong>：Python内置的<code>datetime</code>模块提供了<code>datetime</code>、<code>data</code>以及<code>time</code>类型。</p>
<ul>
<li><code>datetime</code>组合了存储于<code>date</code>和<code>time</code>中的信息
<code>python
# 从字符串中创建 datetime<br/>
dt1 = datetime.strptime(&#39;20091031&#39;, &#39;%Y%m%d&#39;)<br/>
# 获取 date 对象<br/>
dt1.date()<br/>
# 获取 time 对象<br/>
dt1.time()<br/>
# 将 datetime 格式化为字符串<br/>
dt1.strftime(&#39;%m/%d/%Y%H:%M&#39;)<br/>
# 更改字段值<br/>
dt2 = dt1.replace(minute=0, second=30)<br/>
# 做差, diff 是一个 datetime.timedelta 对象<br/>
diff = dt1 - dt2
</code></li>
</ul></li>
</ol>

<blockquote>
<p><strong>注</strong>：</p>

<ul>
<li><code>str</code>、<code>bool</code>、<code>int</code>和<code>float</code>同时也是显式类型转换函数。</li>
<li>除字符串和元组外，Python 中的绝大多数对象都是可变的。</li>
</ul>
</blockquote>

<h2 id="toc_6">数据结构</h2>

<blockquote>
<p><strong>注</strong>：所有的“非只读(non-Get)”函数调用，比如下面例子中的<code>list1.sort()</code>，除非特别声明，都是原地操作(不会创建新的对象)。</p>
</blockquote>

<h3 id="toc_7">元组</h3>

<p>元组是 Python 中任何类型的对象的一个一维、固定长度、<strong>不可变</strong>的序列。</p>

<pre><code class="language-python"># 创建元组
tup1 = 4, 5, 6
tup1 = (6, 7, 8)
# 创建嵌套元组
tup1 = (4, 5, 6), (7, 8)
# 将序列或迭代器转化为元组
tuple([1, 0, 2])
# 连接元组
tup1 + tup2
# 解包元组
a, b, c = tup1
</code></pre>

<p><strong>元组应用</strong>：</p>

<pre><code class="language-python"># 交换两个变量的值
a, b = b, a
</code></pre>

<h3 id="toc_8">列表</h3>

<p>列表是 Python 中任何类型的对象的一个一维、非固定长度、<strong>可变</strong>（比如内容可以被修改）的序列。</p>

<pre><code class="language-python"># 创建列表
list1 = [1, &#39;a&#39;, 3]
list1 = list(tup1)
# 连接列表
list1 + list2
list1.extend(list2)
# 追加到列表的末尾
list1.append(&#39;b&#39;)
# 插入指定位置
list1.insert(PosIndex, &#39;a&#39;)
# 反向插入，即弹出给定位置的值/删除
ValueAtIdx = list1.pop(PosIndex)
# 移除列表中的第一个值, a 必须是列表中第一个值
list1.remove(&#39;a&#39;)
# 检查成员
3 in list1 =&gt; True or False
# 对列表进行排序
list1.sort()
# 按特定方式排序
list1.sort(key=len) # 按长度排序
</code></pre>

<blockquote>
<ul>
<li>使用 + 连接列表会有比较大的开支，因为这个过程中会创建一个新的列表，然后复制对象。因此，使用<code>extend()</code>是更明智的选择。</li>
<li><code>insert</code>和<code>append</code>相比会有更大的开支（时间/空间）。</li>
<li>在列表中检查是否包含一个值会比在字典和集合中慢很多，因为前者需要进行线性扫描，而后者是基于哈希表的，所以只需要花费常数时间。</li>
</ul>
</blockquote>

<h4 id="toc_9">内置的<code>bisect</code>模块</h4>

<ul>
<li>对一个排序好的列表进行二分查找或插入</li>
<li><code>bisect.bisect</code>找到元素在列表中的位置，<code>bisect.insort</code>将元素插入到相应位置。</li>
<li>用法：
<code>python
import bisect<br/>
list1 = list(range(10))<br/>
#找到 5 在 list1 中的位置，从 1 开始，因此 position = index + 1<br/>
bisect.bisect(list1, 5)<br/>
#将 3.5 插入 list1 中合适位置<br/>
bisect.insort(list1, 3.5)
</code></li>
</ul>

<blockquote>
<p><strong>注</strong>：<code>bisect</code> 模块中的函数并不会去检查列表是否排序好，因为这会花费很多时间。所以，对未排序好的列表使用这些函数也不会报错，但可能会返回不正确的结果。</p>
</blockquote>

<h3 id="toc_10">针对序列类型的切片</h3>

<blockquote>
<p>序列类型包括<code>str</code>、<code>array</code>、<code>tuple</code>、<code>list</code>等。</p>
</blockquote>

<p>用法：</p>

<pre><code class="language-python">list1[start:stop]
# 如果使用 step
list1[start:stop:step]
</code></pre>

<blockquote>
<p><strong>注</strong>：</p>

<ul>
<li>切片结果包含 <code>start</code> 索引，但不包含 <code>stop</code> 索引</li>
<li><code>start/stop</code> 索引可以省略，如果省略，则默认为序列从开始到结束，如 <code>list1 == list1[:]</code> 。</li>
</ul>
</blockquote>

<p><code>step</code> 的应用：</p>

<pre><code class="language-python"># 取出奇数位置的元素
list1[::2]
# 反转字符串
str1[::-1]
</code></pre>

<h3 id="toc_11">字典（哈希表）</h3>

<pre><code class="language-python"># 创建字典
dict1 = {&#39;key1&#39;: &#39;value1&#39;, 2: [3, 2]}
# 从序列创建字典
dict(zip(KeyList, ValueList))
# 获取/设置/插入元素
dict1[&#39;key1&#39;]
dict1[&#39;key1&#39;] = &#39;NewValue&#39;
# get 提供默认值
dict1.get(&#39;key1&#39;, DefaultValue)
# 检查键是否存在
&#39;key1&#39; in dict1
# 获取键列表
dict1.keys()
# 获取值列表
dict1.values()
# 更新值
dict1.update(dict2)  # dict1 的值被 dict2 替换
</code></pre>

<blockquote>
<ul>
<li>如果键不存在，则会出现 <code>KeyError Exception</code> 。</li>
<li>当键不存在时，如果 <code>get()</code>不提供默认值则会返回 <code>None</code> 。</li>
<li>以相同的顺序返回键列表和值列表，但顺序不是特定的，也就是说极大可能非排序。</li>
</ul>
</blockquote>

<h4 id="toc_12">有效字典键类型</h4>

<ul>
<li>键必须是不可变的，比如标量类型(<code>int</code>、<code>float</code>、<code>string</code>)或者元组（元组中的所有对象也必须是不可变的）。</li>
<li>这儿涉及的技术术语是“可哈希(hashability)”。可以用函数<code>hash()</code>来检查一个对象是否是可哈希的，比如 <code>hash(&#39;This is a string&#39;)</code>会返回一个哈希值，而<code>hash([1,2])</code>则会报错（不可哈希）。</li>
</ul>

<h3 id="toc_13">集合</h3>

<ul>
<li>一个集合是一些<strong>无序</strong>且唯一的元素的聚集；</li>
<li><p>你可以把它看成只有键的字典；</p>
<pre><code class="language-python"># 创建集合
set([3, 6, 3])<br/>
{3, 6, 3}<br/>
# 子集测试<br/>
set1.issubset(set2)<br/>
# 超集测试<br/>
set1.issuperset(set2)<br/>
# 测试两个集合中的元素是否完全相同<br/>
set1 == set2
</code></pre></li>
<li><p><strong>集合操作</strong></p>
<ul>
<li>并（或）：<code>set1 | set2</code></li>
<li>交（与）：<code>set1 &amp; set2</code></li>
<li>差：<code>set1 - set2</code></li>
<li>对称差（异或）：<code>set1 ^ set2</code></li>
</ul></li>
</ul>

<h2 id="toc_14">函数</h2>

<p>Python 的函数参数传递是通过<strong>引用传递</strong>。</p>

<ul>
<li><p>基本形式</p>
<pre><code class="language-python">def func1(posArg1, keywordArg1=1, ..)
</code></pre>
<blockquote>
<p><strong>注</strong>：</p>
<ul>
<li>关键字参数必须跟在位置参数的后面；</li>
<li>默认情况下，Python 不会“延迟求值”，表达式的值会立刻求出来。</li>
</ul>
</blockquote></li>
<li><p>函数调用机制</p>
<ol>
<li>所有函数均位于模块内部作用域。见“模块”部分。</li>
<li>在调用函数时，参数被打包成一个元组和一个字典，函数接收一个元组<code>args</code>和一个字典<code>kwargs</code>，然后在函数内部解包。</li>
</ol></li>
<li><p>“函数是对象”的常见用法：</p>
<pre><code class="language-python">def func1(ops = [str.strip, user_define_func, ..], ..):
for function in ops:<br/>
    value = function(value)
</code></pre></li>
</ul>

<h3 id="toc_15">返回值</h3>

<ul>
<li>如果函数直到结束都没有<code>return</code>语句，则返回<code>None</code>。</li>
<li>如果有多个返回值则通过<strong>一个</strong>元组来实现。
<code>python
return (value1, value2)<br/>
value1, value2 = func1(..)
</code></li>
</ul>

<h3 id="toc_16">匿名函数（又称 LAMBDA 函数）</h3>

<ul>
<li>什么是匿名函数？</li>
</ul>

<p>匿名函数是一个只包含一条语句的简单函数。</p>

<pre><code class="language-python">lambda x : x * 2
# def func1(x) : return x * 2
</code></pre>

<ul>
<li>匿名函数的应用：“柯里化(curring)”，即利用已存在函数的部分参数来派生新的函数。
<code>python
ma60 = lambda x : pd.rolling_mean(x, 60)
</code></li>
</ul>

<h3 id="toc_17">一些有用的函数（针对数据结构）</h3>

<ol>
<li><p><strong>Enumerate</strong> 返回一个序列<code>(i, value)</code>元组，<code>i</code> 是当前 <code>item</code> 的索引。</p>
<pre><code class="language-python">for i, value in enumerate(collection):
</code></pre>
<ul>
<li>应用：创建一个序列中值与其在序列中的位置的字典映射（假设每一个值都是唯一的）。</li>
</ul></li>
<li><p><strong>Sorted</strong> 可以从任意序列中返回一个排序好的序列。</p>
<pre><code class="language-python">sorted([2, 1, 3]) =&gt; [1, 2, 3]
</code></pre>
<ul>
<li>应用：
<code>python
sorted(set(&#39;abc bcd&#39;)) =&gt; [&#39; &#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]<br/>
# 返回一个字符串排序后无重复的字母序列
</code></li>
</ul></li>
<li><p><strong>Zip</strong> 函数可以把许多列表、元组或其他序列的元素配对起来创建一系列的元组。</p>
<pre><code class="language-python">zip(seq1, seq2) =&gt; [(&#39;seq1_1&#39;, &#39;seq2_1&#39;), (..), ..]
</code></pre>
<ul>
<li><code>zip()</code>可以接收任意数量的序列作为参数，但是产生的元素的数目取决于最短的序列。</li>
<li><p>应用：多个序列同时迭代：</p>
<pre><code class="language-python">for i, (a, b) in enumerate(zip(seq1, seq2)):
</code></pre></li>
<li><p><code>unzip</code>：另一种思考方式是把一些行转化为一些列：</p>
<pre><code class="language-python">seq1, seq2 = unzip(zipOutput)
</code></pre></li>
</ul></li>
<li><p><strong>Reversed</strong> 将一个序列的元素以逆序迭代。</p>
<pre><code class="language-python">list(reversed(range(10)))
</code></pre>
<blockquote>
<p><code>reversed()</code> 会返回一个迭代器，<code>list()</code> 使之成为一个列表。</p>
</blockquote></li>
</ol>

<h2 id="toc_18">控制流</h2>

<ol>
<li>用于 <code>if-else</code> 条件中的操作符：<br/>
```python<br/>
var1 is var2  # 检查两个变量是否是相同的对象</li>
</ol>

<p>var1 is not var2  # 检查两个变量是否是不同的对象</p>

<p>var1 == var2  # 检查两个变量的值是否相等</p>

<pre><code class="language-text">&gt; **注**：Python 中使用 `and`、`or`、`not` 来组合条件，而不是使用 `&amp;&amp;`、`||`、`!` 。

2. `for`循环的常见用法：
```python
for element in iterator:  # 可迭代对象（list、tuple）或迭代器
    pass

for a, b, c in iterator:  # 如果元素是可以解包的序列
    pass
</code></pre>

<ol>
<li><code>pass</code>：无操作语句，在不需要进行任何操作的块中使用。</li>
<li><p>三元表达式，又称简洁的 <code>if-else</code>，基本形式：</p>
<pre><code class="language-python">value = true-expr if condition else false-expr
</code></pre></li>
<li><p>Python 中没有 <code>switch/case</code> 语句，请使用 <code>if/elif</code>。</p></li>
</ol>

<h2 id="toc_19">面向对象编程</h2>

<ol>
<li><strong>对象</strong>是 Python 中所有类型的根。</li>
<li>万物（数字、字符串、函数、类、模块等）皆为对象，每个对象均有一个“类型(type)”。对象变量是一个指向变量在内存中位置的指针。</li>
<li><p>所有对象均会被<strong>引用计数</strong>。</p>
<pre><code class="language-python">sys.getrefcount(5) =&gt; x
a = 5, b = a<br/>
# 上式会在等号的右边创建一个对象的引用，因此 a 和 b 均指向 5<br/>
sys.getrefcount(5)<br/>
=&gt; x + 2<br/>
del(a); sys.getrefcount(5) =&gt; x + 1
</code></pre></li>
<li><p>类的基本形式：</p>
<pre><code class="language-python">class MyObject(object):
# &#39;self&#39; 等价于 Java/C++ 中的 &#39;this&#39;<br/>
def __init__(self, name):<br/>
    self.name = name<br/>
def memberFunc1(self, arg1):<br/>
    pass<br/>
@staticmethod<br/>
def classFunc2(arg1):<br/>
    pass<br/>
obj1 = MyObject(&#39;name1&#39;)<br/>
obj1.memberFunc1(&#39;a&#39;)<br/>
MyObject.classFunc2(&#39;b&#39;)
</code></pre></li>
<li><p>有用的交互式工具：</p>
<pre><code class="language-python">dir(variable1)  # 列出对象的所有可用方法
</code></pre></li>
</ol>

<h2 id="toc_20">常见字符串操作</h2>

<pre><code class="language-python"># 通过分隔符连接列表/元组
&#39;, &#39;.join([ &#39;v1&#39;, &#39;v2&#39;, &#39;v3&#39;]) =&gt; &#39;v1, v2, v3&#39;

# 格式化字符串
string1 = &#39;My name is {0}　{name}&#39;
newString1 = string1.format(&#39;Sean&#39;, name =　&#39;Chen&#39;)

# 分裂字符串
sep = &#39;-&#39;;
stringList1 =　string1.split(sep)

# 获取子串
start = 1;
string1[start:8]

# 补 &#39;0&#39; 向右对齐字符串
month = &#39;5&#39;;
month.zfill(2) =&gt; &#39;05&#39;
month = &#39;12&#39;;
month.zfill(2) =&gt; &#39;12&#39;
month.zfill(3) =&gt; &#39;012&#39;
</code></pre>

<h2 id="toc_21">异常处理</h2>

<ol>
<li><p>基本形式：</p>
<pre><code class="language-python">try:
pass<br/>
except ValueError as e:<br/>
print e<br/>
except (TypeError, AnotherError):<br/>
pass<br/>
except:<br/>
pass<br/>
finally:<br/>
pass  # 清理，比如 close db;
</code></pre></li>
<li><p>手动引发异常：</p>
<pre><code class="language-python">raise AssertionError  # 断言失败
raise SystemExit<br/>
# 请求程序退出<br/>
raise RuntimeError(&#39;错误信息 :..&#39;)
</code></pre></li>
</ol>

<h2 id="toc_22">列表、字典以及元组的推导表达式</h2>

<p>使代码更加易读易写的语法糖。</p>

<ol>
<li><p><strong>列表推导</strong></p>
<ul>
<li>用一个简练的表达式，通过筛选一个数据集并且转换经过筛选的元素的方式来简明地生成新列表。</li>
<li>基本形式：
<code>python
[expr for val in collection if condition]
</code>
等价于
<code>python
result = []<br/>
for val in collection:<br/>
if condition:<br/>
result.append(expr)
</code>
可以省略过滤条件，只留下表达式。</li>
</ul></li>
<li><p><strong>字典推导</strong></p>
<ul>
<li>基本形式：
<code>python
{key-expr : value-expr for value in collection if condition}
</code></li>
</ul></li>
<li><p><strong>集合推导</strong></p>
<ul>
<li>基本形式：和列表推导一样，不过是用 <code>()</code> 而不是 <code>[]</code> 。</li>
</ul></li>
<li><p><strong>嵌套列表</strong></p>
<ul>
<li>基本形式：
<code>python
[expr for val in collection for innerVal in val if condition]
</code></li>
</ul></li>
</ol>

<h2 id="toc_23">单元测试</h2>

<p>Python自带<code>unittest</code>模块，可供我们编写单元测试。</p>

<pre><code class="language-python">import unittest
</code></pre>

<p>我们可以编写继承于<code>unittest.TestCase</code>测试类的子类，并在子类中编写具体的测试函数。测试函数命必须以<code>test_</code>开头，否则不会被识别为测试函数，进而不会在运行单元测试时被运行。</p>

<pre><code class="language-python">class TestSubclass(unittest.TestCase):

    def test_func(self):
        self.assertEqual(0, 0)
        # 可以通过msg关键字参数提供测试失败时的提示消息
        self.assertEqual(0, 0, msg=&#39;modified message&#39;)
        self.assertGreater(1, 0)
        self.assertIn(0, [0])
        self.assertTrue(True)
        # 测试是否会抛出异常
        with self.assertRaises(KeyError):
            _ = dict()[1]

    # 被@unittest.skip装饰器装饰的测试类或测试函数会被跳过
    @unittest.skip(reason=&#39;just skip&#39;)
    def test_skip(self):
        raise Exception(&#39;I shall never be tested&#39;)
</code></pre>

<p>另外，<code>unittest.TestCase</code>中还有两个特殊的成员函数，他们分别会在调用每一个测试函数的前后运行。在测试前连接数据库并在测试完成后断开连接是一种常见的使用场景。</p>

<pre><code class="language-python">def setUp(self):
    # To do: connect to the database
    pass

def tearDown(self):
    # To do: release the connection
    pass

def test_database(self):
    # To do: test the database
    pass
</code></pre>

<p>测试类编写完毕后，可以通过添加以下代码来将当前文件当成正常的Python脚本使用</p>

<pre><code class="language-python">if __name__ == &#39;__main__&#39;:
  unittest.main()
</code></pre>

<h1 id="toc_24">Python数据科学速查表</h1>

<p><a href="%E9%99%84%E4%BB%B6Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E9%80%9F%E6%9F%A5%E8%A1%A8.pdf">Python数据科学速查表</a> </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[1. python简介及安装]]></title>
    <link href="ryanhuo.github.io/15822327222660.html"/>
    <updated>2020-02-21T05:05:22+08:00</updated>
    <id>ryanhuo.github.io/15822327222660.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">python简介</h2>

<p><strong>编程语言</strong>是用来定义 计算机程序 的形式语言。我们通过编程语言来编写程序代码，再通过语言处理程序执行向计算机发送指令，让计算机完成对应的工作。</p>

<p>Python也是编程语言的一种,并且是高级的编程语言。Python语言可能是第一种即简单又功能强大的编程语言。</p>

<h2 id="toc_1">python的优点</h2>

<ol>
<li><p><strong>简单</strong>：Python是一种代表简单主义思想的语言。阅读一个良好的Python程序就感觉像是在读英语一样，尽管这个英语的要求非常严格！Python的这种伪代码本质是它最大的优点之一。它使你能够专注于解决问题而不是去搞明白语言本身。</p></li>
<li><p><strong>易学</strong>：就如同你即将看到的一样，Python极其容易上手。前面已经提到了，Python有极其简单的语法。</p></li>
<li><p><strong>免费、开源</strong>：Python是FLOSS（自由/开放源码软件）之一。简单地说，你可以自由地发布这个软件的拷贝、阅读它的源代码、对它做改动、把它的一部分用于新的自由软件中。FLOSS是基于一个团体分享知识的概念。这是为什什么Python如此优秀的原因之一—它是由一群希望看到一个更更加优秀的Python的人创造并经常改进着的。</p></li>
<li><p><strong>层语言</strong>：当你用Python语言编写程序的时候，你无需考虑诸如如何管理理你的程序使用的内存一类的底层细节。</p></li>
<li><p><strong>可移植性</strong>：由于它的开源本质，Python已经被移植在许多平台上（经过改动使它能够工作在不不同平台上）。如果你小心地避免使用依赖于系统的特性，那么你的所有Python程无需修改就可以在下述任何平台上面运行。这些平台包括Linux、Windows、FreeBSD、Macintosh、Solaris、OS/2、Amiga、AROS、AS/400、BeOS、OS/390、z/OS、Palm OS、QNX、VMS、Psion、Acom RISC OS、VxWorks、PlayStation、Sharp Zaurus、Windows CE甚至还有PocketPC、Symbian以及Google基于linux开发的Android平台！</p></li>
<li><p><strong>解释性</strong>：这一点需要一些解释。一个用编译性语言比如C或C++写的程序可以从源文件（即C或C++语言）转换到一个你的计算机使用的语言（二进制代码，即0和1）。这个过程通过编译器和不同的标记、选项完成。当你运行你的程序的时候，连接/转载器软件把你的程序从硬盘复制到内存中并且运行。而Python语言写的程序不不需要编译成二进制代码。你可以直接从源代码运行程序。在计算机内部，Python解释器把源代码转换成称为字节码的中间形式，然后再把它翻译成计算机使用的机器器语言并运行。事实上，由于你不再需要担心如何编译程序，如何确保连接转载正确的库等等，所有这一切使得使用Python更更加简单。由于你只需要把你的Python程序拷贝到另外一台计算机上，它就可以工作了，这也使得你的Python程序更加易于移植。</p></li>
<li><p><strong>面向对象</strong>：Python既支持面向过程的编程也支持面向对象的编程。在“面向过程”的语言中，程序是由过程或仅仅是可重用代码的函数构建起来的。在“面向对象”的语言中，程序是由数据和功能组合而成的对象构建起来的。与其他主要的语言如C++和Java相比，Python以一种非常强大又简单的方式实现面向对象编程。</p></li>
<li><p><strong>可扩展性</strong>：如果你需要你的一段关键代码运行得更快或者希望某些算法不不公开，你可以把你的部分程序用C或C++编写，然后在你的Python程序中使用它们。</p></li>
<li><p><strong>丰富的库</strong>：Python标准库确实很庞大。它可以帮助你处理理各种工作，包括正则表达式、文档生成、单元测试、线程、数据库、网页浏览器、CGI、FTP、电子邮件、XML、XML-RPC、HTML、WAV文件、密码系统、GUI（图形用户界面）、Tk和其他与系统有关的操作。记住，只要安装了Python，所有这些功能都是可用的。这被称作Python的“功能齐全”理念。除了标准库以外，还有许多其他高质量的库，如wxPython、Twisted和Python图像库等等。</p></li>
<li><p><strong>规范的代码</strong>：Python采用强制缩进的方式使得代码具有极佳的可读性。</p></li>
</ol>

<h2 id="toc_2">pycharm安装激活</h2>

<p>PyCharm是一 Python IDE，带有一 整套可以帮助用户在使用Python语言开发时提高其效率的工具，比如调试、语法高亮、Project管理、 代码跳转、智能提示、自动完成、单元测试、版本控制。此外，该IDE提供了-些高级功能，以用于支持Django框架下的专业Web开发。</p>

<h3 id="toc_3">下载安装</h3>

<p><a href="https://www.jetbrains.com/pycharm/">官方下载地址</a></p>

<h3 id="toc_4">激活</h3>

<p>激活方式均选择License server。</p>

<p><img src="media/15822327222660/1.0.jpg" alt=""/></p>

<p>第一服务器License server address: <a href="http://39.105.114.41:1027">http://39.105.114.41:1027</a></p>

<p>第二服务器License server address: <a href="http://36.110.99.11:3456">http://36.110.99.11:3456</a></p>

<p>以上两台服务器任选一台。</p>

<h2 id="toc_5">使用Anconda方式安装Python环境</h2>

<p>Anaconda指的是一个开源的Python发行版本，其包含了conda、Python等180多个科学包及其依赖项。 因为包含了大量的科学包，Anaconda 的下载文件比较大（约 600 MB），如果只需要某些包，或者需要节省带宽或存储空间，也可以使用Miniconda这个较小的发行版（仅包含conda和 Python）。</p>

<h3 id="toc_6">下载</h3>

<p><a href="https://www.continuum.io/downloads">Python3.6版本</a></p>

<h3 id="toc_7">安装</h3>

<p>根据安装步骤下一步安装完成即可</p>

<p>anaconda自带python3.6环境不需要自己再次去官网下载python了。</p>

<h4 id="toc_8">注意： Windows如果忘记勾选添加环境变量选项需要可以进行一下操作</h4>

<p><img src="media/15822327222660/1.1.png" alt=""/><br/>
<img src="media/15822327222660/1.2.png" alt=""/><br/>
<img src="media/15822327222660/1.3.png" alt=""/></p>

<h4 id="toc_9">注意： Mac 添加环境变量</h4>

<pre><code class="language-text">export PATH=&quot;~/anaconda3/bin:$PATH&quot;
</code></pre>

<p>或者</p>

<pre><code class="language-text">vim~/.bash_profile
</code></pre>

<p>点进入编辑模式，进行编辑然后添加</p>

<pre><code class="language-text">export PATH=&quot;~/anaconda3/bin:$PATH&quot;
</code></pre>

<p>编辑完成后，点esc 退出</p>

<p>直接输入 ：:wq! 这四个字符后，回车即可保存。</p>

<h3 id="toc_10">使用</h3>

<h4 id="toc_11">界面介绍</h4>

<p><img src="media/15822327222660/1.4.png" alt=""/></p>

<h4 id="toc_12">工具介绍</h4>

<p><img src="media/15822327222660/1.5.png" alt=""/></p>

<h4 id="toc_13">添加快捷键</h4>

<p><img src="media/15822327222660/1.6.png" alt=""/></p>

<h2 id="toc_14">创建jupyter虚拟环境</h2>

<h3 id="toc_15">Windows</h3>

<h4 id="toc_16">conda关于环境的几个常用命令</h4>

<p>anaconda国内下载源：<a href="https://repo.continuum.io/archive/">https://repo.continuum.io/archive/</a></p>

<p>查看当前的环境列列表：</p>

<pre><code class="language-text">$ conda env list

创建新的python环境，并且还可以指定python的版本

$ conda create -n myenv python=3.7 激活、进入某个环境： $ activate test 退出环境： $ deactivate

删除环境： $ conda remove --name test --all

</code></pre>

<h4 id="toc_17">创建想要添加的虚拟环境</h4>

<pre><code class="language-text">conda create -n myenv python=3.5
</code></pre>

<p>创建好以后可以在C:\ProgramData\Anaconda3\envs\（具体与自己安装的anaconda路路径为准）  下找到新创建的环境</p>

<h4 id="toc_18">将新的环境添加到jupyter中</h4>

<p>第一：首先到C:\ProgramData\Anaconda3\share\jupyter\kernels 文件夹下，会有一个自带的Python3文件夹；</p>

<p>第二：然后在Python3  文件夹同级目录下创建一个文件夹test文件夹（名字自己随便取，记得是英文）；</p>

<p>第三：将Python3文件夹下的kernel.json文件复制到test文件夹下； </p>

<p>第四：用记事本打开后</p>

<pre><code class="language-text">{ &quot;argv&quot;: [ &quot;C:\\ProgramData\\Anaconda3\\python.exe&quot;, &quot;-m&quot;, &quot;ipykernel_launcher&quot;, &quot;-f&quot;, &quot;
{connection_ﬁle}&quot; ], &quot;display_name&quot;: &quot;Python 3&quot;, &quot;language&quot;: &quot;python&quot; }
</code></pre>

<p>将路径改成新创建的环境路路径，然后Python 3改成jupyter中想显示的名字。</p>

<p>第五：重启jupyter-notebook,选择新建会出现你想要的环境。</p>

<h4 id="toc_19">安装ipykernel库</h4>

<p>第一： activate myenv 激活你的虚拟环境</p>

<p>第二： conda install ipykernel , 中间会出现&lt;[y]/n&gt;? 在后面直接输入y,回车。</p>

<h4 id="toc_20">重启jupyter即可</h4>

<h3 id="toc_21">Mac</h3>

<h4 id="toc_22">mac中激活和退出某个环境的命令</h4>

<p>激活、进入某个环境： <br/>
$ source activate test</p>

<p>注意： 最新的anaconda 命令改成了conda activate test<br/>
退出环境： $ source deactivate</p>

<p>注意： 最新的anaconda 命令改成了conda deactivate</p>

<h4 id="toc_23">创建想要添加的虚拟环境</h4>

<p>$ conda create -n myenv python=3.5</p>

<h4 id="toc_24">查找kernel.json文件</h4>

<p>$ ﬁnd . -name &quot;kernel.json&quot;</p>

<p>第一：然后在 ./Library/Jupyter/kernels/ 目录下<strong>手动创建一个文件夹</strong>，然后创建一个名为 kernel.json 的文件，让该文件和已有的虚拟环境相关联，即可使用该虚拟环境。该json文件的内容大概如此：/Users/mac/Library/Jupyter/kernels/python37</p>

<p>{ &quot;display_name&quot;: &quot;py35&quot;, &quot;language&quot;: &quot;python&quot;, &quot;argv&quot;: [ &quot;/Users/mac/Library/Jupyter/kernels/python37/bin/python&quot;, &quot;-m&quot;, &quot;ipykernel_launcher&quot;, &quot;-f&quot;, &quot;{connection_ﬁle}&quot; ] }</p>

<p>第二： 重启jupyter，就会出现新的环境</p>

<p>注意： 上面操作完成之后，会提示/Users/mac/anaconda3/envs/python37/bin/python3.7: No module named ipykernel_launcher</p>

<p>第三：激活虚拟环境，然后conda install ipykernel</p>

<p>第四： 重启</p>

<h2 id="toc_25">Anaconda安装拓拓展</h2>

<p>第一： 终端输入</p>

<pre><code class="language-text">$ pip install jupyter_contrib_nbextensions
$ pip install jupyter_nbextensions_conﬁgurator
$ jupyter contrib nbextension install --user
</code></pre>

<p>第二： 重启jupyter</p>

<p><a href="https://jupyter-contrib-nbextensions.readthedocs.io/en/latest/nbextensions/code_prettify/README_code_prettify.html">关 于 插 件 的 介 绍 </a></p>

<p>例如： Hinterland 代码提示</p>

<h2 id="toc_26">jupyter汉化问题</h2>

<h3 id="toc_27">Mac</h3>

<p>jupyter在浏览器器的显示语言是根据终端语言自适应的，如果你的终端是中文，那么启动jupyter后，浏览器器就以中文显示</p>

<ol>
<li> 终端是中文状态，jupyter是中文</li>
</ol>

<p><img src="media/15822327222660/1.7.png" alt=""/></p>

<ol>
<li> 如果想显示英文，有两种方式可以设置</li>
</ol>

<h4 id="toc_28">一种是临时的</h4>

<p>终端中依次输入以下命令：</p>

<pre><code class="language-text">export LC_ALL=en_US.UTF-8
export LANG=en_US.UTF-8
</code></pre>

<p>然后在当前终端输入<code>jupyter notebook</code> 启动jupyter；</p>

<p>注意：以上的命令设置只对当前终端生效，如果在新的终端启动jupyter，还是会显示中文，目前没有对所有终端生效的方法。</p>

<h4 id="toc_29">一种是永久的</h4>

<ol>
<li> 在终端中输入locale查看系统默认的语言设置；</li>
<li> 使用vim编辑bash_proﬁle文件，修改设置，终端输入
<code>vim~/.bash_profile</code></li>
</ol>

<p><img src="media/15822327222660/1.8.png" alt=""/></p>

<ol>
<li><p>在最后一行添加<code>export LANG=en_US.UTF-8</code>这一行</p></li>
<li><p>保存文件退出，然后在终端输入<code>source ~/.bash_profile</code> ，让设置生效，然后启动</p></li>
</ol>

<p><img src="media/15822327222660/1.9.png" alt=""/></p>

<h3 id="toc_30">windows</h3>

<p>windows中在cmd中启动jupyter，默认以英文显示，如果想要中文，需要下载git。</p>

<ol>
<li> 下载地址：<a href="https://www.git-scm.com/download/win">https://www.git-scm.com/download/win</a></li>
<li> 一路路next，进行安装；</li>
<li> 安装完毕，搜索git bash并打开；</li>
<li> 打开Git bash输入命令<code>jupyter notebook</code>启动jupyter.</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2. numpy]]></title>
    <link href="ryanhuo.github.io/15822327223909.html"/>
    <updated>2020-02-21T05:05:22+08:00</updated>
    <id>ryanhuo.github.io/15822327223909.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">NumPy介绍</h2>

<p>Numpy（Numerical Python）是一个开源的Python科学计算库，用于快速处理任意维度的数组。<br/>
Numpy支持常见的数组和矩阵操作。对于同样的数值计算任务，使用Numpy比直接使用Python要简洁的多。<br/>
Numpy使用ndarray对象来处理多维数组，该对象是一个快速而灵活的大数据容器。</p>

<h2 id="toc_1">NumPy优点</h2>

<ol>
<li> 快速</li>
<li> 方便</li>
<li><p>科学计算的基础库</p></li>
</ol>

<ul>
<li><p>对于同样的数值计算任务，使用NumPy要比直接编写Python代码便捷得多；</p></li>
<li><p>NumPy中的数组的存储效率和输入输出性能均远远优于Python中等价的基本数据结构，且其能够提升的性能是   与数组中的元素成比例的；</p></li>
<li><p>NumPy的大部分代码都是用C语言写的，其底层算法在设计时就有着优异的性能，这使得NumPy比纯Python代  码高效得多</p></li>
</ul>

<h2 id="toc_2">安装</h2>

<pre><code class="language-text">pip install numpy
</code></pre>

<h2 id="toc_3">与原生list运算效率对比</h2>

<pre><code class="language-python">import random 
import time 
import numpy as np
a = []
for i in range(100000000): 
    a.append(random.random())
t1 = time.time() 
sum1=sum(a) 
t2=time.time()

b=np.array(a) 
t4=time.time() 
sum3=np.sum(b) 
t5=time.time() 

print(t2-t1, t5-t4)
</code></pre>

<pre><code class="language-text">45.5947265625 2.542968988418579
</code></pre>

<h2 id="toc_4">NumPy 的Ndarray 对象</h2>

<p>NumPy 最重要的一个特点是其 N 维数组对象 ndarray，它是一系列同类型数据的集合，以 0 下标为开始进行集合中元素的索引。ndarray 对象是用于存放同类型元素的多维数组。</p>

<h3 id="toc_5">创建一维数组</h3>

<p>多种样式创建一维数组</p>

<h4 id="toc_6">直接传入列表</h4>

<pre><code class="language-python">import numpy as np
list=[1,2,3,4]
Array_1=np.array(list)
print(Array_1,type(Array_1))
</code></pre>

<pre><code class="language-text">[1 2 3 4] &lt;class &#39;numpy.ndarray&#39;&gt;
</code></pre>

<h4 id="toc_7">传入range生成序列</h4>

<pre><code class="language-python">Array_2=np.array(range(1,10))
print(Array_2,type(Array_2))
</code></pre>

<pre><code class="language-text">[1 2 3 4 5 6 7 8 9] &lt;class &#39;numpy.ndarray&#39;&gt;
</code></pre>

<h4 id="toc_8">利用numpy自带的np.arange（）</h4>

<pre><code class="language-python">Array_3=np.arange(1,10)
print(Array_3,type(Array_3))
</code></pre>

<pre><code class="language-text">[1 2 3 4 5 6 7 8 9] &lt;class &#39;numpy.ndarray&#39;&gt;
</code></pre>

<h2 id="toc_9">创建二维数组</h2>

<pre><code class="language-python">list2=[[1,2,3],[4,5,6],[7,8,9]]

t1=np.array(list2)
print(t1,type(t1))
</code></pre>

<pre><code class="language-text">[[1 2 3]
 [4 5 6]
 [7 8 9]] &lt;class &#39;numpy.ndarray&#39;&gt;
</code></pre>

<h3 id="toc_10">常用属性</h3>

<pre><code class="language-python"># 获取数组的维度（与函数的参数相似）
print(t1.ndim)
</code></pre>

<pre><code class="language-text">2
</code></pre>

<pre><code class="language-python">#形状(行，列)
print(t1.shape)
</code></pre>

<pre><code class="language-text">(3, 3)
</code></pre>

<pre><code class="language-python">#元素个数
print(t1.size)
</code></pre>

<pre><code class="language-text">9
</code></pre>

<h3 id="toc_11">调整数组的形状</h3>

<pre><code class="language-python">t2= np.array([[1,2,3],[4,5,6]])
# 修改的是原有的four.shape = (3,2)
print(t2)

# 返回一个新的数组
t2 = t2.reshape(3,2) 
print(t2)

# 将多维变成一维数组
t3= t2.reshape((6,),order=&#39;F&#39;)
# 默认情况下‘C’以行为主的顺序展开，‘F’（Fortran风格）意味着以列的顺序展开

t4 = t2.flatten(order=&#39;F&#39;) 
print(t3)
print(t4)

</code></pre>

<pre><code class="language-text">[[1 2 3]
 [4 5 6]]
[[1 2]
 [3 4]
 [5 6]]
[1 3 5 2 4 6]
[1 3 5 2 4 6]
</code></pre>

<pre><code class="language-python"># 拓展：数组的形状
t = np.arange(24)
print(t) 
print(t.shape)


# 转换成二维
t1 = t.reshape((4,6))
print(t1) 
print(t1.shape)


# 转成三维
t2 = t.reshape((2,3,4)) 
print(t2) 
print(t2.shape)

</code></pre>

<pre><code class="language-text">[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23]
(24,)
[[ 0  1  2  3  4  5]
 [ 6  7  8  9 10 11]
 [12 13 14 15 16 17]
 [18 19 20 21 22 23]]
(4, 6)
[[[ 0  1  2  3]
  [ 4  5  6  7]
  [ 8  9 10 11]]

 [[12 13 14 15]
  [16 17 18 19]
  [20 21 22 23]]]
(2, 3, 4)
</code></pre>

<h3 id="toc_12">将数组转成list</h3>

<pre><code class="language-python">a= np.array([9, 12, 88, 14, 25])
list_a = a.tolist() 
print(list_a) 
print(type(list_a))

</code></pre>

<pre><code class="language-text">[9, 12, 88, 14, 25]
&lt;class &#39;list&#39;&gt;
</code></pre>

<h2 id="toc_13">NumPy的数据类型</h2>

<pre><code class="language-python">f = np.array([1,2,3,4,5], dtype = np.int16)

# 返回数组中每个元素的字节单位长度
print(f.itemsize) # 1 np.int8(一个字节)

</code></pre>

<pre><code class="language-text">2
</code></pre>

<pre><code class="language-python"># 获取数据类型
print(f.dtype)

</code></pre>

<pre><code class="language-text">int16
</code></pre>

<pre><code class="language-python"># 调整数据类型
f1 = f.astype(np.int64) 
print(f1.dtype)

</code></pre>

<pre><code class="language-text">int64
</code></pre>

<pre><code class="language-python"># 拓展随机生成小数
# 使用python语法，保留两位
print(round(random.random(),2))

arr = np.array([random.random() for i in range(10)])
# 取小数点后两位
print(np.round(arr,2))


</code></pre>

<pre><code class="language-text">0.02
[0.29 0.82 0.01 0.23 0.89 0.46 0.44 0.4  0.58 0.17]
</code></pre>

<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>bool</td>
<td>用一个字节存储的布尔类型（True或False）</td>
</tr>
<tr>
<td>inti</td>
<td>由所在平台决定其大小的整数（一般为int32或int64）</td>
</tr>
<tr>
<td>int8</td>
<td>一个字节大小，-128 至 127</td>
</tr>
<tr>
<td>int16</td>
<td>整数，-32768 至 32767</td>
</tr>
<tr>
<td>int32</td>
<td>整数，-2 ** 31 至 2 ** 32 -1</td>
</tr>
<tr>
<td>int64</td>
<td>整数，-2 ** 63 至 2 ** 63 - 1</td>
</tr>
<tr>
<td>uint8</td>
<td>无符号整数，0 至 255</td>
</tr>
<tr>
<td>uint16</td>
<td>无符号整数，0 至 65535</td>
</tr>
<tr>
<td>uint32</td>
<td>无符号整数，0 至 2 ** 32 - 1</td>
</tr>
<tr>
<td>uint64</td>
<td>无符号整数，0 至 2 ** 64 - 1</td>
</tr>
<tr>
<td>float16</td>
<td>半精度浮点数：16位，正负号1位，指数5位，精度10位</td>
</tr>
<tr>
<td>float32</td>
<td>单精度浮点数：32位，正负号1位，指数8位，精度23位</td>
</tr>
<tr>
<td>float64或float</td>
<td>双精度浮点数：64位，正负号1位，指数11位，精度52位</td>
</tr>
<tr>
<td>complex64</td>
<td>复数，分别用两个32位浮点数表示实部和虚部</td>
</tr>
<tr>
<td>complex128或complex</td>
<td>复数，分别用两个64位浮点数表示实部和虚部</td>
</tr>
</tbody>
</table>

<h2 id="toc_14">数组的计算</h2>

<h3 id="toc_15">数组和数的计算</h3>

<p>由于numpy的广播机机制在运算过程中，加减乘除的值被广播到所有的元素上面。</p>

<pre><code class="language-python">t1 = np.arange(24).reshape((6,4)) 
print(t1+2)
print(t1*2) 
print(t1/2)

</code></pre>

<pre><code class="language-text">[[ 2  3  4  5]
 [ 6  7  8  9]
 [10 11 12 13]
 [14 15 16 17]
 [18 19 20 21]
 [22 23 24 25]]
[[ 0  2  4  6]
 [ 8 10 12 14]
 [16 18 20 22]
 [24 26 28 30]
 [32 34 36 38]
 [40 42 44 46]]
[[ 0.   0.5  1.   1.5]
 [ 2.   2.5  3.   3.5]
 [ 4.   4.5  5.   5.5]
 [ 6.   6.5  7.   7.5]
 [ 8.   8.5  9.   9.5]
 [10.  10.5 11.  11.5]]
</code></pre>

<h3 id="toc_16">数组与数组之间的操作</h3>

<p>同种形状的数组(对应位置进行计算操作)</p>

<pre><code class="language-python">t1 = np.arange(24).reshape((6,4))
t2 = np.arange(100,124).reshape((6,4))

print(t1+t2) 
print(t1*t2)

</code></pre>

<pre><code class="language-text">[[100 102 104 106]
 [108 110 112 114]
 [116 118 120 122]
 [124 126 128 130]
 [132 134 136 138]
 [140 142 144 146]]
[[   0  101  204  309]
 [ 416  525  636  749]
 [ 864  981 1100 1221]
 [1344 1469 1596 1725]
 [1856 1989 2124 2261]
 [2400 2541 2684 2829]]
</code></pre>

<p>不种形状的多维数组不能计算</p>

<pre><code class="language-python">t1 = np.arange(24).reshape((4,6)) 
t2 = np.arange(18).reshape((3,6)) 
print(t1)
print(t2) 
print(t1-t2)

</code></pre>

<pre><code class="language-text">[[ 0  1  2  3  4  5]
 [ 6  7  8  9 10 11]
 [12 13 14 15 16 17]
 [18 19 20 21 22 23]]
[[ 0  1  2  3  4  5]
 [ 6  7  8  9 10 11]
 [12 13 14 15 16 17]]




---------------------------------------------------------------------------

ValueError                                Traceback (most recent call last)

&lt;ipython-input-32-8e6819c2b1e3&gt; in &lt;module&gt;()
      3 print(t1)
      4 print(t2)
----&gt; 5 print(t1-t2)



ValueError: operands could not be broadcast together with shapes (4,6) (3,6) 
</code></pre>

<p>行数或者列数相同的一维数组和多维数组可以进行计算： </p>

<p>行形状相同（会与每一行数组的对应位相操作)</p>

<pre><code class="language-python">t1 = np.arange(24).reshape((4,6)) 
t2 = np.arange(0,6)

print(t1-t2)


</code></pre>

<pre><code class="language-text">[[ 0  0  0  0  0  0]
 [ 6  6  6  6  6  6]
 [12 12 12 12 12 12]
 [18 18 18 18 18 18]]
</code></pre>

<p>列形状相同（会与每一个相同维度的数组的对应位相操作)</p>

<pre><code class="language-python">t1 = np.arange(24).reshape((4,6)) 
t2 = np.arange(4).reshape((4,1))

print(t1-t2)


</code></pre>

<pre><code class="language-text">[[ 0  1  2  3  4  5]
 [ 5  6  7  8  9 10]
 [10 11 12 13 14 15]
 [15 16 17 18 19 20]]
</code></pre>

<h2 id="toc_17">数组中的轴</h2>

<ol>
<li><p>什么是轴： 在numpy中可以理解为方向，使用0，1，2数字表示，对于一个一维数组，只有一个0轴， 对于2维数组（shape（2，2))有0轴和1轴， 对于3维数组（shape（2，2，3））有0，1，2轴</p></li>
<li><p>为什么要学习轴：有了轴的概念后，我们计算会更加方便，比如计算一个2维数组的平均值，必须指定是计算哪个方向上面的数字的平均值。</p></li>
</ol>

<p><img src="media/15822327223909/20191127155610-1577075803629.png" alt="20191127155610"/></p>

<p><img src="media/15822327223909/20191127155642-1577075815036.png" alt="20191127155642"/></p>

<pre><code class="language-python">import numpy as np
a = np.array([[1,2,3],[4,5,6]])

print(np.sum(a,axis=0)) # [5 7 9]

print(np.sum(a,axis = 1)) # [ 6 15]

print(np.sum(a))# 计算所有的值的和


</code></pre>

<pre><code class="language-text">[5 7 9]
[ 6 15]
21
</code></pre>

<pre><code class="language-python">#三维的数据
a = np.arange(27).reshape((3,3,3))
print(a)

</code></pre>

<pre><code class="language-text">[[[ 0  1  2]
  [ 3  4  5]
  [ 6  7  8]]

 [[ 9 10 11]
  [12 13 14]
  [15 16 17]]

 [[18 19 20]
  [21 22 23]
  [24 25 26]]]
</code></pre>

<pre><code class="language-python">b = np.sum(a, axis=0)
print(b)


</code></pre>

<pre><code class="language-text">[[27 30 33]
 [36 39 42]
 [45 48 51]]
</code></pre>

<pre><code class="language-python">c = np.sum(a, axis=1)
print(c)

</code></pre>

<pre><code class="language-text">[[ 9 12 15]
 [36 39 42]
 [63 66 69]]
</code></pre>

<pre><code class="language-python">c = np.sum(a, axis=2)
print(c)

</code></pre>

<pre><code class="language-text">[[ 3 12 21]
 [30 39 48]
 [57 66 75]]
</code></pre>

<p><strong>总结：</strong>在计算的时候可以想象成是每一个坐标轴，分别计算这个轴上面的每一个刻度上的值，或者在二维数组中记住0表示列1表示行.</p>

<h2 id="toc_18">数组的索引和切片</h2>

<p>一维数组的操作方法</p>

<pre><code class="language-python">import numpy as np

a = np.arange(10)
# 冒号分隔切片参数 start:stop:step 来进行切片操作

print(a[2:7:2])# 从索引 2 开始到索引 7 停止，间隔为 2

# 如果只放置一个参数，如 [2]，将返回与该索引相对应的单个元素
print(a[2],a)

# 如果为 [2:]，表示从该索引开始以后的所有项都将被提取
print(a[2:])


</code></pre>

<pre><code class="language-text">[2 4 6]
2 [0 1 2 3 4 5 6 7 8 9]
[2 3 4 5 6 7 8 9]
</code></pre>

<p>多维数组的操作方法</p>

<pre><code class="language-python">import numpy as np
t1 = np.arange(24).reshape(4,6) 
print(t1)
print(&#39;*&#39;*20)
print(t1[1]) # 取一行(一行代表是一条数据，索引也是从0开始的) 
print(t1[1,:]) # 取一行

print(t1[1:])# 取连续的多行
print(t1[1:3,:])# 取连续的多行

print(t1[[0,2,3]])# 取不连续的多行
print(t1[[0,2,3],:])# 取不连续的多行

print(t1[:,1])# 取一列
print(t1[:,1:])# 连续的多列
print(t1[:,[0,2,3]])# 取不连续的多列
print(t1[2,3])# # 取某一个值,三行四列
print(t1[[0,1,1],[0,1,3]])# 取多个不连续的值，[[行，行。。。],[列，列。。。]]

</code></pre>

<pre><code class="language-text">[[ 0  1  2  3  4  5]
 [ 6  7  8  9 10 11]
 [12 13 14 15 16 17]
 [18 19 20 21 22 23]]
********************
[ 6  7  8  9 10 11]
[ 6  7  8  9 10 11]
[[ 6  7  8  9 10 11]
 [12 13 14 15 16 17]
 [18 19 20 21 22 23]]
[[ 6  7  8  9 10 11]
 [12 13 14 15 16 17]]
[[ 0  1  2  3  4  5]
 [12 13 14 15 16 17]
 [18 19 20 21 22 23]]
[[ 0  1  2  3  4  5]
 [12 13 14 15 16 17]
 [18 19 20 21 22 23]]
[ 1  7 13 19]
[[ 1  2  3  4  5]
 [ 7  8  9 10 11]
 [13 14 15 16 17]
 [19 20 21 22 23]]
[[ 0  2  3]
 [ 6  8  9]
 [12 14 15]
 [18 20 21]]
15
[0 7 9]
</code></pre>

<h2 id="toc_19">组中的数值修改</h2>

<pre><code class="language-python">t = np.arange(24).reshape(4,6)

# 修改某一行的值
t[1,:]=0

# 修改某一列的值
t[:,1]=0

# 修改连续多行
t[1:3,:]=0

# 修改连续多列
t[:,1:4]=0

# 修改多行多列，取第二行到第四行，第三列到第五列
t[1:4,2:5]=0

# 修改多个不相邻的点
t[[0,1],[0,3]]=0

# 可以根据条件修改，比如讲小于10的值改掉
t[t&lt;10]=0

# 使用逻辑判断
# np.logical_and    &amp; 
# np.logical_or |
# np.logical_not        ~ 

t[(t&gt;2)&amp;(t&lt;6)]=0    # 与
t[(t&lt;2)|(t&gt;6)]=0    # 或
t[~(t&gt;6)]=0 # 非
print(t)

# 拓 展
# 三目运算（ np.where(condition, x, y)满足条件(condition)，输出x，不满足输出y。)）
# score = np.array([[80,88],[82,81],[75,81]])
# result = np.where(score&gt;80,True,False) 
# print(result)

</code></pre>

<pre><code class="language-text">[[0 0 0 0 0 0]
 [0 0 0 0 0 0]
 [0 0 0 0 0 0]
 [0 0 0 0 0 0]]
</code></pre>

<h2 id="toc_20">数组的添加、删除和去重</h2>

<h3 id="toc_21">数组的添加</h3>

<ol>
<li>numpy.append 函数在数组的末尾添加值。 追加操作会分配整个数组，并把原来的数组复制到新数组中。 此外，输入数组的维度必须匹配否则将生成ValueError。</li>
</ol>

<p><strong>参数说明：</strong></p>

<ul>
<li>arr：输入数组</li>
<li>values：要向arr添加的值，需要和arr形状相同（除了要添加的轴）</li>
<li>axis：默认为 None。当axis无定义时，是横向加成，返回总是为一维数组！当axis有定义的时候，分别为0和1的时候。当</li>
<li>axis有定义的时候，分别为0和1的时候（列数要相同）。当axis为1时，数组是加在右边（行数要相同）。</li>
</ul>

<pre><code class="language-python">a = np.array([[1,2,3],[4,5,6]])

print (&#39;第一个数组：&#39;)
print (a)
print (&#39;\n&#39;)

print (&#39; 向 数 组 添 加 元 素 ：&#39;) 
print (np.append(a, [7,8,9])) 
print (&#39;\n&#39;)

print (&#39;沿轴 0 添加元素：&#39;)
print (np.append(a, [[7,8,9]],axis = 0)) 
print (&#39;\n&#39;)

print (&#39;沿轴 1 添加元素：&#39;)
print (np.append(a, [[5,5,5],[7,8,9]],axis = 1))


</code></pre>

<pre><code class="language-text">第一个数组：
[[1 2 3]
 [4 5 6]]
</code></pre>

<p>​<br/><br/>
​     向 数 组 添 加 元 素 ：<br/>
​    [1 2 3 4 5 6 7 8 9]</p>

<p>​<br/><br/>
​    沿轴 0 添加元素：<br/>
​    [[1 2 3]<br/>
​     [4 5 6]<br/>
​     [7 8 9]]</p>

<p>​<br/><br/>
​    沿轴 1 添加元素：<br/>
​    [[1 2 3 5 5 5]<br/>
​     [4 5 6 7 8 9]]</p>

<ol>
<li><p>numpy.insert 函数在给定索引之前，沿给定轴在输入数组中插入值。</p>
<p>如果值的类型转换为要插入，则它与输入数组不同。 插入没有原地的，函数会返回一个新数组。 此外，如果未提供轴，则输入数组会被展开。</p></li>
</ol>

<pre><code class="language-python">a = np.array([[1,2],[3,4],[5,6]])

print (&#39;第一个数组：&#39;) 
print (a)
print (&#39;\n&#39;)

print (&#39;未传递 Axis 参数。 在插入之前输入数组会被展开。&#39;) 
print (np.insert(a,3,[11,12]))
print (&#39;\n&#39;)
print (&#39;传递了 Axis 参数。 会广播值数组来配输入数组。&#39;)

print (&#39;沿轴  0 广播：&#39;)
print (np.insert(a,1,[11],axis = 0)) 
print (&#39;\n&#39;)

print (&#39;沿轴  1 广播：&#39;)
print (np.insert(a,1,11,axis = 1))


</code></pre>

<pre><code class="language-text">第一个数组：
[[1 2]
 [3 4]
 [5 6]]
</code></pre>

<p>​<br/><br/>
​    未传递 Axis 参数。 在插入之前输入数组会被展开。<br/>
​    [ 1  2  3 11 12  4  5  6]</p>

<p>​<br/><br/>
​    传递了 Axis 参数。 会广播值数组来配输入数组。<br/>
​    沿轴  0 广播：<br/>
​    [[ 1  2]<br/>
​     [11 11]<br/>
​     [ 3  4]<br/>
​     [ 5  6]]</p>

<p>​<br/><br/>
​    沿轴  1 广播：<br/>
​    [[ 1 11  2]<br/>
​     [ 3 11  4]<br/>
​     [ 5 11  6]]</p>

<h3 id="toc_22">数组中的删除</h3>

<p>numpy.delete 函数返回从输入数组中删除指定子数组的新数组。 与 insert() 函数的情况一样，如果未提供轴参数， 则输入数组将展开。</p>

<p><strong>参数说明：</strong></p>

<ul>
<li><p>arr： 输入数组  </p></li>
<li><p>obj：可以被切片，整数或者整数数组，表明要从输入数组删除的子数组</p></li>
<li><p>axis：沿着它删除给定子数组的轴，如果未提供，则输入数组会被展开</p></li>
</ul>

<pre><code class="language-python">a = np.arange(12).reshape(3,4)
print (&#39;第一个数组：&#39;)
print (a)
print (&#39;\n&#39;)

print (&#39;未传递 Axis 参数。 在删除之前输入数组会被展开。&#39;) 
print (np.delete(a,5))
print (&#39;\n&#39;)

print (&#39;删除每一行中的第二列：&#39;)
print (np.delete(a,1,axis = 1)) 
print (&#39;\n&#39;)


</code></pre>

<pre><code class="language-text">第一个数组：
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
</code></pre>

<p>​<br/><br/>
​    未传递 Axis 参数。 在删除之前输入数组会被展开。<br/>
​    [ 0  1  2  3  4  6  7  8  9 10 11]</p>

<p>​<br/><br/>
​    删除每一行中的第二列：<br/>
​    [[ 0  2  3]<br/>
​     [ 4  6  7]<br/>
​     [ 8 10 11]]</p>

<p>​<br/><br/>
​    </p>

<h3 id="toc_23">数组去重</h3>

<p>numpy.unique 函数用于去除数组中的重复元素。</p>

<ul>
<li>arr：输入数组 ，如果不是一维数组则会展开                         * return_index：如果为true，返回新列表元素在旧列表中的位置（下标），并以列表形式储</li>
<li>return_inverse：如果为true，返回旧列表元素在新列表中的位置（下标），并以列表形式储</li>
<li>return_counts：如果为true，返回去重数组中的元素在原数组中的出现次数</li>
</ul>

<pre><code class="language-python">a = np.array([5,2,6,2,7,5,6,8,2,9])
print (&#39;第一个数组：&#39;) 
print (a)
print (&#39;\n&#39;)

print (&#39;第一个数组的去重值：&#39;) 
u = np.unique(a)
print (u)
print (&#39;\n&#39;)


print (&#39;去重数组的索引数组：&#39;)
u,indices = np.unique(a, return_index = True) 
print (indices)
print (&#39;\n&#39;)

print (&#39;我们可以看到每个和原数组下标对应的数值：&#39;) 
print (a)
print (&#39;\n&#39;)

print (&#39;去重数组的下标：&#39;)
u,indices = np.unique(a,return_inverse = True) 
print (u)
print (indices) 
print (&#39;\n&#39;)

print (&#39;返回去重元素的重复数量：&#39;)
u,indices = np.unique(a,return_counts = True) # print (u)
print (indices)

</code></pre>

<pre><code class="language-text">第一个数组：
[5 2 6 2 7 5 6 8 2 9]
</code></pre>

<p>​<br/><br/>
​    第一个数组的去重值：<br/>
​    [2 5 6 7 8 9]</p>

<p>​<br/><br/>
​    去重数组的索引数组：<br/>
​    [1 0 2 4 7 9]</p>

<p>​<br/><br/>
​    我们可以看到每个和原数组下标对应的数值：<br/>
​    [5 2 6 2 7 5 6 8 2 9]</p>

<p>​<br/><br/>
​    去重数组的下标：<br/>
​    [2 5 6 7 8 9]<br/>
​    [1 0 2 0 3 1 2 4 0 5]</p>

<p>​<br/><br/>
​    返回去重元素的重复数量：<br/>
​    [3 2 2 1 1 1]</p>

<h2 id="toc_24">numpy的计算</h2>

<pre><code class="language-python">score = np.array([[80,88],[82,81],[75,81]])
print(score)

</code></pre>

<pre><code class="language-text">[[80 88]
 [82 81]
 [75 81]]
</code></pre>

<h3 id="toc_25">获取所有数据最大值</h3>

<pre><code class="language-python">print(np.max(score))

</code></pre>

<pre><code class="language-text">88
</code></pre>

<h3 id="toc_26">获取某个轴上的数据最大值</h3>

<pre><code class="language-python">print(np.max(score,axis=0))

</code></pre>

<pre><code class="language-text">[82 88]
</code></pre>

<h3 id="toc_27">获取最小值</h3>

<pre><code class="language-python">print(np.min(score))

</code></pre>

<pre><code class="language-text">75
</code></pre>

<h3 id="toc_28">获取某个轴上最小值</h3>

<pre><code class="language-python">print(np.min(score,axis=0))

</code></pre>

<pre><code class="language-text">[75 81]
</code></pre>

<h3 id="toc_29">数据的比较</h3>

<pre><code class="language-python">t1=[1,2,3,4,5,6,7,8]
print(t1)

</code></pre>

<pre><code class="language-text">[1, 2, 3, 4, 5, 6, 7, 8]
</code></pre>

<pre><code class="language-python">print(np.maximum(t1,0)) # 第一个参数中的每一个数与第二个参数比较返回大的

</code></pre>

<pre><code class="language-text">[1 2 3 4 5 6 7 8]
</code></pre>

<pre><code class="language-python">print(np.minimum(t1,0))# 第一个参数中的每一个数与第二个参数比较返回小的

</code></pre>

<pre><code class="language-text">[0 0 0 0 0 0 0 0]
</code></pre>

<pre><code class="language-python"># 接受的两个参数，也可以大小一致;第二个参数只是一个单独的值时，其实是用到了维度的广播机制
print(np.maximum(t1,[2,4,6,8,9,1,3,5]))

</code></pre>

<pre><code class="language-text">[2 4 6 8 9 6 7 8]
</code></pre>

<h3 id="toc_30">求平均值</h3>

<pre><code class="language-python">print(np.mean(t1))# 获取所有数据的平均值

</code></pre>

<pre><code class="language-text">4.5
</code></pre>

<pre><code class="language-python">print(np.mean(score,axis=0))

</code></pre>

<pre><code class="language-text">[79.         83.33333333]
</code></pre>

<h3 id="toc_31">求前缀和</h3>

<pre><code class="language-python">arr = np.array([[1,2,3], [4,5,6]]) 
print(arr)
print(&#39;*&#39;*20)
print(&#39;&#39;&#39;
[1, 2, 3]------&gt;    |  1   |  2   |  3  |
[4, 5, 6]------&gt;    |5=1+4 |7=2+5 |9=3+6| &#39;&#39;&#39;)
print(&#39;*&#39;*20)
print(arr.cumsum(0))

</code></pre>

<pre><code class="language-text">[[1 2 3]
 [4 5 6]]
********************

[1, 2, 3]------&gt;    |  1   |  2   |  3  |
[4, 5, 6]------&gt;    |5=1+4 |7=2+5 |9=3+6| 
********************
[[1 2 3]
 [5 7 9]]
</code></pre>

<pre><code class="language-python">print(&#39;&#39;&#39;
[1, 2, 3]------&gt;    |1  |2+1    |3+2+1  |
[4, 5, 6]------&gt;    |4  |4+5    |4+5+6  | &#39;&#39;&#39;)
print(&#39;*&#39;*20)
print(arr.cumsum(1)) 

</code></pre>

<pre><code class="language-text">[1, 2, 3]------&gt;    |1  |2+1    |3+2+1  |
[4, 5, 6]------&gt;    |4  |4+5    |4+5+6  | 
********************
[[ 1  3  6]
 [ 4  9 15]]
</code></pre>

<h3 id="toc_32">求最小索引值</h3>

<pre><code class="language-python">print(np.argmin(score,axis=0))

</code></pre>

<pre><code class="language-text">[2 1]
</code></pre>

<h3 id="toc_33">求每一列的标准差</h3>

<p>标准差是一组数据平均值分散程度的一种度量。一个较大的标准差，代表大部分数值和其平均值之间差异较大；</p>

<p>一个较小的标准差，代表这些数据较接近平均值反应出数据的波动稳定情况，越大表示波动越大，越不稳定。</p>

<pre><code class="language-python">print(np.std(score,axis=0))

</code></pre>

<pre><code class="language-text">[2.94392029 3.29983165]
</code></pre>

<h3 id="toc_34">极 值</h3>

<pre><code class="language-python">np.ptp(score,axis=None)# 就是最大值和最小值的差

</code></pre>

<pre><code class="language-text">13
</code></pre>

<h3 id="toc_35">拓展</h3>

<ul>
<li>方差var</li>
<li>协方差cov</li>
<li>计算平均值 average</li>
<li>计算中位数 median</li>
</ul>

<h2 id="toc_36">通用函数</h2>

<table>
<thead>
<tr>
<th>函数</th>
<th>介绍</th>
</tr>
</thead>

<tbody>
<tr>
<td>numpy.sqrt(array)</td>
<td>平方根函数</td>
</tr>
<tr>
<td>numpy.exp(array)</td>
<td>e<sup>array[i]的数组</sup></td>
</tr>
<tr>
<td>numpy.abs/fabs(array)</td>
<td>计算绝对值</td>
</tr>
<tr>
<td>numpy.square(array)</td>
<td>计算各元素的平方 等于array**2</td>
</tr>
<tr>
<td>numpy.log/log10/log2(array)</td>
<td>计算各元素的各种对数</td>
</tr>
<tr>
<td>numpy.sign(array)</td>
<td>计算各元素正负号</td>
</tr>
<tr>
<td>numpy.isnan(array)</td>
<td>计算各元素是否为NaN</td>
</tr>
<tr>
<td>numpy.isinf(array)</td>
<td>计算各元素是否为NaN</td>
</tr>
<tr>
<td>numpy.cos/cosh/sin/sinh/tan/tanh(array)</td>
<td>三角函数</td>
</tr>
<tr>
<td>numpy.modf(array)</td>
<td>将array中值得整数和小数分离，作两个数组返回</td>
</tr>
<tr>
<td>numpy.ceil(array)</td>
<td>向上取整,也就是取比这个数大的整数</td>
</tr>
<tr>
<td>numpy.floor(array)</td>
<td>向下取整,也就是取比这个数小的整数</td>
</tr>
<tr>
<td>numpy.rint(array)</td>
<td>四舍五入</td>
</tr>
<tr>
<td>numpy.trunc(array)</td>
<td>向0取整</td>
</tr>
<tr>
<td>numpy.cos(array)</td>
<td>正弦值</td>
</tr>
<tr>
<td>numpy.sin(array)</td>
<td>余弦值</td>
</tr>
<tr>
<td>numpy.tan(array)</td>
<td>正切值</td>
</tr>
<tr>
<td>numpy.add(array1,array2)</td>
<td>元素级加法</td>
</tr>
<tr>
<td>numpy.subtract(array1,array2)</td>
<td>元素级减法</td>
</tr>
<tr>
<td>numpy.multiply(array1,array2)</td>
<td>元素级乘法</td>
</tr>
<tr>
<td>numpy.divide(array1,array2)</td>
<td>元素级除法 array1./array2</td>
</tr>
<tr>
<td>numpy.power(array1,array2)</td>
<td>元素级指数 array1.<sup>array2</sup></td>
</tr>
<tr>
<td>numpy.maximum/minimum(array1,aray2)</td>
<td>元素级最大值</td>
</tr>
<tr>
<td>numpy.fmax/fmin(array1,array2)</td>
<td>元素级最大值，忽略NaN</td>
</tr>
<tr>
<td>numpy.mod(array1,array2)</td>
<td>元素级求模</td>
</tr>
<tr>
<td>numpy.copysign(array1,array2)</td>
<td>将第二个数组中值得符号复制给第一个数组中值</td>
</tr>
<tr>
<td>numpy.greater/greater_equal/less/less_equal/equal/not_equal  (array1,array2)</td>
<td>元素级比较运算，产生布尔数组</td>
</tr>
<tr>
<td>numpy.logical_end/logical_or/logic_xor(array1,array2)</td>
<td>元素级的真值逻辑运算</td>
</tr>
</tbody>
</table>

<h2 id="toc_37">数组的拼接</h2>

<p>有的时候我们需要将两个数据加起来一起研究分析，我们就可以将其进行拼接然后分析</p>

<h3 id="toc_38">根据轴连接的数组序列</h3>

<pre><code class="language-python">a = np.array([[1,2],[3,4]])
b = np.array([[5,6],[7,8]])

#要求a,b两个数组的维度相同
print (&#39;沿轴 0 连接两个数组：&#39;)
print (np.concatenate((a,b),axis= 0))
print (&#39;\n&#39;)
print (&#39;沿轴 1 连接两个数组：&#39;)
print (np.concatenate((a,b),axis = 1))

</code></pre>

<pre><code class="language-text">沿轴 0 连接两个数组：
[[1 2]
 [3 4]
 [5 6]
 [7 8]]
</code></pre>

<p>​<br/><br/>
​    沿轴 1 连接两个数组：<br/>
​    [[1 2 5 6]<br/>
​     [3 4 7 8]]</p>

<h3 id="toc_39">根据轴进行堆叠</h3>

<pre><code class="language-python">print (&#39;沿轴 0 连接两个数组：&#39;)
print (np.stack((a,b),axis= 0))
print (&#39;\n&#39;)
print (&#39;沿轴 1 连接两个数组：&#39;)
print (np.stack((a,b),axis = 1))

</code></pre>

<pre><code class="language-text">沿轴 0 连接两个数组：
[[[1 2]
  [3 4]]

 [[5 6]
  [7 8]]]
</code></pre>

<p>​<br/><br/>
​    沿轴 1 连接两个数组：<br/>
​    [[[1 2]<br/>
​      [5 6]]<br/>
​<br/><br/>
​     [[3 4]<br/>
​      [7 8]]]</p>

<h3 id="toc_40">矩阵垂直拼接</h3>

<pre><code class="language-python">v1 = [[0,1,2,3,4,5],
    [6,7,8,9,10,11]] 

v2 = [[12,13,14,15,16,17],
    [18,19,20,21,22,23]] 

result = np.vstack((v1,v2)) 
print(result)

</code></pre>

<pre><code class="language-text">[[ 0  1  2  3  4  5]
 [ 6  7  8  9 10 11]
 [12 13 14 15 16 17]
 [18 19 20 21 22 23]]
</code></pre>

<h3 id="toc_41">矩阵水平拼接</h3>

<pre><code class="language-python">result = np.hstack((v1,v2)) 
print(result)

</code></pre>

<pre><code class="language-text">[[ 0  1  2  3  4  5 12 13 14 15 16 17]
 [ 6  7  8  9 10 11 18 19 20 21 22 23]]
</code></pre>

<h2 id="toc_42">数组的分割</h2>

<h3 id="toc_43">将一个数组分割为多个子数组</h3>

<p><strong>参数说明：</strong></p>

<ul>
<li>ary： 被分割的数组<br/></li>
<li>indices_or_sections：果是一个整数，就用该数平均切分，如果是一个数组，为沿轴切分的位置（左开右闭）</li>
<li>axis：沿着哪个维度进行切向，默认为0，横向切分。为1时，纵向切分</li>
</ul>

<pre><code class="language-python">arr = np.arange(9).reshape(3,3)
print (&#39;将数组分为三个大小相等的子数组：&#39;) 
b= np.split(arr,3)
print (b)

</code></pre>

<pre><code class="language-text">将数组分为三个大小相等的子数组：
[array([[0, 1, 2]]), array([[3, 4, 5]]), array([[6, 7, 8]])]
</code></pre>

<h3 id="toc_44">numpy.hsplit 函数用于水平分割数组，通过指定要返回的相同形状的数组数量来拆分原数组。</h3>

<pre><code class="language-python">harr = np.floor(10 * np.random.random((2, 6))) #
print (&#39;原array：&#39;)
print(harr)

print (&#39;拆分后：&#39;)
print(np.hsplit(harr, 3))

</code></pre>

<pre><code class="language-text">原array：
[[6. 9. 3. 6. 1. 1.]
 [8. 3. 1. 7. 4. 5.]]
拆分后：
[array([[6., 9.],
       [8., 3.]]), array([[3., 6.],
       [1., 7.]]), array([[1., 1.],
       [4., 5.]])]
</code></pre>

<h3 id="toc_45">numpy.vsplit</h3>

<p>沿着垂直轴分割</p>

<pre><code class="language-python">a = np.arange(16).reshape(4,4)
print (&#39;第一个数组：&#39;) 
print (a)
print (&#39;\n&#39;)

print (&#39;竖直分割：&#39;)
b = np.vsplit(a,2) 
print (b)

</code></pre>

<pre><code class="language-text">第一个数组：
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]
 [12 13 14 15]]
</code></pre>

<p>​<br/><br/>
​    竖直分割：<br/>
​    [array([[0, 1, 2, 3],<br/>
​           [4, 5, 6, 7]]), array([[ 8,  9, 10, 11],<br/>
​           [12, 13, 14, 15]])]</p>

<h2 id="toc_46">数组中nan和inf</h2>

<p>C 语言中表示最大的正整数值是 0x7FFF FFFF，最小的负整数是 0x8000 0000。<br/>
查阅资料后，发现 inf 表示无穷大，需要使用 float(‘inf’) 函数来转化，那么对应的就有  float(&#39;-inf&#39;) 表示无穷小了。这样你就可以使用任意数来判断和它的关系了。</p>

<p>那什么时候会出现inf呢？ 比如一个数字除以0，Python中会报错，但是numpy中会是一个inf或者-inf</p>

<p>另外还有 nan，这种写法在 pandans 中常见，表示缺失的数据，所以一般用 nan 来表示。任何与其做运算结果都是 nan</p>

<pre><code class="language-python"># 创建一个nan和inf 
a = np.nan 
b = np.inf
print(a,type(a)) 
print(b,type(b))

#--判断数组中为nan的个数
t = np.arange(24,dtype=float).reshape(4,6)

#将三行四列的数改成nan 
t[3,4] = np.nan

#可以使用np.count_nonzero() 来判断非零的个数
print(np.count_nonzero(t))
#并 且  np.nan != np.nan  结果 是TRUE
#所以我们可以使用这两个结合使用判断nan的个数
print(np.count_nonzero(t != t))

#将nan替换为0
t[np.isnan(t)] = 0 
print(t)

</code></pre>

<pre><code class="language-text">nan &lt;class &#39;float&#39;&gt;
inf &lt;class &#39;float&#39;&gt;
23
1
[[ 0.  1.  2.  3.  4.  5.]
 [ 6.  7.  8.  9. 10. 11.]
 [12. 13. 14. 15. 16. 17.]
 [18. 19. 20. 21.  0. 23.]]
</code></pre>

<pre><code class="language-python">#----------练习： 处理数组中nan
t = np.arange(24).reshape(4,6).astype(&#39;float&#39;)
#将数组中的一部分替换nan 
t[1,3:] = np.nan
print(t)
#遍历每一列，然后判断每一列是否有nan 
for i in range(t.shape[1]):
#   #获取当前列数据
    temp_col = t[:,i]
#
#   判断当前列的数据中是否含有nan
    nan_num = np.count_nonzero(temp_col != temp_col)
#
    if nan_num != 0: #条件成立说明含有nan 
    # 将这一列不为nan的数据拿出来
        temp_col_not_nan = temp_col[temp_col==temp_col]
# 将nan替换成这一列的平均值
        temp_col[np.isnan(temp_col)] = np.mean(temp_col_not_nan)
print(t)

</code></pre>

<pre><code class="language-text">[[ 0.  1.  2.  3.  4.  5.]
 [ 6.  7.  8. nan nan nan]
 [12. 13. 14. 15. 16. 17.]
 [18. 19. 20. 21. 22. 23.]]
[[ 0.  1.  2.  3.  4.  5.]
 [ 6.  7.  8. 13. 14. 15.]
 [12. 13. 14. 15. 16. 17.]
 [18. 19. 20. 21. 22. 23.]]
</code></pre>

<h2 id="toc_47">二维数组的转置</h2>

<pre><code class="language-python">#对换数组的维度
a = np.arange(12).reshape(3,4) 
print (&#39;原数组：&#39;)
print (a )
print (&#39;\n&#39;)

print (&#39;对换数组：&#39;)
print (np.transpose(a))

# 与transpose一致
a = np.arange(12).reshape(3,4)

print (&#39;原数组：&#39;) 
print (a)
print (&#39;\n&#39;)

print (&#39;转置数组：&#39;) 
print (a.T)

# 函数用于交换数组的两个轴
t1 = np.arange(24).reshape(4,6)
re = t1.swapaxes(1,0) 
print (&#39; 原 数 组 ：&#39;) 
print (t1)
print (&#39;\n&#39;)

print (&#39;调用 swapaxes 函数后的数组：&#39;) 
print (re)

</code></pre>

<pre><code class="language-text">原数组：
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
</code></pre>

<p>​<br/><br/>
​    对换数组：<br/>
​    [[ 0  4  8]<br/>
​     [ 1  5  9]<br/>
​     [ 2  6 10]<br/>
​     [ 3  7 11]]<br/>
​    原数组：<br/>
​    [[ 0  1  2  3]<br/>
​     [ 4  5  6  7]<br/>
​     [ 8  9 10 11]]</p>

<p>​<br/><br/>
​    转置数组：<br/>
​    [[ 0  4  8]<br/>
​     [ 1  5  9]<br/>
​     [ 2  6 10]<br/>
​     [ 3  7 11]]<br/>
​     原 数 组 ：<br/>
​    [[ 0  1  2  3  4  5]<br/>
​     [ 6  7  8  9 10 11]<br/>
​     [12 13 14 15 16 17]<br/>
​     [18 19 20 21 22 23]]</p>

<p>​    调用 swapaxes 函数后的数组：<br/>
​    [[ 0  6 12 18]<br/>
​     [ 1  7 13 19]<br/>
​     [ 2  8 14 20]<br/>
​     [ 3  9 15 21]<br/>
​     [ 4 10 16 22]<br/>
​     [ 5 11 17 23]]</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[1. matplotlib]]></title>
    <link href="ryanhuo.github.io/15822327223959.html"/>
    <updated>2020-02-21T05:05:22+08:00</updated>
    <id>ryanhuo.github.io/15822327223959.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">matplotlib介绍</h2>

<p>Matplotlib是一个Python2D绘图库，它可以在各种平台上以各种硬拷贝格式和交互式环境生成出具有出版品质的图形。 Matplotlib可用于Python脚本，Python和IPython shell，Jupyter笔记本，Web应用程序服务器和四个图形用户界面工具包。</p>

<p>Matplotlib试图让简单的事情变得更简单，让无法实现的事情变得可能实现。 只需几行代码即可生成绘图，直方图， 功率谱，条形图，错误图，散点图等。</p>

<p>为了简单绘图，pyplot模块提供了类似于MATLAB的界面，特别是与IPython结合使用时。 对于高级用户，您可以通过面向对象的界面或MATLAB用户熟悉的一组函数完全控制线条样式，字体属性，轴属性等。</p>

<h2 id="toc_1">matplotlib优点</h2>

<p>可视化是在整个数据挖掘的关键辅助工具，可以清晰的理解数据，从而调整我们的分析方法。</p>

<ul>
<li>能将数据进行可视化,更直观的呈现</li>
<li>使数据更加客观、更具说服力</li>
</ul>

<p>例如下面两个图为数字展示和图形展示：<br/>
<img src="media/15822327223959/2.1.jpg" alt=""/></p>

<h2 id="toc_2">常见图形种类及意义</h2>

<ul>
<li><p>折线图：以折线的上升或下降来表示统计数量的增减变化的统计图</p>
<p><strong>特点：能够显示数据的变化趋势，反映事物的变化情况。(变化)</strong></p></li>
</ul>

<p><img src="media/15822327223959/clip_image007.gif" alt=""/></p>

<ul>
<li><p>散点图：用两组数据构成多个坐标点，考察坐标点的分布,判断两变量之间是否存在某种关联或总结坐标点的分布模式。</p>
<p><strong>特点：判断变量之间是否存在数量关联趋势,展示离群点(分布规律)</strong></p></li>
</ul>

<p><img src="media/15822327223959/20191127101123.png" alt=""/></p>

<ul>
<li>柱状图：排列在工作表的列或行中的数据可以绘制到柱状图中。
<strong>特点：绘制连离散的数据,能够一眼看出各个数据的大小,比较数据之间的差别。(统计/对比)</strong>
<img src="media/15822327223959/20191127101217.png" alt=""/></li>
<li>直方图：由一系列高度不等的纵向条纹或线段表示数据分布的情况。   一般用横轴表示数据范围，纵轴表示分布情况。
<strong>特点：绘制连续性的数据展示一组或者多组数据的分布状况(统计)</strong></li>
</ul>

<p><img src="media/15822327223959/20191127101232.png" alt=""/></p>

<ul>
<li>饼图：用于表示不同分类的占比情况，通过弧度大小来对比各种分类。
<strong>特点：分类数据的占比情况(占比)</strong>
<img src="media/15822327223959/20191127101311.png" alt=""/></li>
</ul>

<h2 id="toc_3">安装</h2>

<pre><code class="language-text">source activate python37 
pip install matplotlib
</code></pre>

<h2 id="toc_4">Matplotlib画图</h2>

<pre><code class="language-python"># 导入模块
import matplotlib.pyplot as plt
# 在jupyter中执行的时候显示图片
%matplotlib inline
# 传入x和y, 通过plot画图
plt.plot([1, 0, 9], [4, 5, 6])
# 在执行程序的时候展示图形
plt.show()
</code></pre>

<p><img src="media/15822327223959/output20.png" alt="png"/></p>

<h2 id="toc_5">matplotlib图像结构的认识</h2>

<p><img src="media/15822327223959/20191127101529.png" alt=""/></p>

<h2 id="toc_6">折线图</h2>

<h3 id="toc_7">折线图的绘制</h3>

<pre><code class="language-python">from matplotlib import pyplot as plt 
x = range(1,8) # x轴的位置
y = [17, 17, 18, 15, 11, 11, 13]
# 传入x和y, 通过plot画折线图
plt.plot(x,y) 
plt.show()
</code></pre>

<p><img src="media/15822327223959/output40.png" alt="png"/></p>

<h3 id="toc_8">折线图的颜色和形状设置</h3>

<pre><code class="language-python">from matplotlib import pyplot as plt 


x = range(1,8) # x轴的位置
y = [17, 17, 18, 15, 11, 11, 13]
# 传入x和y, 通过plot画折线图
plt.plot(x, y, color=&#39;red&#39;,alpha=0.5,linestyle=&#39;--&#39;,linewidth=3) 


&#39;&#39;&#39;
基础属性设置
color=&#39;red&#39; : 折线的颜色
alpha=0.5: 折线的透明度(0-1) 
linestyle=&#39;--&#39; : 折线的样式
linewidth=3 : 折线的宽度
&#39;&#39;&#39;

&#39;&#39;&#39;
线的样式
-   实线(solid)
--  短线(dashed)
-.  短点相间线(dashdot)
：   虚点线(dotted)
&#39;&#39;&#39;
plt.show()
</code></pre>

<p><img src="media/15822327223959/output60.png" alt="png"/></p>

<h3 id="toc_9">折点样式</h3>

<pre><code class="language-python">from matplotlib import pyplot as plt 
x = range(1,8) # x轴的位置
y = [17, 17, 18, 15, 11, 11, 13]
# 传入x和y, 通过plot画折线图
plt.plot(x, y, marker=&#39;o&#39;) 
plt.show()
&#39;&#39;&#39;
折点形状选择:
================    ===============================
 
character   description
================    ===============================
``&#39;-&#39;`` solid line style
``&#39;--&#39;``    dashed line style
``&#39;-.&#39;``    dash-dot line style
``&#39;:&#39;`` dotted line style
``&#39;.&#39;`` point marker
``&#39;,&#39;`` pixel marker
``&#39;o&#39;`` circle marker
``&#39;v&#39;`` triangle_down marker
``&#39;^&#39;`` triangle_up marker
``&#39;&lt;&#39;`` triangle_left marker
``&#39;&gt;&#39;`` triangle_right marker
``&#39;1&#39;`` tri_down marker
``&#39;2&#39;`` tri_up marker
``&#39;3&#39;`` tri_left marker
``&#39;4&#39;`` tri_right marker
``&#39;s&#39;`` square marker
``&#39;p&#39;`` pentagon marker
``&#39;*&#39;`` star marker
``&#39;h&#39;`` hexagon1 marker
``&#39;H&#39;`` hexagon2 marker
``&#39;+&#39;`` plus marker
``&#39;x&#39;`` x marker
``&#39;D&#39;`` diamond marker
``&#39;d&#39;`` thin_diamond marker
``&#39;|&#39;`` vline marker
``&#39;_&#39;`` hline marker
&#39;&#39;&#39;

plt.show()

</code></pre>

<p><img src="media/15822327223959/output80.png" alt="png"/></p>

<h3 id="toc_10">设置图片的大小和保存</h3>

<pre><code class="language-python">from matplotlib import pyplot as plt 
import random

x = range(2,26,2) # x轴的位置
y = [random.randint(15, 30) for i in x]
# 设置图片的大小
&#39;&#39;&#39;
figsize:指定figure的宽和高，单位为英寸；
dpi参数指定绘图对象的分辨率，即每英寸多少个像素，缺省值为80    1英寸等于2.5cm,A4纸是 21*30cm的纸张
&#39;&#39;&#39;
# 根据画布对象
plt.figure(figsize=(20,8),dpi=80)
 
plt.plot(x,y)   # 传入x和y, 通过plot画图
# plt.show()
# 保存(注意： 要放在绘制的下面,并且plt.show()会释放figure资源，如果在显示图像之后保存图片将只能保存空图片。)
plt.savefig(&#39;./t1.png&#39;)
# 图片的格式也可以保存为svg这种矢量图格式，这种矢量图放在网页中放大后不会有锯齿
# plt.savefig(&#39;./t1.svg&#39;)
</code></pre>

<p><img src="media/15822327223959/output100.png" alt="png"/></p>

<h3 id="toc_11">绘制x轴和y轴刻度</h3>

<pre><code class="language-python">from matplotlib import pyplot as plt 
x = range(2,26,2) # x轴的位置
y = [random.randint(15, 30) for i in x] 
plt.figure(figsize=(20,8),dpi=80)

# 设置x轴的刻度
# plt.xticks(x)
# plt.xticks(range(1,25))
# 设置y轴的刻度
# plt.yticks(y)
# plt.yticks(range(min(y),max(y)+1))

# 构造x轴刻度标签
x_ticks_label = [&quot;{}:00&quot;.format(i) for i in x] #rotation = 45 让字旋转45度plt.xticks(x,x_ticks_label,rotation = 45)
# 设置y轴的刻度标签
y_ticks_label = [&quot;{}℃&quot;.format(i) for i in range(min(y),max(y)+1)]
plt.yticks(range(min(y),max(y)+1),y_ticks_label)

# 绘 图
plt.plot(x,y) 
plt.show()
</code></pre>

<p><img src="media/15822327223959/output120.png" alt="png"/></p>

<h3 id="toc_12">设置显示中文</h3>

<pre><code class="language-python"># matplotlib只显示英文,无法显示中文，需要修改matplotlib的默认字体
# 通过matplotlib下的font_manager可以解决
# 两个小时内的每分钟跳动变化
from matplotlib import pyplot as plt 
import matplotlib
import random


x = range(0,120)
y = [random.randint(10,30) for i in range(120)]
plt.figure(figsize=(20,8),dpi=80) 
plt.plot(x,y)
# 加坐标轴信息
# 在有中文输出的地方，增加一个属性： fontproperties
# plt.xlabel(&#39;时间&#39;,fontproperties = &#39;simHei&#39;,fontsize=20)
&#39;&#39;&#39;
另外一种写法
查看Linux、Mac下支持的字体
终端执行： fc-list
查看支持的中文（冒号前面有空格) fc-list :lang=zh
查看Windows下的字体：“C:\Windows\Fonts”
可以自己下载字体文件（xxx.ttf），然后双击安装即可

# my_font = font_manager.FontProperties(fname=&#39;/System/Library/Fonts/PingFang.ttc&#39;,size=18) 
# plt.ylabel(&quot;天气&quot;,fontproperties=my_font)
&#39;&#39;&#39;



from matplotlib import font_manager
my_font = font_manager.FontProperties(fname=r&quot;C:/Windows/Fonts/msyh.ttc&quot;,size=16)#msyh为微软雅黑

#rotation将字体旋转45度
plt.xlabel(&#39;时间&#39;,rotation=45,fontproperties=my_font)
plt.ylabel(&quot;次数&quot;,fontproperties=my_font)

# 设置标题
plt.title(&#39;每分钟跳动次数&#39;,fontproperties=my_font,color=&#39;green&#39;)

plt.show()
</code></pre>

<p><img src="media/15822327223959/output140.png" alt="png"/></p>

<h3 id="toc_13">一图多线</h3>

<pre><code class="language-python">y1 = [1,0,1,1,2,4,3,4,4,5,6,5,4,3,3,1,1,1,1,1]
y2 = [1,0,3,1,2,2,3,4,3,2,1,2,1,1,1,1,1,1,1,1]
 
x = range(11,31) # # 设置图形
plt.figure(figsize=(20,8),dpi=80) 
&#39;&#39;&#39;
添加图例:label 对线的解释，然后用plt.legend添加到图片上;
添加颜色: color=&#39;red&#39;
线条风格： linestyle=&#39;-&#39;;    - 实线 、 -- 虚线，破折线、 -. 点划线、 : 点虚线，虚线、 &#39;&#39; 留空或空格线条粗细： linewidth = 5
透明度：    alpha=0.5
&#39;&#39;&#39;
plt.plot(x,y1,color=&#39;red&#39;,label=&#39;自己&#39;)
plt.plot(x,y2,color=&#39;blue&#39;,label=&#39;同事&#39;)
# 设置x轴刻度
xtick_labels = [&#39;{}岁&#39;.format(i) for i in x]
my_font = font_manager.FontProperties(fname=r&quot;C:/Windows/Fonts/msyh.ttc&quot;,size=16) 
plt.xticks(x,xtick_labels,fontproperties=my_font,rotation=45)
# 绘制网格（网格也是可以设置线的样式)
#alpha=0.4 设置透明度
plt.grid(alpha=0.4)

# 添加图例(注意：只有在这里需要添加prop参数是显示中文，其他的都用fontproperties)
# 设置位置loc : upper left、 lower left、 center left、 upper center
plt.legend(prop=my_font,loc=&#39;upper right&#39;)

#展示
plt.show()

</code></pre>

<p><img src="media/15822327223959/output160.png" alt="png"/></p>

<h3 id="toc_14">拓展（一图多个坐标系子图）</h3>

<pre><code class="language-python">import matplotlib.pyplot as plt 
import numpy as np

x = np.arange(1, 100)
#划分子图
fig,axes=plt.subplots(2,2)
ax1=axes[0,0]
ax2=axes[0,1] 
ax3=axes[1,0] 
ax4=axes[1,1]

fig=plt.figure(figsize=(20,10),dpi=80)
# 作 图 1 
ax1.plot(x, x)
#作图2
ax2.plot(x, -x)
#作图3
ax3.plot(x, x ** 2)
# ax3.grid(color=&#39;r&#39;, linestyle=&#39;--&#39;, linewidth=1,alpha=0.3)
#作图4
ax4.plot(x, np.log(x)) 
plt.show()
</code></pre>

<p><img src="media/15822327223959/output180.png" alt="png"/></p>

<pre><code class="language-text">&lt;Figure size 1600x800 with 0 Axes&gt;
</code></pre>

<pre><code class="language-python"># add_subplot方法 给figure新增子图
import numpy as np
import matplotlib.pyplot as plt 
x = np.arange(0,100)
#新建figure对象
fig=plt.figure(figsize=(20,10),dpi=80)
# 新 建 子 图 1 
ax1=fig.add_subplot(2,2,1)
ax1.plot(x, x)
# 新 建 子 图 2 
ax3=fig.add_subplot(2,2,2)
ax3.plot(x, x ** 2)
ax3.grid(color=&#39;r&#39;, linestyle=&#39;--&#39;, linewidth=1,alpha=0.3)
# 新 建 子 图 3 
ax4=fig.add_subplot(2,2,3)
ax4.plot(x, np.log(x)) 
plt.show()
</code></pre>

<pre><code class="language-text">E:\anaconda\lib\site-packages\ipykernel_launcher.py:16: RuntimeWarning: divide by zero encountered in log
  app.launch_new_instance()
</code></pre>

<p><img src="media/15822327223959/output191.png" alt="png"/></p>

<h2 id="toc_15">绘制散点图</h2>

<p><strong>题干</strong>:3月份每天最高气温</p>

<p>a = [11,17,16,11,12,11,12,6,6,7,8,9,12,15,14,17,18,21,16,17,20,14,15,15,15,19,21,22,22,22,23] </p>

<pre><code class="language-python">from matplotlib import pyplot as plt 
from matplotlib import font_manager
y = [11,17,16,11,12,11,12,6,6,7,8,9,12,15,14,17,18,21,16,17,20,14,15,15,15,19,21,22,22,22,23]
x = range(1,32)#3月份31天

# 设置图形大小
plt.figure(figsize=(20,8),dpi=80)

# 使用scatter绘制散点图
plt.scatter(x,y,label= &#39;3月份&#39;)

# 调整x轴的刻度
my_font = font_manager.FontProperties(fname=r&quot;C:/Windows/Fonts/msyh.ttc&quot;,size=10)

_xticks_labels = [&#39;3 月 {} 日 &#39;.format(i) for i in x] 
plt.xticks(x[::3],_xticks_labels[::3],fontproperties=my_font,rotation=45)
plt.xlabel(&#39;日期&#39;,fontproperties=my_font)
plt.ylabel(&#39;温度&#39;,fontproperties=my_font)
# 图 例
plt.legend(prop=my_font) 
plt.show()
</code></pre>

<p><img src="media/15822327223959/output210.png" alt="png"/></p>

<h2 id="toc_16">绘制条形图</h2>

<p>假设你获取到了2019年内地电影票房前20的电影（列表a)和电影票房数据（列表b)，请展示该数据</p>

<p>a = [&#39;流浪地球&#39;,&#39;疯狂的外星人&#39;,&#39;飞驰人生&#39;,&#39;大黄蜂&#39;,&#39;熊出没·原始时代&#39;,&#39;新喜剧之王&#39;]</p>

<p>b = [&#39;38.13&#39;,&#39;19.85&#39;,&#39;14.89&#39;,&#39;11.36&#39;,&#39;6.47&#39;,&#39;5.93&#39;] </p>

<pre><code class="language-python">from matplotlib import pyplot as plt 
from matplotlib import font_manager

my_font = font_manager.FontProperties(fname=r&quot;C:/Windows/Fonts/msyh.ttc&quot;,size=10) 

a = [&#39;流浪地球&#39;,&#39;疯狂的外星人&#39;,&#39;飞驰人生&#39;,&#39;大黄蜂&#39;,&#39;熊出没·原始时代&#39;,&#39;新喜剧之王&#39;]
b = [38.13,19.85,14.89,11.36,6.47,5.93]

plt.figure(figsize=(20,8),dpi=80)#确定图形大小
 
# 绘制条形图的方法
&#39;&#39;&#39;
width=0.3   条形的宽度
&#39;&#39;&#39;
rects = plt.bar(range(len(a)),b,width=0.3,color=&#39;g&#39;) 
plt.xticks(range(len(a)),a,fontproperties=my_font,rotation=45)
# 在条形图上加标注(水平居中) 
for rect in rects:
    height = rect.get_height()
    
plt.text(rect.get_x() + rect.get_width() / 2, height+0.3, str(height),ha=&quot;center&quot;) 
plt.show()

</code></pre>

<p><img src="media/15822327223959/output230.png" alt="png"/></p>

<h2 id="toc_17">直方图</h2>

<p>现有250部电影的时长，希望统计出这些电影时长的分布状态(比如时长为100分钟到120分钟电影的数量，出现的频率)等信息，你应该如何呈现这些数据？</p>

<pre><code class="language-python">from matplotlib import pyplot as plt 
from matplotlib import font_manager
# 1）准备数据
time = [131,98,125,131,124,139,131, 117, 128, 108, 135, 138, 131, 102, 107, 114,
119,128,121,142,127,130,124, 101, 110, 116, 117, 110, 128, 128, 115,99,
136,126,134,95,138,117,111,78, 132, 124, 113, 150, 110, 117,86,95, 144,
105, 126, 130,126, 130, 126, 116, 123, 106, 112, 138, 123,86, 101,99, 136,123,
117,119,105,137, 123, 128, 125, 104, 109, 134, 125, 127,105, 120,107,129, 116,
108,132,103,136, 118, 102, 120, 114,105, 115, 132, 145, 119, 121,112,139, 125,
138,109,132,134,156, 106, 117, 127, 144, 139, 139, 119, 140,83,110,102,123,
107,143,115,136, 118, 139, 123, 112, 118, 125, 109, 119, 133,112,114,122, 109,
106,123,116,131,127, 115, 118, 112, 135,115,146,137,116,103,144,83,123,
111,110,111,100,154,136, 100, 118, 119, 133,134,106,129,126,110,111,109,
141,120, 117, 106, 149, 122, 122, 110, 118, 127, 121, 114, 125, 126,114, 140, 103,
130,141, 117, 106, 114, 121, 114, 133, 137,92,121,112,146,97,137, 105,98,
117,112,81,97, 139, 113,134, 106, 144, 110, 137,137,111,104,117, 100, 111,
101,110,105, 129, 137, 112, 120, 113, 133, 112,83,94,146,133,101,131, 116,
111,84, 137, 115, 122, 106, 144, 109, 123, 116, 111,111, 133, 150]

my_font = font_manager.FontProperties(fname=r&quot;C:/Windows/Fonts/msyh.ttc&quot;,size=10)  
# 2）创建画布
plt.figure(figsize=(20, 8), dpi=100) 

# 3）绘制直方图
# 设置组距
distance = 2
# 计算组数
group_num = int((max(time) - min(time)) / distance)
# 绘制直方图
plt.hist(time, bins=group_num)

# 修改x轴刻度显示
plt.xticks(range(min(time), max(time))[::2])

# 添加网格显示
plt.grid(linestyle=&quot;--&quot;, alpha=0.5)

# 添加x, y轴描述信息
plt.xlabel(&quot;电影时长大小&quot;,fontproperties=my_font)
plt.ylabel(&quot;电影的数据量&quot;,fontproperties=my_font)

# 4）显示图像
plt.show()
</code></pre>

<p><img src="media/15822327223959/output250.png" alt="png"/></p>

<h2 id="toc_18">饼状图</h2>

<pre><code class="language-python">import matplotlib.pyplot as plt
import matplotlib
from matplotlib import font_manager
my_font = font_manager.FontProperties(fname=r&quot;C:/Windows/Fonts/msyh.ttc&quot;,size=10)

#正常显示中文的方法
plt.rcParams[&#39;font.sans-serif&#39;]=[&#39;SimHei&#39;]



label_list = [&quot;第一部分&quot;, &quot;第二部分&quot;, &quot;第三部分&quot;]   # 各部分标签
size = [55, 35, 10] # 各部分大小
color = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]    # 各部分颜色
explode = [0, 0.05, 0]  # 各部分突出值
&quot;&quot;&quot;
绘制饼图
explode：设置各部分突出
label:设置各部分标签
labeldistance:设置标签文本距圆心位置，1.1表示1.1倍半径autopct：设置圆里面文本
shadow：设置是否有阴影
startangle：起始角度，默认从0开始逆时针转pctdistance：设置圆内文本距圆心距离
返回值
l_text：圆内部文本，matplotlib.text.Text object
p_text：圆外部文本
&quot;&quot;&quot;
patches, l_text, p_text = plt.pie(size,
                                  explode=explode, 
                                  colors=color, 
                                  labels=label_list, 
                                  labeldistance=1.1, 
                                  autopct=&quot;%1.1f%%&quot;, 
                                  shadow=False, 
                                  startangle=90, 
                                  pctdistance=0.6)


plt.axis(&quot;equal&quot;)   # 设置横轴和纵轴大小相等，这样饼才是圆的
plt.legend() 
plt.show()

</code></pre>

<p><img src="media/15822327223959/output270.png" alt="png"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[3. pandas]]></title>
    <link href="ryanhuo.github.io/15822327224092.html"/>
    <updated>2020-02-21T05:05:22+08:00</updated>
    <id>ryanhuo.github.io/15822327224092.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">Pandas简介</h2>

<p>Pandas 是基于NumPy 的一种工具，该工具是为了解决数据分析任务而创建的。Pandas 纳入了大量库和一些标准的数据模型，提供了高效地操作大型数据集所需的工具。pandas提供了大量能使我们快速便捷地处理数据的函数和方法。</p>

<h2 id="toc_1">Series对象</h2>

<p>Pandas基于两种数据类型：series与dataframe。</p>

<p>Series是Pandas中最基本的对象，Series类似一种一维数组。事实上，Series 基本上就是基于 NumPy 的数组对象来的。和 NumPy 的数组不同，Series 能为数据自定义标签，也就是索引（index），然后通过索引来访问数组中的数据。</p>

<p>Dataframe是一个二维的表结构。Pandas的dataframe可以存储许多种不同的数据类型，并且每一个坐标轴都有自己的标签。你可以把它想象成一个series的字典项。</p>

<pre><code class="language-python">import pandas as pd
from pandas import Series,DataFrame
import numpy as np
</code></pre>

<h3 id="toc_2">创建series</h3>

<p>index 参数是可省略的，你可以选择不输入这个参数。<br/>
如果不带 index 参数，Pandas 会自动用默认 index 进行索引，类似数组，索引值是 [0, ..., len(data) - 1]</p>

<pre><code class="language-python">sel=Series([1,2,3,4])
print(sel)
</code></pre>

<pre><code class="language-text">0    1
1    2
2    3
3    4
dtype: int64
</code></pre>

<pre><code class="language-python">#通常创建方式
sel=Series([1,2,3,4],index=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])
#sel=Series([1,2,3,4],index=list(&#39;abcd&#39;))
print(sel)
</code></pre>

<pre><code class="language-text">a    1
b    2
c    3
d    4
dtype: int64
</code></pre>

<pre><code class="language-python">print(sel.values) #获取索引值
print(sel.index) #获取检索值
print(sel.iteritems()) #获取索引和值对
</code></pre>

<pre><code class="language-text">[1 2 3 4]
Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;], dtype=&#39;object&#39;)
&lt;zip object at 0x00000000085838C8&gt;
</code></pre>

<h4 id="toc_3">字典转化为Series</h4>

<pre><code class="language-python">dict={&quot;red&quot;:100,&quot;black&quot;:400,&quot;green&quot;:300,&quot;pink&quot;:900}
se3=Series(dict) 
print(se3)
</code></pre>

<pre><code class="language-text">red      100
black    400
green    300
pink     900
dtype: int64
</code></pre>

<h4 id="toc_4">Series数据获取</h4>

<pre><code class="language-python"># Series对象同时支持位置和标签两种方式获取数据
print(&#39;索引下标&#39;,sel[&#39;c&#39;])
print(&#39;位置下标&#39;,sel[2])
</code></pre>

<pre><code class="language-text">索引下标 3
位置下标 3
</code></pre>

<pre><code class="language-python">#获取不连续的数据
print(&#39;索引下标&#39;,sel[[&#39;a&#39;,&#39;c&#39;]])
print(&#39;位置下标&#39;,sel[[1,3]])
</code></pre>

<pre><code class="language-text">索引下标 a    1
c    3
dtype: int64
位置下标 b    2
d    4
dtype: int64
</code></pre>

<pre><code class="language-python">#可以使用切片获取数据
print(&#39;索引下标&#39;,sel[&#39;a&#39;:&#39;c&#39;])
print(&#39;位置下标&#39;,sel[0:3])
</code></pre>

<pre><code class="language-text">索引下标 a    1
b    2
c    3
dtype: int64
位置下标 a    1
b    2
c    3
dtype: int64
</code></pre>

<pre><code class="language-python">#重新赋值索引值
sel.index=[&#39;d&#39;,&#39;f&#39;,&#39;h&#39;,&#39;g&#39;]
print(sel)
</code></pre>

<pre><code class="language-text">d    1
f    2
h    3
g    4
dtype: int64
</code></pre>

<pre><code class="language-python">#ReIndex重新索引,会返回一个新的Series(调用reindex将会重新排序，缺失值则用NaN填补) 
print(sel.reindex([&#39;b&#39;,&#39;a&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;]))
print(sel)

</code></pre>

<pre><code class="language-text">b    NaN
a    NaN
c    NaN
d    1.0
e    NaN
dtype: float64
d    1
f    2
h    3
g    4
dtype: int64
</code></pre>

<pre><code class="language-python">#Drop丢弃指定轴的项
se1=pd.Series(range(10,15)) 
print(se1) 
print(se1.drop([2,3]))

</code></pre>

<pre><code class="language-text">0    10
1    11
2    12
3    13
4    14
dtype: int64
0    10
1    11
4    14
dtype: int64
</code></pre>

<h3 id="toc_5">Series 进行算术运算操作</h3>

<p>对 Series 的算术运算都是基于 index 进行的。</p>

<p>我们可以用加减乘除（+ - * /）这样的运算符对两个 Series 进行运算，</p>

<p>Pandas 将会根据索引 index，对响应的数据进行计算，结果将会以浮点数的形式存储，以避免丢失精度。</p>

<p>如果 Pandas 在两个 Series 里找不到相同的 index，对应的位置就返回一个空值 NaN</p>

<pre><code class="language-python">series1 = pd.Series([1,2,3,4],[&#39;London&#39;,&#39;HongKong&#39;,&#39;Humbai&#39;,&#39;lagos&#39;])
series2 = pd.Series([1,3,6,4],[&#39;London&#39;,&#39;Accra&#39;,&#39;lagos&#39;,&#39;Delhi&#39;])

</code></pre>

<pre><code class="language-python">print(series1+series2)
print(&#39;-&#39;*20)
print(series1+series2)
print(&#39;-&#39;*20)
print(series1*series2)

</code></pre>

<pre><code class="language-text">Accra        NaN
Delhi        NaN
HongKong     NaN
Humbai       NaN
London       2.0
lagos       10.0
dtype: float64
--------------------
Accra        NaN
Delhi        NaN
HongKong     NaN
Humbai       NaN
London       2.0
lagos       10.0
dtype: float64
--------------------
Accra        NaN
Delhi        NaN
HongKong     NaN
Humbai       NaN
London       1.0
lagos       24.0
dtype: float64
</code></pre>

<h4 id="toc_6">series支持numpy数组运算</h4>

<pre><code class="language-python">sel =Series(data = [1,6,3,5], index =[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;]) 
print(sel[sel&gt;3])#布尔数组过滤
print(&#39;-&#39;*20)
print(sel*2)
print(&#39;-&#39;*20)
print(np.square(sel))#直接加入到numpy的数学函数

</code></pre>

<pre><code class="language-text">b    6
d    5
dtype: int64
--------------------
a     2
b    12
c     6
d    10
dtype: int64
--------------------
a     1
b    36
c     9
d    25
dtype: int64
</code></pre>

<h2 id="toc_7">DataFrame</h2>

<p>DataFrame（数据表）是一种 2 维数据结构，数据以表格的形式存储，分成若干行和列。通过 DataFrame，你能很方便地处理数据。常见的操作比如选取、替换行或列的数据，还能重组数据表、修改索引、多重筛选等。我们基本上   可以把 DataFrame 理解成一组采用同样索引的 Series 的集合。调用DataFrame()可以将多种格式的数据转换为<br/>
DataFrame对象，它的的三个参数data、index和columns分别为数据、行索引和列索引。</p>

<h3 id="toc_8">DataFrame的创建</h3>

<pre><code class="language-python">df1 = DataFrame(np.random.randint(0,10,(4,4)),index=[1,2,3,4],columns=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;]) 
print(df1)

</code></pre>

<pre><code class="language-text">   a  b  c  d
1  9  3  7  2
2  8  8  4  3
3  5  5  7  0
4  4  0  7  2
</code></pre>

<h4 id="toc_9">字典创建</h4>

<p>行索引由index决定，列索引由字典的键决定</p>

<pre><code class="language-python">dict={
&#39;Province&#39;: [&#39;Guangdong&#39;, &#39;Beijing&#39;, &#39;Qinghai&#39;, &#39;Fujian&#39;],
&#39;pop&#39;: [1.3, 2.5, 1.1, 0.7],
&#39;year&#39;: [2018, 2018, 2018, 2018]}
df2=pd.DataFrame(dict,index=[1,2,3,4]) 
print(df2)


</code></pre>

<pre><code class="language-text">    Province  pop  year
1  Guangdong  1.3  2018
2    Beijing  2.5  2018
3    Qinghai  1.1  2018
4     Fujian  0.7  2018
</code></pre>

<h4 id="toc_10">使用from_dict</h4>

<pre><code class="language-python">dict2={&#39;a&#39;:[1,2,3],&#39;b&#39;:[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]}
df3=pd.DataFrame.from_dict(dict2)
print(df3)

</code></pre>

<pre><code class="language-text">   a  b
0  1  a
1  2  b
2  3  c
</code></pre>

<pre><code class="language-python">#索引相同的情况下，相同索引的值会相对应，缺少的值会添加NaN 
data = {
    &#39;Name&#39;:pd.Series([&#39;zs&#39;,&#39;ls&#39;,&#39;we&#39;],index=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]),
    &#39;Age&#39;:pd.Series([&#39;10&#39;,&#39;20&#39;,&#39;30&#39;,&#39;40&#39;],index=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;]),
    &#39;country&#39;:pd.Series([&#39;中国&#39;,&#39;日本&#39;,&#39;韩国&#39;],index=[&#39;a&#39;,&#39;c&#39;,&#39;b&#39;])
}

df = pd.DataFrame(data) 
print(df)
# to_dict()方法将DataFrame对象转换为字典
dict = df.to_dict()
print(dict)


</code></pre>

<pre><code class="language-text">  Name Age country
a   zs  10      中国
b   ls  20      韩国
c   we  30      日本
d  NaN  40     NaN
{&#39;Name&#39;: {&#39;a&#39;: &#39;zs&#39;, &#39;b&#39;: &#39;ls&#39;, &#39;c&#39;: &#39;we&#39;, &#39;d&#39;: nan}, &#39;Age&#39;: {&#39;a&#39;: &#39;10&#39;, &#39;b&#39;: &#39;20&#39;, &#39;c&#39;: &#39;30&#39;, &#39;d&#39;: &#39;40&#39;}, &#39;country&#39;: {&#39;a&#39;: &#39;中国&#39;, &#39;b&#39;: &#39;韩国&#39;, &#39;c&#39;: &#39;日本&#39;, &#39;d&#39;: nan}}
</code></pre>

<h3 id="toc_11">DataFrame对象常用属性</h3>

<pre><code class="language-python">import pandas as pd
from pandas import Series,DataFrame
import numpy as np

#数据
df_dict = {
    &#39;name&#39;:[&#39;James&#39;,&#39;Curry&#39;,&#39;Iversion&#39;],
    &#39;age&#39;:[&#39;18&#39;,&#39;20&#39;,&#39;19&#39;],
    &#39;national&#39;:[&#39;us&#39;,&#39;China&#39;,&#39;us&#39;]
}


df=pd.DataFrame(df_dict,index=[0,1,2])

print(df)

</code></pre>

<pre><code class="language-text">       name age national
0     James  18       us
1     Curry  20    China
2  Iversion  19       us
</code></pre>

<pre><code class="language-python">#获取行列数
print(df.shape)

</code></pre>

<pre><code class="language-text">(3, 3)
</code></pre>

<pre><code class="language-python">#获取行索引
print(df.index.tolist())

</code></pre>

<pre><code class="language-text">[0, 1, 2]
</code></pre>

<pre><code class="language-python">#获取列索引
print(df.columns.tolist())

</code></pre>

<pre><code class="language-text">[&#39;name&#39;, &#39;age&#39;, &#39;national&#39;]
</code></pre>

<pre><code class="language-python">#获取数据类型
print(df.dtypes)

</code></pre>

<pre><code class="language-text">name        object
age         object
national    object
dtype: object
</code></pre>

<pre><code class="language-python">#获取数据维度
print(df.ndim)

</code></pre>

<pre><code class="language-text">2
</code></pre>

<pre><code class="language-python">#values属性也会以二维ndarray的形式返回DataFrame的数据
print(df.values)

</code></pre>

<pre><code class="language-text">[[&#39;James&#39; &#39;18&#39; &#39;us&#39;]
 [&#39;Curry&#39; &#39;20&#39; &#39;China&#39;]
 [&#39;Iversion&#39; &#39;19&#39; &#39;us&#39;]]
</code></pre>

<pre><code class="language-python">#展示概况
print(df.info())

</code></pre>

<pre><code class="language-text">&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
Int64Index: 3 entries, 0 to 2
Data columns (total 3 columns):
name        3 non-null object
age         3 non-null object
national    3 non-null object
dtypes: object(3)
memory usage: 96.0+ bytes
None
</code></pre>

<pre><code class="language-python">#显示头两行，默认头五行
print(df.head(2))

</code></pre>

<pre><code class="language-text">    name age national
0  James  18       us
1  Curry  20    China
</code></pre>

<pre><code class="language-python">#显示后几行
print(df.tail(2))

</code></pre>

<pre><code class="language-text">       name age national
1     Curry  20    China
2  Iversion  19       us
</code></pre>

<pre><code class="language-python">#获取DataFrame的列
print(df[&#39;name&#39;])
print(&#39;-&#39;*20)
#因为我们只获取一列，所以返回的就是一个 Series 
print(type(df[&#39;name&#39;]))
print(&#39;-&#39;*20)
# 如果获取多个列，那返回的就是一个 DataFrame 类型：
print(df[[&#39;name&#39;,&#39;age&#39;]])
print(type(df[[&#39;name&#39;,&#39;age&#39;]]))


</code></pre>

<pre><code class="language-text">0       James
1       Curry
2    Iversion
Name: name, dtype: object
--------------------
&lt;class &#39;pandas.core.series.Series&#39;&gt;
--------------------
       name age
0     James  18
1     Curry  20
2  Iversion  19
&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
</code></pre>

<pre><code class="language-python"># 获取一行
print(df[0:1])
print(&#39;-&#39;*20)
# 获取多行
print(df[1:3])
print(&#39;-&#39;*20)
# 取多行里面的某一列（不能进行多行多列的选择）
print(df[1:3][[&#39;name&#39;,&#39;age&#39;]])
# 注意： df[]只能进行行选择，或列选择，不能同时多行多列选择。



</code></pre>

<pre><code class="language-text">    name age national
0  James  18       us
--------------------
       name age national
1     Curry  20    China
2  Iversion  19       us
--------------------
       name age
1     Curry  20
2  Iversion  19
</code></pre>

<pre><code class="language-python">&#39;&#39;&#39;df.loc 通过标签索引行数据
df.iloc 通过位置获取行数据
&#39;&#39;&#39;
# 获取某一行某一列的数据
print(df.loc[0,&#39;name&#39;])
print(&#39;-&#39;*20)

# 一行所有列
print(df.loc[0,:])
print(&#39;-&#39;*20)

# 某一行多列的数据
print(df.loc[0,[&#39;name&#39;,&#39;age&#39;]])
print(&#39;-&#39;*20)

# 选择间隔的多行多列
print(df.loc[[0,2],[&#39;name&#39;,&#39;national&#39;]])
print(&#39;-&#39;*20)

# 选择连续的多行和间隔的多列
print(df.loc[0:2,[&#39;name&#39;,&#39;national&#39;]])
print(&#39;-&#39;*20)

# 取一行
print(df.iloc[1])
print(&#39;-&#39;*20)

# 取连续多行
print(df.iloc[0:2])
print(&#39;-&#39;*20)

# 取间断的多行
print(df.iloc[[0,2],:])
print(&#39;-&#39;*20)

# 取某一列
print(df.iloc[:,1])
print(&#39;-&#39;*20)

# 某一个值
print(df.iloc[1,0])

</code></pre>

<pre><code class="language-text">James
--------------------
name        James
age            18
national       us
Name: 0, dtype: object
--------------------
name    James
age        18
Name: 0, dtype: object
--------------------
       name national
0     James       us
2  Iversion       us
--------------------
       name national
0     James       us
1     Curry    China
2  Iversion       us
--------------------
name        Curry
age            20
national    China
Name: 1, dtype: object
--------------------
    name age national
0  James  18       us
1  Curry  20    China
--------------------
       name age national
0     James  18       us
2  Iversion  19       us
--------------------
0    18
1    20
2    19
Name: age, dtype: object
--------------------
Curry
</code></pre>

<pre><code class="language-python"># 修改值
df.iloc[0,0]=&#39;panda&#39; 
print(df)
print(&#39;-&#39;*40)
# dataframe中的排序方法
df = df.sort_values(by=&#39;age&#39;,ascending=False) 
# ascending=False： 降序排列，默认是升序
print(df)


</code></pre>

<pre><code class="language-text">       name age national
1     panda  20    China
2  Iversion  19       us
0     panda  18       us
----------------------------------------
       name age national
1     panda  20    China
2  Iversion  19       us
0     panda  18       us
</code></pre>

<h3 id="toc_12">dataframe修改index、columns</h3>

<pre><code class="language-python">df1=pd.DataFrame(np.arange(9).reshape(3,3),index=[&#39;bi&#39;,&#39;sh&#39;,&#39;oz&#39;],columns=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;])
print(df1)

</code></pre>

<pre><code class="language-text">    a  b  c
bi  0  1  2
sh  3  4  5
oz  6  7  8
</code></pre>

<pre><code class="language-python">#修改df1的index
df1.index=[&#39;beijing&#39;,&#39;shanghai&#39;,&#39;xiamen&#39;]
print(df1)

</code></pre>

<pre><code class="language-text">          a  b  c
beijing   0  1  2
shanghai  3  4  5
xiamen    6  7  8
</code></pre>

<pre><code class="language-python">#定义map函数（x是原有行列）
def test_map(x):
    return x+&#39;_ABC&#39;
print(df1.rename(index=test_map,columns=test_map))


</code></pre>

<pre><code class="language-text">              a_ABC  b_ABC  c_ABC
beijing_ABC       0      1      2
shanghai_ABC      3      4      5
xiamen_ABC        6      7      8
</code></pre>

<pre><code class="language-python"># 同时，renme可以传入字典，为某个index单独修改名称

df2=df1.rename(index={&#39;beijing&#39;:&#39;bi&#39;},columns={&#39;a&#39;:&#39;aa&#39;})
print(df2)

</code></pre>

<pre><code class="language-text">          aa  b  c
bi         0  1  2
shanghai   3  4  5
xiamen     6  7  8
</code></pre>

<pre><code class="language-python"># 列转化为索引
df3=pd.DataFrame({&#39;X&#39;:range(5),&#39;Y&#39;:range(5),&#39;S&#39;:[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;],&#39;Z&#39;:[1,1,2,2,2]}) 
print(df3)
print(&#39;-&#39;*30)

# 指定一列为索引 (drop=False 指定同时保留作为索引的列) 
result = df3.set_index(&#39;S&#39;,drop=False) 
result.index.name=None
print(result)


</code></pre>

<pre><code class="language-text">   X  Y  S  Z
0  0  0  a  1
1  1  1  b  1
2  2  2  c  2
3  3  3  d  2
4  4  4  e  2
------------------------------
   X  Y  S  Z
a  0  0  a  1
b  1  1  b  1
c  2  2  c  2
d  3  3  d  2
e  4  4  e  2
</code></pre>

<h3 id="toc_13">添加数据</h3>

<pre><code class="language-python"># 增加数据
df1 = pd.DataFrame([[&#39;Snow&#39;,&#39;M&#39;,22],[&#39;Tyrion&#39;,&#39;M&#39;,32],[&#39;Sansa&#39;,&#39;F&#39;,18],[&#39;Arya&#39;,&#39;F&#39;,14]], columns=[&#39;name&#39;,&#39;gender&#39;,&#39;age&#39;])
print(df1)

</code></pre>

<pre><code class="language-text">     name gender  age
0    Snow      M   22
1  Tyrion      M   32
2   Sansa      F   18
3    Arya      F   14
</code></pre>

<pre><code class="language-python">#在数据框最后加上score
df1[&#39;score&#39;]=[80,90,67,78]#与增加数据一样
print(df1)

</code></pre>

<pre><code class="language-text">     name gender  age  score
0    Snow      M   22     80
1  Tyrion      M   32     90
2   Sansa      F   18     67
3    Arya      F   14     78
</code></pre>

<p>在具体某个位置插入一列可以用<strong>insert</strong>的方法</p>

<ul>
<li>语法格式：列表.insert(index, obj)
<ul>
<li>index ---&gt;对象 obj 需要插入的索引位置。</li>
<li>obj ---&gt; 要插入列表中的对象（列名）</li>
</ul></li>
</ul>

<pre><code class="language-python">col_name=df1.columns.tolist()#将数据框中列明全部提取出存在列表里
col_name.insert(2,&#39;city&#39;) #在列索引为2的位置后面插入列名为city的列
#没有值，所有列为NaN
df1=df1.reindex(columns=col_name)# DataFrame.reindex() 对原行/列索引重新构建索引值
print(df1)

</code></pre>

<pre><code class="language-text">     name gender  city  age  score
0    Snow      M   NaN   22     80
1  Tyrion      M   NaN   32     90
2   Sansa      F   NaN   18     67
3    Arya      F   NaN   14     78
</code></pre>

<pre><code class="language-python">df1[&#39;city&#39;]=[&#39;北京&#39;,&#39;上海&#39;,&#39;广东&#39;,&#39;厦门&#39;]
print(df1)

</code></pre>

<pre><code class="language-text">     name gender city  age  score
0    Snow      M   北京   22     80
1  Tyrion      M   上海   32     90
2   Sansa      F   广东   18     67
3    Arya      F   厦门   14     78
</code></pre>

<h4 id="toc_14">df中的insert,插入一列</h4>

<p>df.insert(iloc,column,value)</p>

<ul>
<li>iloc:要插入的位置</li>
<li>colunm:列名</li>
<li>value:值</li>
</ul>

<pre><code class="language-python">df1.insert(2,&#39;score2&#39;,[79,43,67,89])
print(df1)

</code></pre>

<pre><code class="language-text">     name gender  score2 city  age  score
0    Snow      M      79   北京   22     80
1  Tyrion      M      43   上海   32     90
2   Sansa      F      67   广东   18     67
3    Arya      F      89   厦门   14     78
</code></pre>

<pre><code class="language-python"># 插入行
row=[&#39;Ryan&#39;,&#39;M&#39;,&#39;100&#39;,&#39;厦门&#39;,&#39;18&#39;,&#39;100&#39;]
df1.loc[3]=row
print(df1)

</code></pre>

<pre><code class="language-text">     name gender score2 city age score
0    Snow      M     79   北京  22    80
1  Tyrion      M     43   上海  32    90
2   Sansa      F     67   广东  18    67
3    Ryan      M    100   厦门  18   100
</code></pre>

<pre><code class="language-python"># 增加数据
df1 = pd.DataFrame([[&#39;Snow&#39;,&#39;M&#39;,22],
                    [&#39;Tyrion&#39;,&#39;M&#39;,32],
                    [&#39;Sansa&#39;,&#39;F&#39;,18],
                    [&#39;Arya&#39;,&#39;F&#39;,14]], 
                   columns=[&#39;name&#39;,&#39;gender&#39;,&#39;age&#39;])
print(df1)

# 先创建一个DataFrame，用来增加进数据框的最后一行
new=pd.DataFrame({&#39;name&#39;:&#39;lisa&#39;,
                  &#39;gender&#39;:&#39;F&#39;, &#39;age&#39;:19},
                 index=[0])
print(&#39;-&#39;*30)
print(new)
print(&#39;-&#39;*30)
df1=df1.append(new,ignore_index=True)   # ignore_index=False,表示不按原来的索引，从0开始自动递增
print(df1)


</code></pre>

<pre><code class="language-text">     name gender  age
0    Snow      M   22
1  Tyrion      M   32
2   Sansa      F   18
3    Arya      F   14
------------------------------
   name gender  age
0  lisa      F   19
------------------------------
     name gender  age
0    Snow      M   22
1  Tyrion      M   32
2   Sansa      F   18
3    Arya      F   14
4    lisa      F   19
</code></pre>

<h4 id="toc_15">插入多行多列</h4>

<ul>
<li>objs:合并对象</li>
<li>axis:合并方式，默认0表示按列合并，1表示按行合并</li>
<li>ignore_index:是否忽略索引</li>
</ul>

<pre><code class="language-python">df1 = pd.DataFrame(np.arange(6).reshape(3,2),columns=[&#39;four&#39;,&#39;five&#39;])
df2 = pd.DataFrame(np.arange(6).reshape(2,3),columns=[&#39;one&#39;,&#39;two&#39;,&#39;three&#39;]) 
print(df2)

print(&#39;-&#39;*30)

# 按行合并
result=pd.concat([df2,df1],axis=1)
print(result)

print(&#39;-&#39;*30)

# 按列合并
result=pd.concat([df2,df1],ignore_index=True,)
print(result)

</code></pre>

<pre><code class="language-text">   one  two  three
0    0    1      2
1    3    4      5
------------------------------
   one  two  three  four  five
0  0.0  1.0    2.0     0     1
1  3.0  4.0    5.0     2     3
2  NaN  NaN    NaN     4     5
------------------------------
   five  four  one  three  two
0   NaN   NaN  0.0    2.0  1.0
1   NaN   NaN  3.0    5.0  4.0
2   1.0   0.0  NaN    NaN  NaN
3   3.0   2.0  NaN    NaN  NaN
4   5.0   4.0  NaN    NaN  NaN



E:\anaconda\lib\site-packages\ipykernel_launcher.py:14: FutureWarning: Sorting because non-concatenation axis is not aligned. A future version
of pandas will change to not sort by default.

To accept the future behavior, pass &#39;sort=True&#39;.

To retain the current behavior and silence the warning, pass sort=False
</code></pre>

<p>​<br/><br/>
​    </p>

<h4 id="toc_16">DataFrame的删除</h4>

<ul>
<li>lables：要删除数据的标签</li>
<li>axis：0表示删除行，1表示删除列，默认0</li>
<li>inplace:是否在当前df中执行此操作</li>
</ul>

<pre><code class="language-python">df2 = pd.DataFrame(np.arange(9).reshape(3,3),columns=[&#39;one&#39;,&#39;two&#39;,&#39;three&#39;])
print(df2)
df4=df2.drop([&#39;one&#39;],axis=1, inplace=False) 
df3=df2.drop([0,1],axis=0, inplace=False) 

print(&#39;-&#39;*30)
print(df4)
print(&#39;-&#39;*30)
print(df3)


</code></pre>

<pre><code class="language-text">   one  two  three
0    0    1      2
1    3    4      5
2    6    7      8
------------------------------
   two  three
0    1      2
1    4      5
2    7      8
------------------------------
   one  two  three
2    6    7      8
</code></pre>

<h3 id="toc_17">数据处理</h3>

<h4 id="toc_18">通过<strong>dropna()</strong>滤除缺失数据：</h4>

<pre><code class="language-python">se=pd.Series([4,None,8,None,5]) 
print(se)
print(&#39;-&#39;*20)
print(se.dropna())
print(&#39;-&#39;*20)
print(se.notnull()) 
print(&#39;-&#39;*20)
print(se.isnull())


print(&#39;-&#39;*20)
# 通过布尔序列也能滤除：
print(se[se.notnull()])


</code></pre>

<pre><code class="language-text">0    4.0
1    NaN
2    8.0
3    NaN
4    5.0
dtype: float64
--------------------
0    4.0
2    8.0
4    5.0
dtype: float64
--------------------
0     True
1    False
2     True
3    False
4     True
dtype: bool
--------------------
0    False
1     True
2    False
3     True
4    False
dtype: bool
--------------------
0    4.0
2    8.0
4    5.0
dtype: float64
</code></pre>

<h4 id="toc_19">处理DataFrame对象</h4>

<pre><code class="language-python">df1=pd.DataFrame([[1,2,3],[None,None,2],[None,None,None],[8,8,None]])
print(df1)

print(&#39;-&#39;*20)
print(df1.dropna())
print(&#39;-&#39;*20)
# 传入how=‘all’滤除全为NaN的行：
print(df1.dropna(how=&#39;all&#39;)) # 默认情况下是how=&#39;any&#39;，只要有nan就删除

print(&#39;-&#39;*20)
# 传入axis=1滤除列：
print(df1.dropna(axis=1,how=&quot;any&quot;))

print(&#39;-&#39;*20)
#传入thresh=n保留至少有n个非NaN数据的行：  
print(df1.dropna(thresh=3))

</code></pre>

<pre><code class="language-text">     0    1    2
0  1.0  2.0  3.0
1  NaN  NaN  2.0
2  NaN  NaN  NaN
3  8.0  8.0  NaN
--------------------
     0    1    2
0  1.0  2.0  3.0
--------------------
     0    1    2
0  1.0  2.0  3.0
1  NaN  NaN  2.0
3  8.0  8.0  NaN
--------------------
Empty DataFrame
Columns: []
Index: [0, 1, 2, 3]
--------------------
     0    1    2
0  1.0  2.0  3.0
</code></pre>

<h4 id="toc_20">填充缺失数据</h4>

<pre><code class="language-python">df1=pd.DataFrame([[1,2,3],[None,None,2],[None,None,None],[8,8,None]])
print(df1)

</code></pre>

<pre><code class="language-text">     0    1    2
0  1.0  2.0  3.0
1  NaN  NaN  2.0
2  NaN  NaN  NaN
3  8.0  8.0  NaN
</code></pre>

<pre><code class="language-python"># 用常数填充fillna
print(df1.fillna(0))

</code></pre>

<pre><code class="language-text">     0    1    2
0  1.0  2.0  3.0
1  0.0  0.0  2.0
2  0.0  0.0  0.0
3  8.0  8.0  0.0
</code></pre>

<pre><code class="language-python">#传入inplace=True直接修改原对象： 
df1.fillna(0,inplace=True) 
print(df1)

</code></pre>

<pre><code class="language-text">     0    1    2
0  1.0  2.0  3.0
1  0.0  0.0  2.0
2  0.0  0.0  0.0
3  8.0  8.0  0.0
</code></pre>

<pre><code class="language-python">df1=pd.DataFrame([[1,2,3],[None,None,2],[None,None,None],[8,8,None]])
# 通过字典填充不同的常数
print(df1.fillna({0:10,1:20,2:30}))


</code></pre>

<pre><code class="language-text">      0     1     2
0   1.0   2.0   3.0
1  10.0  20.0   2.0
2  10.0  20.0  30.0
3   8.0   8.0  30.0
</code></pre>

<pre><code class="language-python">#填充平均值
print(df1.fillna(df1.mean()))
# 如果只填充一列
df1.iloc[:,1].fillna(5,inplace = True)
print(df1)

</code></pre>

<pre><code class="language-text">     0    1    2
0  1.0  2.0  3.0
1  4.5  5.0  2.0
2  4.5  5.0  2.5
3  8.0  8.0  2.5
     0    1    2
0  1.0  2.0  3.0
1  NaN  5.0  2.0
2  NaN  5.0  NaN
3  8.0  8.0  NaN
</code></pre>

<pre><code class="language-python"># 传 入 method=” “ 改 变 插 值 方 式 ： 
df2=pd.DataFrame(np.random.randint(0,10,(5,5))) 
df2.iloc[1:4,3]=None
df2.iloc[2:4,4]=None
print(df2)
print(&#39;-&#39;*20)

#用前面的值来填充ffill  用后面的值来填充bfill 
print(df2.fillna(method=&#39;ffill&#39;))

print(&#39;-&#39;*20)
# 传入limit=” “限制填充行数：
print(df2.fillna(method=&#39;bfill&#39;,limit=2))
print(&#39;-&#39;*20)
# 传入axis=” “修改填充方向：
print(df2.fillna(method=&quot;ffill&quot;,limit=1,axis=1))


</code></pre>

<pre><code class="language-text">   0  1  2    3    4
0  7  6  9  4.0  4.0
1  8  1  7  NaN  5.0
2  2  7  0  NaN  NaN
3  7  3  2  NaN  NaN
4  1  0  7  7.0  4.0
--------------------
   0  1  2    3    4
0  7  6  9  4.0  4.0
1  8  1  7  4.0  5.0
2  2  7  0  4.0  5.0
3  7  3  2  4.0  5.0
4  1  0  7  7.0  4.0
--------------------
   0  1  2    3    4
0  7  6  9  4.0  4.0
1  8  1  7  NaN  5.0
2  2  7  0  7.0  4.0
3  7  3  2  7.0  4.0
4  1  0  7  7.0  4.0
--------------------
     0    1    2    3    4
0  7.0  6.0  9.0  4.0  4.0
1  8.0  1.0  7.0  7.0  5.0
2  2.0  7.0  0.0  0.0  NaN
3  7.0  3.0  2.0  2.0  NaN
4  1.0  0.0  7.0  7.0  4.0
</code></pre>

<h4 id="toc_21">移除重复数据</h4>

<p>DataFrame中经常会出现重复行，利用duplicated()函数返回每一行判断是否重复的结果（重复则为True) </p>

<pre><code class="language-python">df1=pd.DataFrame({&#39;A&#39;:[1,1,1,2,2,3,1],&#39;B&#39;:list(&quot;aabbbca&quot;)}) 
print(df1)
print(&#39;-&#39;*30)
# 判断每一行是否重复(结果是bool值，TRUE代表重复的) 
print(df1.duplicated())

print(&#39;-&#39;*30)
# 去除全部的重复行
print(df1.drop_duplicates())

print(&#39;-&#39;*30)
#  指定列去除重复行
print(df1.drop_duplicates([&#39;A&#39;]))


print(&#39;-&#39;*30)
# 保留重复行中的最后一行
print(df1.drop_duplicates([&#39;A&#39;],keep=&#39;last&#39;))

print(&#39;-&#39;*30)
#去除重复的同时改变DataFrame对象
df1.drop_duplicates([&#39;A&#39;,&#39;B&#39;],inplace=True) 
print(df1)

</code></pre>

<pre><code class="language-text">   A  B
0  1  a
1  1  a
2  1  b
3  2  b
4  2  b
5  3  c
6  1  a
------------------------------
0    False
1     True
2    False
3    False
4     True
5    False
6     True
dtype: bool
------------------------------
   A  B
0  1  a
2  1  b
3  2  b
5  3  c
------------------------------
   A  B
0  1  a
3  2  b
5  3  c
------------------------------
   A  B
4  2  b
5  3  c
6  1  a
------------------------------
   A  B
0  1  a
2  1  b
3  2  b
5  3  c
</code></pre>

<h3 id="toc_22">数据合并</h3>

<h4 id="toc_23">join合并</h4>

<p>着重关注行的合并</p>

<pre><code class="language-python">import pandas as pd
df3=pd.DataFrame({&#39;Red&#39;:[1,3,5],&#39;Green&#39;:[5,0,3]},index=list(&#39;abc&#39;))
df4=pd.DataFrame({&#39;Blue&#39;:[1,9,8],&#39;Yellow&#39;:[6,6,7]},index=list(&#39;cde&#39;)) 
print(df3)
print(&#39;-&#39;*30)
print(df4)

# 简单合并（默认是left左连接,以左侧df3为基础）
df3.join(df4,how=&#39;left&#39;)
print(&#39;-&#39;*30)
print(df3)

# 右链接
df3.join(df4,how=&#39;right&#39;)

# 外链接
df3.join(df4,how=&#39;outer&#39;)



</code></pre>

<pre><code class="language-text">   Red  Green
a    1      5
b    3      0
c    5      3
------------------------------
   Blue  Yellow
c     1       6
d     9       6
e     8       7
------------------------------
   Red  Green
a    1      5
b    3      0
c    5      3
</code></pre>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code class="language-text">.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre>
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Red</th>
      <th>Green</th>
      <th>Blue</th>
      <th>Yellow</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>1.0</td>
      <td>5.0</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>b</th>
      <td>3.0</td>
      <td>0.0</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>c</th>
      <td>5.0</td>
      <td>3.0</td>
      <td>1.0</td>
      <td>6.0</td>
    </tr>
    <tr>
      <th>d</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>9.0</td>
      <td>6.0</td>
    </tr>
    <tr>
      <th>e</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>8.0</td>
      <td>7.0</td>
    </tr>
  </tbody>
</table>
</div>

<pre><code class="language-python"># 合并多个DataFrame对象
df5=pd.DataFrame({&#39;Brown&#39;:[3,4,5],&#39;White&#39;:[1,1,2]},index=list(&#39;aed&#39;)) 

df3.join([df4,df5])


</code></pre>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code class="language-text">.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre>
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Red</th>
      <th>Green</th>
      <th>Blue</th>
      <th>Yellow</th>
      <th>Brown</th>
      <th>White</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>1</td>
      <td>5</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>3.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>b</th>
      <td>3</td>
      <td>0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>c</th>
      <td>5</td>
      <td>3</td>
      <td>1.0</td>
      <td>6.0</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>

<h4 id="toc_24">merge合并</h4>

<p>着重关注的是列的合并</p>

<pre><code class="language-python">df1=pd.DataFrame({&#39;名字&#39;:list(&#39;ABCDE&#39;),&#39;性别&#39;:[&#39;男&#39;,&#39;女&#39;,&#39;男&#39;,&#39;男&#39;,&#39;女&#39;],&#39;职称&#39;:[&#39;副教授&#39;,&#39;讲     师&#39;,&#39;助教&#39;,&#39;教授&#39;,&#39;助教&#39;]},
                 index=range(1001,1006))
df1.columns.name=&#39;学院老师&#39;
df1.index.name=&#39;编号&#39;
print(df1)

print(&#39;-&#39;*20)
df2=pd.DataFrame({&#39;名字&#39;:list(&#39;ABDAX&#39;),&#39;课程&#39;:[&#39;C++&#39;,&#39;计算机导论&#39;,&#39;汇编&#39;,&#39;数据结构&#39;,&#39;马克思原理&#39;],&#39;职称&#39;:[&#39;副教授&#39;,&#39;讲师&#39;,&#39;教授&#39;,&#39;副教授&#39;,&#39;讲师&#39;]},index=[1001,1002,1004,1001,3001])
df2.columns.name=&#39;课程&#39;
df2.index.name=&#39;编号&#39;
print(df2)

</code></pre>

<pre><code class="language-text">学院老师 名字 性别       职称
编号                 
1001  A  男      副教授
1002  B  女  讲     师
1003  C  男       助教
1004  D  男       教授
1005  E  女       助教
--------------------
课程   名字     课程   职称
编号                 
1001  A    C++  副教授
1002  B  计算机导论   讲师
1004  D     汇编   教授
1001  A   数据结构  副教授
3001  X  马克思原理   讲师
</code></pre>

<pre><code class="language-python"># 默认下是根据左右对象中出现同名的列作为连接的键，且连接方式是how=’inner’ 
print(pd.merge(df1,df2))# 返回匹配的

# 指定列名合并
pd.merge(df1,df2,on=&#39;名字&#39;,suffixes=[&#39;_1&#39;,&#39;_2&#39;])# 返回匹配的

# 连接方式，根据左侧为准
pd.merge(df1,df2,how=&#39;left&#39;)

# 根据左侧为准
pd.merge(df1,df2,how=&#39;right&#39;)

# 所 有
# pd.merge(df1,df2,how=&#39;outer&#39;)

# 根据多个键进行连接
pd.merge(df1,df2,on=[&#39;职称&#39;,&#39;名字&#39;])


</code></pre>

<pre><code class="language-text">  名字 性别   职称    课程
0  A  男  副教授   C++
1  A  男  副教授  数据结构
2  D  男   教授    汇编
</code></pre>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code class="language-text">.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre>
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>名字</th>
      <th>性别</th>
      <th>职称</th>
      <th>课程</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>A</td>
      <td>男</td>
      <td>副教授</td>
      <td>C++</td>
    </tr>
    <tr>
      <th>1</th>
      <td>A</td>
      <td>男</td>
      <td>副教授</td>
      <td>数据结构</td>
    </tr>
    <tr>
      <th>2</th>
      <td>D</td>
      <td>男</td>
      <td>教授</td>
      <td>汇编</td>
    </tr>
  </tbody>
</table>
</div>

<h3 id="toc_25">拓展——轴向连接（Concat）</h3>

<ol>
<li> Series对象的连接</li>
</ol>

<pre><code class="language-python">s1=pd.Series([1,2],index=list(&#39;ab&#39;))
s2=pd.Series([3,4,5],index=list(&#39;bde&#39;)) 
print(s1)
print(s2)
print(pd.concat([s1,s2]))

#横向连接
print(pd.concat([s1,s2],axis=1))

# 用内连接求交集(连接方式，共有’inner’,’left’,right’,’outer’) 
pd.concat([s1,s2],axis=1,join=&#39;inner&#39;)

# 指定部分索引进行连接
pd.concat([s1,s2],axis=1,join_axes=[list(&#39;abc&#39;)])

# 创建层次化索引
pd.concat([s1,s2],keys=[&#39;A&#39;,&#39;B&#39;])

#当纵向连接时keys为列名
pd.concat([s1,s2],keys=[&#39;A&#39;,&#39;D&#39;],axis=1)


</code></pre>

<pre><code class="language-text">a    1
b    2
dtype: int64
b    3
d    4
e    5
dtype: int64
a    1
b    2
b    3
d    4
e    5
dtype: int64
     0    1
a  1.0  NaN
b  2.0  3.0
d  NaN  4.0
e  NaN  5.0



E:\anaconda\lib\site-packages\ipykernel_launcher.py:8: FutureWarning: Sorting because non-concatenation axis is not aligned. A future version
of pandas will change to not sort by default.

To accept the future behavior, pass &#39;sort=True&#39;.

To retain the current behavior and silence the warning, pass sort=False
</code></pre>

<p>​<br/><br/>
​    E:\anaconda\lib\site-packages\ipykernel_launcher.py:20: FutureWarning: Sorting because non-concatenation axis is not aligned. A future version<br/>
​    of pandas will change to not sort by default.<br/>
​<br/><br/>
​    To accept the future behavior, pass &#39;sort=True&#39;.<br/>
​    </p>

<pre><code class="language-text">To retain the current behavior and silence the warning, pass sort=False
</code></pre>

<p>​    </p>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code class="language-text">.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre>
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>D</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>1.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>b</th>
      <td>2.0</td>
      <td>3.0</td>
    </tr>
    <tr>
      <th>d</th>
      <td>NaN</td>
      <td>4.0</td>
    </tr>
    <tr>
      <th>e</th>
      <td>NaN</td>
      <td>5.0</td>
    </tr>
  </tbody>
</table>
</div>

<ol>
<li>DataFrame对象的连接</li>
</ol>

<pre><code class="language-python">df3=pd.DataFrame({&#39;Red&#39;:[1,3,5],&#39;Green&#39;:[5,0,3]},index=list(&#39;abd&#39;))
df4=pd.DataFrame({&#39;Blue&#39;:[1,9],&#39;Yellow&#39;:[6,6]},index=list(&#39;ce&#39;)) 
print(df3)
print(df4)
pd.concat([df3,df4]) 
pd.concat([df3,df4],axis=1,keys=[&#39;A&#39;,&#39;B&#39;])

# 用字典的方式连接同样可以创建层次化列索引
pd.concat({&#39;A&#39;:df3,&#39;B&#39;:df4},axis=1)


</code></pre>

<pre><code class="language-text">   Red  Green
a    1      5
b    3      0
d    5      3
   Blue  Yellow
c     1       6
e     9       6



E:\anaconda\lib\site-packages\ipykernel_launcher.py:5: FutureWarning: Sorting because non-concatenation axis is not aligned. A future version
of pandas will change to not sort by default.

To accept the future behavior, pass &#39;sort=True&#39;.

To retain the current behavior and silence the warning, pass sort=False

  &quot;&quot;&quot;
E:\anaconda\lib\site-packages\ipykernel_launcher.py:6: FutureWarning: Sorting because non-concatenation axis is not aligned. A future version
of pandas will change to not sort by default.

To accept the future behavior, pass &#39;sort=True&#39;.

To retain the current behavior and silence the warning, pass sort=False
</code></pre>

<p>​<br/><br/>
​    E:\anaconda\lib\site-packages\ipykernel_launcher.py:9: FutureWarning: Sorting because non-concatenation axis is not aligned. A future version<br/>
​    of pandas will change to not sort by default.<br/>
​<br/><br/>
​    To accept the future behavior, pass &#39;sort=True&#39;.<br/>
​    </p>

<pre><code class="language-text">To retain the current behavior and silence the warning, pass sort=False

  if __name__ == &#39;__main__&#39;:
</code></pre>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code class="language-text">.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead tr th {
    text-align: left;
}
</code></pre>
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th colspan="2" halign="left">A</th>
      <th colspan="2" halign="left">B</th>
    </tr>
    <tr>
      <th></th>
      <th>Red</th>
      <th>Green</th>
      <th>Blue</th>
      <th>Yellow</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>1.0</td>
      <td>5.0</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>b</th>
      <td>3.0</td>
      <td>0.0</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>c</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>1.0</td>
      <td>6.0</td>
    </tr>
    <tr>
      <th>d</th>
      <td>5.0</td>
      <td>3.0</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>e</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>9.0</td>
      <td>6.0</td>
    </tr>
  </tbody>
</table>
</div>

<h3 id="toc_26">多层索引（拓展）</h3>

<h4 id="toc_27">创建多层索引</h4>

<pre><code class="language-python">import numpy as np 
import pandas as pd
from pandas import Series,DataFrame

# Series也可以创建多层索引
s = Series(np.random.randint(0,150,size=6),index=list(&#39;abcdef&#39;)) 
print(s)
print(&#39;-&#39;*20)
s = Series(np.random.randint(0,150,size=6),
           index=[[&#39;a&#39;,&#39;a&#39;,&#39;b&#39;,&#39;b&#39;,&#39;c&#39;,&#39;c&#39;],[&#39;期中&#39;,&#39;期末&#39;,&#39;期中&#39;,&#39;期末&#39;,&#39;期中&#39;,&#39;期末&#39;]])  
print(s)

</code></pre>

<pre><code class="language-text">a    146
b    137
c     39
d     16
e    142
f    142
dtype: int32
--------------------
a  期中     43
   期末     53
b  期中     71
   期末    114
c  期中    149
   期末     13
dtype: int32
</code></pre>

<pre><code class="language-python">#DataFrame创建多层索引
df1 = DataFrame(np.random.randint(0,150,size=(6,4)),columns = [&#39;zs&#39;,&#39;ls&#39;,&#39;ww&#39;,&#39;zl&#39;],
                index = [[&#39;python&#39;,&#39;python&#39;,&#39;math&#39;,&#39;math&#39;,&#39;En&#39;,&#39;En&#39;],[&#39;期中&#39;,&#39;期末&#39;,&#39;期中&#39;,&#39;期末&#39;,&#39;期中&#39;,&#39;期末&#39;]])

print(df1)


</code></pre>

<pre><code class="language-text">            zs   ls   ww   zl
python 期中    7  131  141   55
       期末   77   52   85   69
math   期中  139  118   80    3
       期末   23    5   14   27
En     期中  142   47   28  136
       期末   19   95   33   55
</code></pre>

<h5 id="toc_28">特定结构</h5>

<pre><code class="language-python">class1=[&#39;python&#39;,&#39;python&#39;,&#39;math&#39;,&#39;math&#39;,&#39;En&#39;,&#39;En&#39;]
class2=[&#39;期中&#39;,&#39;期末&#39;,&#39;期中&#39;,&#39;期末&#39;,&#39;期中&#39;,&#39;期末&#39;]
m_index2=pd.MultiIndex.from_arrays([class1,class2])
df2=DataFrame(np.random.randint(0,150,(6,4)),index=m_index2) 
print(df2)

print(&#39;-&#39;*20)

class1=[&#39;期中&#39;,&#39;期中&#39;,&#39;期中&#39;,&#39;期末&#39;,&#39;期末&#39;,&#39;期末&#39;]
class2=[&#39;python&#39;,&#39;math&#39;,&#39;En&#39;,&#39;python&#39;,&#39;math&#39;,&#39;En&#39;] 
m_index2=pd.MultiIndex.from_arrays([class1,class2])
df2=DataFrame(np.random.randint(0,150,(6,4)),index=m_index2) 
print(df2)


</code></pre>

<pre><code class="language-text">             0    1    2    3
python 期中   13   13  108   94
       期末  117  130   87   74
math   期中   35  111   80   94
       期末  144   94  111    0
En     期中  135   80   87   90
       期末  108   63  119  118
--------------------
             0    1    2    3
期中 python   22   36   66   41
   math    142    5  139   73
   En       62  130  120  140
期末 python  144    5   60  128
   math     18   41   14   37
   En       74   62   10   83
</code></pre>

<h5 id="toc_29">product构造</h5>

<pre><code class="language-python">class1=[&#39;python&#39;,&#39;math&#39;,&#39;En&#39;]
class2=[&#39;期中&#39;,&#39;期末&#39;]
m_index2=pd.MultiIndex.from_product([class1,class2]) 
df2=DataFrame(np.random.randint(0,150,(6,4)),index=m_index2) 
print(df2)


</code></pre>

<pre><code class="language-text">             0    1    2    3
python 期中   23   98  144  114
       期末  122   80  115   13
math   期中   79   80   43   65
       期末   99  132  103    2
En     期中    1   81   27   72
       期末   50  113   28  116
</code></pre>

<h4 id="toc_30">多层索引对象的索引</h4>

<pre><code class="language-python">#多层索引对象的索引操作# series
s = Series(np.random.randint(0,150,size=6),index=[[&#39;a&#39;,&#39;a&#39;,&#39;b&#39;,&#39;b&#39;,&#39;c&#39;,&#39;c&#39;],[&#39;期中&#39;,&#39;期末&#39;,&#39;期中&#39;,&#39;期末&#39;,&#39;期中&#39;,&#39;期末&#39;]])  # print(s)
#取一个第一级索引
print(s[&#39;a&#39;])

# 取多个第一级索引
print(s[[&#39;a&#39;,&#39;b&#39;]])

# 根据索引获取值
print(s[&#39;a&#39;,&#39;期末&#39;])

# loc方法取值
print(s.loc[&#39;a&#39;])
print(s.loc[[&#39;a&#39;,&#39;b&#39;]])
print(s.loc[&#39;a&#39;,&#39;期末&#39;])

# iloc方法取值(iloc计算的事最内层索引)  
print(s.iloc[1])


print(s.iloc[1:4])

# dataframe 
class1=[&#39;python&#39;,&#39;math&#39;,&#39;En&#39;]
class2=[&#39; 期 中 &#39;,&#39; 期 末 &#39;] 
m_index2=pd.MultiIndex.from_product([class1,class2]) 
df2=DataFrame(np.random.randint(0,150,(6,4)),index=m_index2) 
print(df2)

# 获取列
print(df2[0])

# 一级索引
print(df2.loc[&#39;python&#39;])

# 多个一级索引
print(df2.loc[[&#39;python&#39;,&#39;math&#39;]])

# 取一行
# print(df2.loc[&#39;python&#39;,&#39;期末&#39;])

# 取一值
# print(df2.loc[&#39;python&#39;,&#39;期末&#39;][0])

# iloc是只取最内层的索引的
print(df2.iloc[0])

</code></pre>

<pre><code class="language-text">期中    110
期末    123
dtype: int32
a  期中    110
   期末    123
b  期中     93
   期末      2
dtype: int32
123
期中    110
期末    123
dtype: int32
a  期中    110
   期末    123
b  期中     93
   期末      2
dtype: int32
123
123
a  期末    123
b  期中     93
   期末      2
dtype: int32
                0    1    2    3
python  期 中   123   28  120   69
        期 末     4  146   50   32
math    期 中   142   65   56   81
        期 末    74   59   17   80
En      期 中   133   17   89  113
        期 末    18   35   60  106
python   期 中     123
         期 末       4
math     期 中     142
         期 末      74
En       期 中     133
         期 末      18
Name: 0, dtype: int32
         0    1    2   3
 期 中   123   28  120  69
 期 末     4  146   50  32
                0    1    2   3
python  期 中   123   28  120  69
        期 末     4  146   50  32
math    期 中   142   65   56  81
        期 末    74   59   17  80
0    123
1     28
2    120
3     69
Name: (python,  期 中 ), dtype: int32
</code></pre>

<h2 id="toc_31">Timestamp</h2>

<h3 id="toc_32">时间模块datetime</h3>

<h4 id="toc_33">datetime.date (date对象)</h4>

<pre><code class="language-python">import datetime
# 或者from datetime import date
today=datetime.date.today()#今天的时间
print(today,type(today))
print(str(today),type(str(today)))
#输出date类的格式

print(&#39;-&#39;*30)
t=datetime.date(1997,10,26)
print(t)
#（年，月，日）

</code></pre>

<pre><code class="language-text">2019-11-29 &lt;class &#39;datetime.date&#39;&gt;
2019-11-29 &lt;class &#39;str&#39;&gt;
------------------------------
1997-10-26
</code></pre>

<h4 id="toc_34">datetime.date(datetime对象)</h4>

<pre><code class="language-python">now=datetime.datetime.now()
print(now,type(now))
print(str(now),type(str(now))) 

t1 = datetime.datetime(2016,6,1)
t2 = datetime.datetime(2014,1,1,12,44,33)
print(t1,t2)
# (年，月，日，时，分，秒)，至少输入年月日

t2-t1
# 相减得到时间差 —— timedelta

</code></pre>

<pre><code class="language-text">2019-11-29 14:47:16.940429 &lt;class &#39;datetime.datetime&#39;&gt;
2019-11-29 14:47:16.940429 &lt;class &#39;str&#39;&gt;
2016-06-01 00:00:00 2014-01-01 12:44:33






datetime.timedelta(-882, 45873)
</code></pre>

<h4 id="toc_35">datetime.timedelta(时间差)</h4>

<pre><code class="language-python">today = datetime.datetime.today()  # datetime.datetime也有today()方法
yestoday = today - datetime.timedelta(1)  # 
print(today)
print(yestoday)
print(today - datetime.timedelta(7))
# 时间差主要用作时间的加减法，相当于可被识别的时间“差值”

</code></pre>

<pre><code class="language-text">2019-11-29 14:48:03.943359
2019-11-28 14:48:03.943359
2019-11-22 14:48:03.943359
</code></pre>

<h4 id="toc_36">parser.parse(日期字符串转换)</h4>

<pre><code class="language-python">from dateutil.parser import parse

date = &#39;12-21-2017&#39;
t = parse(date)
print(t,type(t))
# 直接将str转化成datetime.datetime

print(parse(&#39;2000-1-1&#39;),&#39;\n&#39;,
     parse(&#39;5/1/2014&#39;),&#39;\n&#39;,
     parse(&#39;5/1/2014&#39;, dayfirst = True),&#39;\n&#39;,  # 国际通用格式中，日在月之前，可以通过dayfirst来设置
     parse(&#39;22/1/2014&#39;),&#39;\n&#39;,
     parse(&#39;Jan 31, 1997 10:45 PM&#39;))
# 各种格式可以解析，但无法支持中文

</code></pre>

<pre><code class="language-text">2017-12-21 00:00:00 &lt;class &#39;datetime.datetime&#39;&gt;
2000-01-01 00:00:00 
 2014-05-01 00:00:00 
 2014-01-05 00:00:00 
 2014-01-22 00:00:00 
 1997-01-31 22:45:00
</code></pre>

<h3 id="toc_37">Timestamp(Pandas时刻数据)</h3>

<p>时刻数据代表时间点，是pandas的数据类型，是将值与时间点相关联的最基本类型的时间序列数据。<strong>pandas.Timestamp()</strong></p>

<h4 id="toc_38">pd.Timestamp()</h4>

<pre><code class="language-python">import numpy as np
import pandas as pd

date1 = datetime.datetime(2016,12,1,12,45,30)  # 创建一个datetime.datetime
date2 = &#39;2017-12-21&#39;  # 创建一个字符串
t1 = pd.Timestamp(date1)
t2 = pd.Timestamp(date2)
print(t1,type(t1))
print(t2)
print(pd.Timestamp(&#39;2017-12-21 15:00:22&#39;))
# 直接生成pandas的时刻数据 → 时间戳
# 数据类型为 pandas的Timestamp

</code></pre>

<pre><code class="language-text">2016-12-01 12:45:30 &lt;class &#39;pandas._libs.tslibs.timestamps.Timestamp&#39;&gt;
2017-12-21 00:00:00
2017-12-21 15:00:22
</code></pre>

<h4 id="toc_39">pd.to_datetime（转化为时间戳）</h4>

<pre><code class="language-python">from datetime import datetime

date1 = datetime(2016,12,1,12,45,30)
date2 = &#39;2017-12-21&#39;
t1 = pd.to_datetime(date1)
t2 = pd.to_datetime(date2)
print(t1,type(t1))
print(t2,type(t2))
# pd.to_datetime()：如果是单个时间数据，转换成pandas的时刻数据，数据类型为Timestamp

lst_date = [ &#39;2017-12-21&#39;, &#39;2017-12-22&#39;, &#39;2017-12-23&#39;]
t3 = pd.to_datetime(lst_date)
print(t3,type(t3))
# 多个时间数据，将会转换为pandas的DatetimeIndex

</code></pre>

<pre><code class="language-text">2016-12-01 12:45:30 &lt;class &#39;pandas._libs.tslibs.timestamps.Timestamp&#39;&gt;
2017-12-21 00:00:00 &lt;class &#39;pandas._libs.tslibs.timestamps.Timestamp&#39;&gt;
DatetimeIndex([&#39;2017-12-21&#39;, &#39;2017-12-22&#39;, &#39;2017-12-23&#39;], dtype=&#39;datetime64[ns]&#39;, freq=None) &lt;class &#39;pandas.core.indexes.datetimes.DatetimeIndex&#39;&gt;
</code></pre>

<ul>
<li>多个时间数据转换时间戳索引</li>
</ul>

<pre><code class="language-python">date1 = [datetime(2015,6,1),datetime(2015,7,1),datetime(2015,8,1),datetime(2015,9,1),datetime(2015,10,1)]
date2 = [&#39;2017-2-1&#39;,&#39;2017-2-2&#39;,&#39;2017-2-3&#39;,&#39;2017-2-4&#39;,&#39;2017-2-5&#39;,&#39;2017-2-6&#39;]
print(date1)
print(date2)
t1 = pd.to_datetime(date2)
t2 = pd.to_datetime(date2)
print(t1)
print(t2)
# 多个时间数据转换为 DatetimeIndex

date3 = [&#39;2017-2-1&#39;,&#39;2017-2-2&#39;,&#39;2017-2-3&#39;,&#39;hello world!&#39;,&#39;2017-2-5&#39;,&#39;2017-2-6&#39;]
t3 = pd.to_datetime(date3, errors = &#39;ignore&#39;)
print(t3,type(t3))
# 当一组时间序列中夹杂其他格式数据，可用errors参数返回
# errors = &#39;ignore&#39;:不可解析时返回原始输入，这里就是直接生成一般数组

t4 = pd.to_datetime(date3, errors = &#39;coerce&#39;)
print(t4,type(t4))
# errors = &#39;coerce&#39;:不可扩展，缺失值返回NaT（Not a Time），结果认为DatetimeIndex

</code></pre>

<pre><code class="language-text">[datetime.datetime(2015, 6, 1, 0, 0), datetime.datetime(2015, 7, 1, 0, 0), datetime.datetime(2015, 8, 1, 0, 0), datetime.datetime(2015, 9, 1, 0, 0), datetime.datetime(2015, 10, 1, 0, 0)]
[&#39;2017-2-1&#39;, &#39;2017-2-2&#39;, &#39;2017-2-3&#39;, &#39;2017-2-4&#39;, &#39;2017-2-5&#39;, &#39;2017-2-6&#39;]
DatetimeIndex([&#39;2017-02-01&#39;, &#39;2017-02-02&#39;, &#39;2017-02-03&#39;, &#39;2017-02-04&#39;,
               &#39;2017-02-05&#39;, &#39;2017-02-06&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=None)
DatetimeIndex([&#39;2017-02-01&#39;, &#39;2017-02-02&#39;, &#39;2017-02-03&#39;, &#39;2017-02-04&#39;,
               &#39;2017-02-05&#39;, &#39;2017-02-06&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=None)
[&#39;2017-2-1&#39; &#39;2017-2-2&#39; &#39;2017-2-3&#39; &#39;hello world!&#39; &#39;2017-2-5&#39; &#39;2017-2-6&#39;] &lt;class &#39;numpy.ndarray&#39;&gt;
DatetimeIndex([&#39;2017-02-01&#39;, &#39;2017-02-02&#39;, &#39;2017-02-03&#39;, &#39;NaT&#39;, &#39;2017-02-05&#39;,
               &#39;2017-02-06&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=None) &lt;class &#39;pandas.core.indexes.datetimes.DatetimeIndex&#39;&gt;
</code></pre>

<h3 id="toc_40">DatetimeIndex(Pandas时间戳索引)</h3>

<h4 id="toc_41">pd.DatetimeIndex()与TimeSeries时间序列</h4>

<pre><code class="language-python">rng = pd.DatetimeIndex([&#39;12/1/2017&#39;,&#39;12/2/2017&#39;,&#39;12/3/2017&#39;,&#39;12/4/2017&#39;,&#39;12/5/2017&#39;])
print(rng,type(rng))
print(rng[0],type(rng[0]))
# 直接生成时间戳索引，支持str、datetime.datetime
# 单个时间戳为Timestamp，多个时间戳为DatetimeIndex

st = pd.Series(np.random.rand(len(rng)), index = rng)
print(st,type(st))
print(st.index)
# 以DatetimeIndex为index的Series，为TimeSries，时间序列

</code></pre>

<pre><code class="language-text">DatetimeIndex([&#39;2017-12-01&#39;, &#39;2017-12-02&#39;, &#39;2017-12-03&#39;, &#39;2017-12-04&#39;,
               &#39;2017-12-05&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=None) &lt;class &#39;pandas.core.indexes.datetimes.DatetimeIndex&#39;&gt;
2017-12-01 00:00:00 &lt;class &#39;pandas._libs.tslibs.timestamps.Timestamp&#39;&gt;
2017-12-01    0.322258
2017-12-02    0.677879
2017-12-03    0.142017
2017-12-04    0.366208
2017-12-05    0.139923
dtype: float64 &lt;class &#39;pandas.core.series.Series&#39;&gt;
DatetimeIndex([&#39;2017-12-01&#39;, &#39;2017-12-02&#39;, &#39;2017-12-03&#39;, &#39;2017-12-04&#39;,
               &#39;2017-12-05&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=None)
</code></pre>

<h4 id="toc_42">pd.date_range()-日期范围</h4>

<p>生成日期范围</p>

<p>生成方法：</p>

<ul>
<li>start+end</li>
<li>star/end+periods</li>
</ul>

<p>默认频率：day</p>

<pre><code class="language-python">rng1 = pd.date_range(&#39;1/1/2017&#39;,&#39;1/10/2017&#39;, normalize=True)
rng2 = pd.date_range(start = &#39;1/1/2017&#39;, periods = 10)
rng3 = pd.date_range(end = &#39;1/30/2017 15:00:00&#39;, periods = 10)  # 增加了时、分、秒
print(rng1,type(rng1))
print(rng2)
print(rng3)
print(&#39;-------&#39;)
# 直接生成DatetimeIndex
# pd.date_range(start=None, end=None, periods=None, freq=&#39;D&#39;, tz=None, normalize=False, name=None, closed=None, **kwargs)
# start：开始时间
# end：结束时间
# periods：偏移量
# freq：频率，默认天，pd.date_range()默认频率为日历日，pd.bdate_range()默认频率为工作日
# tz：时区

rng4 = pd.date_range(start = &#39;1/1/2017 15:30&#39;, periods = 10, name = &#39;hello world!&#39;, normalize = True)
print(rng4)
print(&#39;-------&#39;)
# normalize：时间参数值正则化到午夜时间戳（这里最后就直接变成0:00:00，并不是15:30:00）
# name：索引对象名称

print(pd.date_range(&#39;20170101&#39;,&#39;20170104&#39;))  # 20170101也可读取
print(pd.date_range(&#39;20170101&#39;,&#39;20170104&#39;,closed = &#39;right&#39;))
print(pd.date_range(&#39;20170101&#39;,&#39;20170104&#39;,closed = &#39;left&#39;))
print(&#39;-------&#39;)
# closed：默认为None的情况下，左闭右闭，left则左闭右开，right则左开右闭

print(pd.bdate_range(&#39;20170101&#39;,&#39;20170107&#39;))
# pd.bdate_range()默认频率为工作日

print(list(pd.date_range(start = &#39;1/1/2017&#39;, periods = 10)))
# 直接转化为list，元素为Timestamp

</code></pre>

<pre><code class="language-text">DatetimeIndex([&#39;2017-01-01&#39;, &#39;2017-01-02&#39;, &#39;2017-01-03&#39;, &#39;2017-01-04&#39;,
               &#39;2017-01-05&#39;, &#39;2017-01-06&#39;, &#39;2017-01-07&#39;, &#39;2017-01-08&#39;,
               &#39;2017-01-09&#39;, &#39;2017-01-10&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;) &lt;class &#39;pandas.core.indexes.datetimes.DatetimeIndex&#39;&gt;
DatetimeIndex([&#39;2017-01-01&#39;, &#39;2017-01-02&#39;, &#39;2017-01-03&#39;, &#39;2017-01-04&#39;,
               &#39;2017-01-05&#39;, &#39;2017-01-06&#39;, &#39;2017-01-07&#39;, &#39;2017-01-08&#39;,
               &#39;2017-01-09&#39;, &#39;2017-01-10&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)
DatetimeIndex([&#39;2017-01-21 15:00:00&#39;, &#39;2017-01-22 15:00:00&#39;,
               &#39;2017-01-23 15:00:00&#39;, &#39;2017-01-24 15:00:00&#39;,
               &#39;2017-01-25 15:00:00&#39;, &#39;2017-01-26 15:00:00&#39;,
               &#39;2017-01-27 15:00:00&#39;, &#39;2017-01-28 15:00:00&#39;,
               &#39;2017-01-29 15:00:00&#39;, &#39;2017-01-30 15:00:00&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)
-------
DatetimeIndex([&#39;2017-01-01&#39;, &#39;2017-01-02&#39;, &#39;2017-01-03&#39;, &#39;2017-01-04&#39;,
               &#39;2017-01-05&#39;, &#39;2017-01-06&#39;, &#39;2017-01-07&#39;, &#39;2017-01-08&#39;,
               &#39;2017-01-09&#39;, &#39;2017-01-10&#39;],
              dtype=&#39;datetime64[ns]&#39;, name=&#39;hello world!&#39;, freq=&#39;D&#39;)
-------
DatetimeIndex([&#39;2017-01-01&#39;, &#39;2017-01-02&#39;, &#39;2017-01-03&#39;, &#39;2017-01-04&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)
DatetimeIndex([&#39;2017-01-02&#39;, &#39;2017-01-03&#39;, &#39;2017-01-04&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)
DatetimeIndex([&#39;2017-01-01&#39;, &#39;2017-01-02&#39;, &#39;2017-01-03&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)
-------
DatetimeIndex([&#39;2017-01-02&#39;, &#39;2017-01-03&#39;, &#39;2017-01-04&#39;, &#39;2017-01-05&#39;,
               &#39;2017-01-06&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=&#39;B&#39;)
[Timestamp(&#39;2017-01-01 00:00:00&#39;, freq=&#39;D&#39;), Timestamp(&#39;2017-01-02 00:00:00&#39;, freq=&#39;D&#39;), Timestamp(&#39;2017-01-03 00:00:00&#39;, freq=&#39;D&#39;), Timestamp(&#39;2017-01-04 00:00:00&#39;, freq=&#39;D&#39;), Timestamp(&#39;2017-01-05 00:00:00&#39;, freq=&#39;D&#39;), Timestamp(&#39;2017-01-06 00:00:00&#39;, freq=&#39;D&#39;), Timestamp(&#39;2017-01-07 00:00:00&#39;, freq=&#39;D&#39;), Timestamp(&#39;2017-01-08 00:00:00&#39;, freq=&#39;D&#39;), Timestamp(&#39;2017-01-09 00:00:00&#39;, freq=&#39;D&#39;), Timestamp(&#39;2017-01-10 00:00:00&#39;, freq=&#39;D&#39;)]
</code></pre>

<h4 id="toc_43">pd.date_range()-日期范围：频率(1)</h4>

<pre><code class="language-python">print(pd.date_range(&#39;2017/1/1&#39;,&#39;2017/1/4&#39;))  # 默认freq = &#39;D&#39;：每日历日
print(pd.date_range(&#39;2017/1/1&#39;,&#39;2017/1/4&#39;, freq = &#39;B&#39;))  # B：每工作日
print(pd.date_range(&#39;2017/1/1&#39;,&#39;2017/1/2&#39;, freq = &#39;H&#39;))  # H：每小时
print(pd.date_range(&#39;2017/1/1 12:00&#39;,&#39;2017/1/1 12:10&#39;, freq = &#39;T&#39;))  # T/MIN：每分
print(pd.date_range(&#39;2017/1/1 12:00:00&#39;,&#39;2017/1/1 12:00:10&#39;, freq = &#39;S&#39;))  # S：每秒
print(pd.date_range(&#39;2017/1/1 12:00:00&#39;,&#39;2017/1/1 12:00:10&#39;, freq = &#39;L&#39;))  # L：每毫秒（千分之一秒）
print(pd.date_range(&#39;2017/1/1 12:00:00&#39;,&#39;2017/1/1 12:00:10&#39;, freq = &#39;U&#39;))  # U：每微秒（百万分之一秒）

print(pd.date_range(&#39;2017/1/1&#39;,&#39;2017/2/1&#39;, freq = &#39;W-MON&#39;))  
# W-MON：从指定星期几开始算起，每周
# 星期几缩写：MON/TUE/WED/THU/FRI/SAT/SUN

print(pd.date_range(&#39;2017/1/1&#39;,&#39;2017/5/1&#39;, freq = &#39;WOM-2MON&#39;))  
# WOM-2MON：每月的第几个星期几开始算，这里是每月第二个星期一

</code></pre>

<pre><code class="language-text">DatetimeIndex([&#39;2017-01-01&#39;, &#39;2017-01-02&#39;, &#39;2017-01-03&#39;, &#39;2017-01-04&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)
DatetimeIndex([&#39;2017-01-02&#39;, &#39;2017-01-03&#39;, &#39;2017-01-04&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;B&#39;)
DatetimeIndex([&#39;2017-01-01 00:00:00&#39;, &#39;2017-01-01 01:00:00&#39;,
               &#39;2017-01-01 02:00:00&#39;, &#39;2017-01-01 03:00:00&#39;,
               &#39;2017-01-01 04:00:00&#39;, &#39;2017-01-01 05:00:00&#39;,
               &#39;2017-01-01 06:00:00&#39;, &#39;2017-01-01 07:00:00&#39;,
               &#39;2017-01-01 08:00:00&#39;, &#39;2017-01-01 09:00:00&#39;,
               &#39;2017-01-01 10:00:00&#39;, &#39;2017-01-01 11:00:00&#39;,
               &#39;2017-01-01 12:00:00&#39;, &#39;2017-01-01 13:00:00&#39;,
               &#39;2017-01-01 14:00:00&#39;, &#39;2017-01-01 15:00:00&#39;,
               &#39;2017-01-01 16:00:00&#39;, &#39;2017-01-01 17:00:00&#39;,
               &#39;2017-01-01 18:00:00&#39;, &#39;2017-01-01 19:00:00&#39;,
               &#39;2017-01-01 20:00:00&#39;, &#39;2017-01-01 21:00:00&#39;,
               &#39;2017-01-01 22:00:00&#39;, &#39;2017-01-01 23:00:00&#39;,
               &#39;2017-01-02 00:00:00&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=&#39;H&#39;)
DatetimeIndex([&#39;2017-01-01 12:00:00&#39;, &#39;2017-01-01 12:01:00&#39;,
               &#39;2017-01-01 12:02:00&#39;, &#39;2017-01-01 12:03:00&#39;,
               &#39;2017-01-01 12:04:00&#39;, &#39;2017-01-01 12:05:00&#39;,
               &#39;2017-01-01 12:06:00&#39;, &#39;2017-01-01 12:07:00&#39;,
               &#39;2017-01-01 12:08:00&#39;, &#39;2017-01-01 12:09:00&#39;,
               &#39;2017-01-01 12:10:00&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=&#39;T&#39;)
DatetimeIndex([&#39;2017-01-01 12:00:00&#39;, &#39;2017-01-01 12:00:01&#39;,
               &#39;2017-01-01 12:00:02&#39;, &#39;2017-01-01 12:00:03&#39;,
               &#39;2017-01-01 12:00:04&#39;, &#39;2017-01-01 12:00:05&#39;,
               &#39;2017-01-01 12:00:06&#39;, &#39;2017-01-01 12:00:07&#39;,
               &#39;2017-01-01 12:00:08&#39;, &#39;2017-01-01 12:00:09&#39;,
               &#39;2017-01-01 12:00:10&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=&#39;S&#39;)
DatetimeIndex([       &#39;2017-01-01 12:00:00&#39;, &#39;2017-01-01 12:00:00.001000&#39;,
               &#39;2017-01-01 12:00:00.002000&#39;, &#39;2017-01-01 12:00:00.003000&#39;,
               &#39;2017-01-01 12:00:00.004000&#39;, &#39;2017-01-01 12:00:00.005000&#39;,
               &#39;2017-01-01 12:00:00.006000&#39;, &#39;2017-01-01 12:00:00.007000&#39;,
               &#39;2017-01-01 12:00:00.008000&#39;, &#39;2017-01-01 12:00:00.009000&#39;,
               ...
               &#39;2017-01-01 12:00:09.991000&#39;, &#39;2017-01-01 12:00:09.992000&#39;,
               &#39;2017-01-01 12:00:09.993000&#39;, &#39;2017-01-01 12:00:09.994000&#39;,
               &#39;2017-01-01 12:00:09.995000&#39;, &#39;2017-01-01 12:00:09.996000&#39;,
               &#39;2017-01-01 12:00:09.997000&#39;, &#39;2017-01-01 12:00:09.998000&#39;,
               &#39;2017-01-01 12:00:09.999000&#39;,        &#39;2017-01-01 12:00:10&#39;],
              dtype=&#39;datetime64[ns]&#39;, length=10001, freq=&#39;L&#39;)
DatetimeIndex([       &#39;2017-01-01 12:00:00&#39;, &#39;2017-01-01 12:00:00.000001&#39;,
               &#39;2017-01-01 12:00:00.000002&#39;, &#39;2017-01-01 12:00:00.000003&#39;,
               &#39;2017-01-01 12:00:00.000004&#39;, &#39;2017-01-01 12:00:00.000005&#39;,
               &#39;2017-01-01 12:00:00.000006&#39;, &#39;2017-01-01 12:00:00.000007&#39;,
               &#39;2017-01-01 12:00:00.000008&#39;, &#39;2017-01-01 12:00:00.000009&#39;,
               ...
               &#39;2017-01-01 12:00:09.999991&#39;, &#39;2017-01-01 12:00:09.999992&#39;,
               &#39;2017-01-01 12:00:09.999993&#39;, &#39;2017-01-01 12:00:09.999994&#39;,
               &#39;2017-01-01 12:00:09.999995&#39;, &#39;2017-01-01 12:00:09.999996&#39;,
               &#39;2017-01-01 12:00:09.999997&#39;, &#39;2017-01-01 12:00:09.999998&#39;,
               &#39;2017-01-01 12:00:09.999999&#39;,        &#39;2017-01-01 12:00:10&#39;],
              dtype=&#39;datetime64[ns]&#39;, length=10000001, freq=&#39;U&#39;)
DatetimeIndex([&#39;2017-01-02&#39;, &#39;2017-01-09&#39;, &#39;2017-01-16&#39;, &#39;2017-01-23&#39;,
               &#39;2017-01-30&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=&#39;W-MON&#39;)
DatetimeIndex([&#39;2017-01-09&#39;, &#39;2017-02-13&#39;, &#39;2017-03-13&#39;, &#39;2017-04-10&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;WOM-2MON&#39;)
</code></pre>

<h4 id="toc_44">pd.date_range()-日期范围：频率(2)</h4>

<pre><code class="language-python">print(pd.date_range(&#39;2017&#39;,&#39;2018&#39;, freq = &#39;M&#39;))  
print(pd.date_range(&#39;2017&#39;,&#39;2020&#39;, freq = &#39;Q-DEC&#39;))  
print(pd.date_range(&#39;2017&#39;,&#39;2020&#39;, freq = &#39;A-DEC&#39;)) 
print(&#39;------&#39;)
# M：每月最后一个日历日
# Q-月：指定月为季度末，每个季度末最后一月的最后一个日历日
# A-月：每年指定月份的最后一个日历日
# 月缩写：JAN/FEB/MAR/APR/MAY/JUN/JUL/AUG/SEP/OCT/NOV/DEC
# 所以Q-月只有三种情况：1-4-7-10,2-5-8-11,3-6-9-12

print(pd.date_range(&#39;2017&#39;,&#39;2018&#39;, freq = &#39;BM&#39;))  
print(pd.date_range(&#39;2017&#39;,&#39;2020&#39;, freq = &#39;BQ-DEC&#39;))  
print(pd.date_range(&#39;2017&#39;,&#39;2020&#39;, freq = &#39;BA-DEC&#39;)) 
print(&#39;------&#39;)
# BM：每月最后一个工作日
# BQ-月：指定月为季度末，每个季度末最后一月的最后一个工作日
# BA-月：每年指定月份的最后一个工作日

print(pd.date_range(&#39;2017&#39;,&#39;2018&#39;, freq = &#39;MS&#39;))  
print(pd.date_range(&#39;2017&#39;,&#39;2020&#39;, freq = &#39;QS-DEC&#39;))  
print(pd.date_range(&#39;2017&#39;,&#39;2020&#39;, freq = &#39;AS-DEC&#39;)) 
print(&#39;------&#39;)
# M：每月第一个日历日
# Q-月：指定月为季度末，每个季度末最后一月的第一个日历日
# A-月：每年指定月份的第一个日历日

print(pd.date_range(&#39;2017&#39;,&#39;2018&#39;, freq = &#39;BMS&#39;))  
print(pd.date_range(&#39;2017&#39;,&#39;2020&#39;, freq = &#39;BQS-DEC&#39;))  
print(pd.date_range(&#39;2017&#39;,&#39;2020&#39;, freq = &#39;BAS-DEC&#39;)) 
print(&#39;------&#39;)
# BM：每月第一个工作日
# BQ-月：指定月为季度末，每个季度末最后一月的第一个工作日
# BA-月：每年指定月份的第一个工作日

</code></pre>

<pre><code class="language-text">DatetimeIndex([&#39;2017-01-31&#39;, &#39;2017-02-28&#39;, &#39;2017-03-31&#39;, &#39;2017-04-30&#39;,
               &#39;2017-05-31&#39;, &#39;2017-06-30&#39;, &#39;2017-07-31&#39;, &#39;2017-08-31&#39;,
               &#39;2017-09-30&#39;, &#39;2017-10-31&#39;, &#39;2017-11-30&#39;, &#39;2017-12-31&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=&#39;M&#39;)
DatetimeIndex([&#39;2017-03-31&#39;, &#39;2017-06-30&#39;, &#39;2017-09-30&#39;, &#39;2017-12-31&#39;,
               &#39;2018-03-31&#39;, &#39;2018-06-30&#39;, &#39;2018-09-30&#39;, &#39;2018-12-31&#39;,
               &#39;2019-03-31&#39;, &#39;2019-06-30&#39;, &#39;2019-09-30&#39;, &#39;2019-12-31&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=&#39;Q-DEC&#39;)
DatetimeIndex([&#39;2017-12-31&#39;, &#39;2018-12-31&#39;, &#39;2019-12-31&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;A-DEC&#39;)
------
DatetimeIndex([&#39;2017-01-31&#39;, &#39;2017-02-28&#39;, &#39;2017-03-31&#39;, &#39;2017-04-28&#39;,
               &#39;2017-05-31&#39;, &#39;2017-06-30&#39;, &#39;2017-07-31&#39;, &#39;2017-08-31&#39;,
               &#39;2017-09-29&#39;, &#39;2017-10-31&#39;, &#39;2017-11-30&#39;, &#39;2017-12-29&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=&#39;BM&#39;)
DatetimeIndex([&#39;2017-03-31&#39;, &#39;2017-06-30&#39;, &#39;2017-09-29&#39;, &#39;2017-12-29&#39;,
               &#39;2018-03-30&#39;, &#39;2018-06-29&#39;, &#39;2018-09-28&#39;, &#39;2018-12-31&#39;,
               &#39;2019-03-29&#39;, &#39;2019-06-28&#39;, &#39;2019-09-30&#39;, &#39;2019-12-31&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=&#39;BQ-DEC&#39;)
DatetimeIndex([&#39;2017-12-29&#39;, &#39;2018-12-31&#39;, &#39;2019-12-31&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;BA-DEC&#39;)
------
DatetimeIndex([&#39;2017-01-01&#39;, &#39;2017-02-01&#39;, &#39;2017-03-01&#39;, &#39;2017-04-01&#39;,
               &#39;2017-05-01&#39;, &#39;2017-06-01&#39;, &#39;2017-07-01&#39;, &#39;2017-08-01&#39;,
               &#39;2017-09-01&#39;, &#39;2017-10-01&#39;, &#39;2017-11-01&#39;, &#39;2017-12-01&#39;,
               &#39;2018-01-01&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=&#39;MS&#39;)
DatetimeIndex([&#39;2017-03-01&#39;, &#39;2017-06-01&#39;, &#39;2017-09-01&#39;, &#39;2017-12-01&#39;,
               &#39;2018-03-01&#39;, &#39;2018-06-01&#39;, &#39;2018-09-01&#39;, &#39;2018-12-01&#39;,
               &#39;2019-03-01&#39;, &#39;2019-06-01&#39;, &#39;2019-09-01&#39;, &#39;2019-12-01&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=&#39;QS-DEC&#39;)
DatetimeIndex([&#39;2017-12-01&#39;, &#39;2018-12-01&#39;, &#39;2019-12-01&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;AS-DEC&#39;)
------
DatetimeIndex([&#39;2017-01-02&#39;, &#39;2017-02-01&#39;, &#39;2017-03-01&#39;, &#39;2017-04-03&#39;,
               &#39;2017-05-01&#39;, &#39;2017-06-01&#39;, &#39;2017-07-03&#39;, &#39;2017-08-01&#39;,
               &#39;2017-09-01&#39;, &#39;2017-10-02&#39;, &#39;2017-11-01&#39;, &#39;2017-12-01&#39;,
               &#39;2018-01-01&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=&#39;BMS&#39;)
DatetimeIndex([&#39;2017-03-01&#39;, &#39;2017-06-01&#39;, &#39;2017-09-01&#39;, &#39;2017-12-01&#39;,
               &#39;2018-03-01&#39;, &#39;2018-06-01&#39;, &#39;2018-09-03&#39;, &#39;2018-12-03&#39;,
               &#39;2019-03-01&#39;, &#39;2019-06-03&#39;, &#39;2019-09-02&#39;, &#39;2019-12-02&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=&#39;BQS-DEC&#39;)
DatetimeIndex([&#39;2017-12-01&#39;, &#39;2018-12-03&#39;, &#39;2019-12-02&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;BAS-DEC&#39;)
------
</code></pre>

<h4 id="toc_45">pd.date_range()-日期范围：复合频率</h4>

<pre><code class="language-python">print(pd.date_range(&#39;2017/1/1&#39;,&#39;2017/2/1&#39;, freq = &#39;7D&#39;))  # 7天
print(pd.date_range(&#39;2017/1/1&#39;,&#39;2017/1/2&#39;, freq = &#39;2h30min&#39;))  # 2小时30分钟
print(pd.date_range(&#39;2017&#39;,&#39;2018&#39;, freq = &#39;2M&#39;))  # 2月，每月最后一个日历日

</code></pre>

<pre><code class="language-text">DatetimeIndex([&#39;2017-01-01&#39;, &#39;2017-01-08&#39;, &#39;2017-01-15&#39;, &#39;2017-01-22&#39;,
               &#39;2017-01-29&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=&#39;7D&#39;)
DatetimeIndex([&#39;2017-01-01 00:00:00&#39;, &#39;2017-01-01 02:30:00&#39;,
               &#39;2017-01-01 05:00:00&#39;, &#39;2017-01-01 07:30:00&#39;,
               &#39;2017-01-01 10:00:00&#39;, &#39;2017-01-01 12:30:00&#39;,
               &#39;2017-01-01 15:00:00&#39;, &#39;2017-01-01 17:30:00&#39;,
               &#39;2017-01-01 20:00:00&#39;, &#39;2017-01-01 22:30:00&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=&#39;150T&#39;)
DatetimeIndex([&#39;2017-01-31&#39;, &#39;2017-03-31&#39;, &#39;2017-05-31&#39;, &#39;2017-07-31&#39;,
               &#39;2017-09-30&#39;, &#39;2017-11-30&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=&#39;2M&#39;)
</code></pre>

<h4 id="toc_46">asfreq：时期频率转换</h4>

<pre><code class="language-python">ts = pd.Series(np.random.rand(4),
              index = pd.date_range(&#39;20170101&#39;,&#39;20170104&#39;))
print(ts)
print(ts.asfreq(&#39;4H&#39;,method = &#39;ffill&#39;))
# 改变频率，这里是D改为4H
# method：插值模式，None不插值，ffill用之前值填充，bfill用之后值填充

</code></pre>

<pre><code class="language-text">2017-01-01    0.380807
2017-01-02    0.082508
2017-01-03    0.989844
2017-01-04    0.946656
Freq: D, dtype: float64
2017-01-01 00:00:00    0.380807
2017-01-01 04:00:00    0.380807
2017-01-01 08:00:00    0.380807
2017-01-01 12:00:00    0.380807
2017-01-01 16:00:00    0.380807
2017-01-01 20:00:00    0.380807
2017-01-02 00:00:00    0.082508
2017-01-02 04:00:00    0.082508
2017-01-02 08:00:00    0.082508
2017-01-02 12:00:00    0.082508
2017-01-02 16:00:00    0.082508
2017-01-02 20:00:00    0.082508
2017-01-03 00:00:00    0.989844
2017-01-03 04:00:00    0.989844
2017-01-03 08:00:00    0.989844
2017-01-03 12:00:00    0.989844
2017-01-03 16:00:00    0.989844
2017-01-03 20:00:00    0.989844
2017-01-04 00:00:00    0.946656
Freq: 4H, dtype: float64
</code></pre>

<h4 id="toc_47">pd.date_range()-日期范围：超前/滞后数据</h4>

<pre><code class="language-python">ts = pd.Series(np.random.rand(4),
              index = pd.date_range(&#39;20170101&#39;,&#39;20170104&#39;))
print(ts)

print(ts.shift(2))
print(ts.shift(-2))
print(&#39;------&#39;)
# 正数：数值后移（滞后）；负数：数值前移（超前）

per = ts/ts.shift(1) - 1
print(per)
print(&#39;------&#39;)
# 计算变化百分比，这里计算：该时间戳与上一个时间戳相比，变化百分比

print(ts.shift(2, freq = &#39;D&#39;))
print(ts.shift(2, freq = &#39;T&#39;))
# 加上freq参数：对时间戳进行位移，而不是对数值进行位移

</code></pre>

<pre><code class="language-text">2017-01-01    0.887591
2017-01-02    0.220969
2017-01-03    0.397006
2017-01-04    0.392343
Freq: D, dtype: float64
2017-01-01         NaN
2017-01-02         NaN
2017-01-03    0.887591
2017-01-04    0.220969
Freq: D, dtype: float64
2017-01-01    0.397006
2017-01-02    0.392343
2017-01-03         NaN
2017-01-04         NaN
Freq: D, dtype: float64
------
2017-01-01         NaN
2017-01-02   -0.751046
2017-01-03    0.796660
2017-01-04   -0.011747
Freq: D, dtype: float64
------
2017-01-03    0.887591
2017-01-04    0.220969
2017-01-05    0.397006
2017-01-06    0.392343
Freq: D, dtype: float64
2017-01-01 00:02:00    0.887591
2017-01-02 00:02:00    0.220969
2017-01-03 00:02:00    0.397006
2017-01-04 00:02:00    0.392343
Freq: D, dtype: float64
</code></pre>

<h3 id="toc_48">Period（Pandas时期）</h3>

<h4 id="toc_49">pd.Period()创建时期</h4>

<pre><code class="language-python">p = pd.Period(&#39;2017&#39;, freq = &#39;M&#39;)
print(p, type(p))
# 生成一个以2017-01开始，月为频率的时间构造器
# pd.Period()参数：一个时间戳 + freq 参数 → freq 用于指明该 period 的长度，时间戳则说明该 period 在时间轴上的位置

print(p + 1)
print(p - 2)
print(pd.Period(&#39;2012&#39;, freq = &#39;A-DEC&#39;) - 1)
# 通过加减整数，将周期整体移动
# 这里是按照 月、年 移动

</code></pre>

<pre><code class="language-text">2017-01 &lt;class &#39;pandas._libs.tslibs.period.Period&#39;&gt;
2017-02
2016-11
2011
</code></pre>

<h4 id="toc_50">pd.period_range()创建时期范围</h4>

<pre><code class="language-python">prng = pd.period_range(&#39;1/1/2011&#39;, &#39;1/1/2012&#39;, freq=&#39;M&#39;)
print(prng,type(prng))
print(prng[0],type(prng[0]))
# 数据格式为PeriodIndex，单个数值为Period

ts = pd.Series(np.random.rand(len(prng)), index = prng)
print(ts,type(ts))
print(ts.index)

</code></pre>

<pre><code class="language-text">PeriodIndex([&#39;2011-01&#39;, &#39;2011-02&#39;, &#39;2011-03&#39;, &#39;2011-04&#39;, &#39;2011-05&#39;, &#39;2011-06&#39;,
             &#39;2011-07&#39;, &#39;2011-08&#39;, &#39;2011-09&#39;, &#39;2011-10&#39;, &#39;2011-11&#39;, &#39;2011-12&#39;,
             &#39;2012-01&#39;],
            dtype=&#39;period[M]&#39;, freq=&#39;M&#39;) &lt;class &#39;pandas.core.indexes.period.PeriodIndex&#39;&gt;
2011-01 &lt;class &#39;pandas._libs.tslibs.period.Period&#39;&gt;
2011-01    0.824645
2011-02    0.903224
2011-03    0.531356
2011-04    0.232478
2011-05    0.410850
2011-06    0.604149
2011-07    0.680435
2011-08    0.039116
2011-09    0.600320
2011-10    0.503596
2011-11    0.995603
2011-12    0.810485
2012-01    0.985762
Freq: M, dtype: float64 &lt;class &#39;pandas.core.series.Series&#39;&gt;
PeriodIndex([&#39;2011-01&#39;, &#39;2011-02&#39;, &#39;2011-03&#39;, &#39;2011-04&#39;, &#39;2011-05&#39;, &#39;2011-06&#39;,
             &#39;2011-07&#39;, &#39;2011-08&#39;, &#39;2011-09&#39;, &#39;2011-10&#39;, &#39;2011-11&#39;, &#39;2011-12&#39;,
             &#39;2012-01&#39;],
            dtype=&#39;period[M]&#39;, freq=&#39;M&#39;)
</code></pre>

<p><strong>时间序列</strong></p>

<ul>
<li><p>Period(&#39;2011&#39;, freq = &#39;A-DEC&#39;)可以看成多个时间期的时间段中的游标</p></li>
<li><p>Timestamp表示一个时间戳，是一个时间截面；Period是一个时期，是一个时间段！！但两者作为index时区别不大</p></li>
</ul>

<h4 id="toc_51">asfreq：频率转换</h4>

<pre><code class="language-python">p = pd.Period(&#39;2017&#39;,&#39;A-DEC&#39;)
print(p)
print(p.asfreq(&#39;M&#39;, how = &#39;start&#39;))  # 也可写 how = &#39;s&#39;
print(p.asfreq(&#39;D&#39;, how = &#39;end&#39;))  # 也可写 how = &#39;e&#39;
# 通过.asfreq(freq, method=None, how=None)方法转换成别的频率

prng = pd.period_range(&#39;2017&#39;,&#39;2018&#39;,freq = &#39;M&#39;)
ts1 = pd.Series(np.random.rand(len(prng)), index = prng)
ts2 = pd.Series(np.random.rand(len(prng)), index = prng.asfreq(&#39;D&#39;, how = &#39;start&#39;))
print(ts1.head(),len(ts1))
print(ts2.head(),len(ts2))
# asfreq也可以转换TIMESeries的index

</code></pre>

<pre><code class="language-text">2017
2017-01
2017-12-31
2017-01    0.803362
2017-02    0.680803
2017-03    0.503056
2017-04    0.885740
2017-05    0.983818
Freq: M, dtype: float64 13
2017-01-01    0.544769
2017-02-01    0.378608
2017-03-01    0.119503
2017-04-01    0.238595
2017-05-01    0.497255
Freq: D, dtype: float64 13
</code></pre>

<h4 id="toc_52">时间戳与时期之间的转换</h4>

<pre><code class="language-python">rng = pd.date_range(&#39;2017/1/1&#39;, periods = 10, freq = &#39;M&#39;)
prng = pd.period_range(&#39;2017&#39;,&#39;2018&#39;, freq = &#39;M&#39;)

ts1 = pd.Series(np.random.rand(len(rng)), index = rng)
print(ts1.head())
print(ts1.to_period().head())
# 每月最后一日，转化为每月

ts2 = pd.Series(np.random.rand(len(prng)), index = prng)
print(ts2.head())
print(ts2.to_timestamp().head())
# 每月，转化为每月第一天

</code></pre>

<pre><code class="language-text">2017-01-31    0.867821
2017-02-28    0.543612
2017-03-31    0.893282
2017-04-30    0.809654
2017-05-31    0.464549
Freq: M, dtype: float64
2017-01    0.867821
2017-02    0.543612
2017-03    0.893282
2017-04    0.809654
2017-05    0.464549
Freq: M, dtype: float64
2017-01    0.731718
2017-02    0.517833
2017-03    0.473853
2017-04    0.009430
2017-05    0.998953
Freq: M, dtype: float64
2017-01-01    0.731718
2017-02-01    0.517833
2017-03-01    0.473853
2017-04-01    0.009430
2017-05-01    0.998953
Freq: MS, dtype: float64
</code></pre>

<h3 id="toc_53">时间序列 - 索引及切片</h3>

<p>TimeSeries是Series的一个子类，所以Series索引及数据选取方面的方法基本一样</p>

<p>同时TimeSeries通过时间序列有更便捷的方法做索引和切片</p>

<h4 id="toc_54">索引</h4>

<pre><code class="language-python">from datetime import datetime

rng = pd.date_range(&#39;2017/1&#39;,&#39;2017/3&#39;)
ts = pd.Series(np.random.rand(len(rng)), index = rng)
print(ts.head())

print(ts[0])
print(ts[:2])
print(&#39;-----&#39;)
# 基本下标位置索引

print(ts[&#39;2017/1/2&#39;])
print(ts[&#39;20170103&#39;])
print(ts[&#39;1/10/2017&#39;])
print(ts[datetime(2017,1,20)])
print(&#39;-----&#39;)
# 时间序列标签索引，支持各种时间字符串，以及datetime.datetime

# 时间序列由于按照时间先后排序，故不用考虑顺序问题
# 索引方法同样适用于Dataframe

</code></pre>

<pre><code class="language-text">2017-01-01    0.790453
2017-01-02    0.252198
2017-01-03    0.360769
2017-01-04    0.525272
2017-01-05    0.452863
Freq: D, dtype: float64
0.7904527728537566
2017-01-01    0.790453
2017-01-02    0.252198
Freq: D, dtype: float64
-----
0.25219772923312767
0.3607686710038176
0.6528232574813878
0.352811458536781
-----
</code></pre>

<h4 id="toc_55">切片</h4>

<pre><code class="language-python">rng = pd.date_range(&#39;2017/1&#39;,&#39;2017/3&#39;,freq = &#39;12H&#39;)
ts = pd.Series(np.random.rand(len(rng)), index = rng)

print(ts[&#39;2017/1/5&#39;:&#39;2017/1/10&#39;])
print(&#39;-----&#39;)
# 和Series按照index索引原理一样，也是末端包含

print(ts[&#39;2017/2&#39;].head())
# 传入月，直接得到一个切片

</code></pre>

<pre><code class="language-text">2017-01-05 00:00:00    0.042829
2017-01-05 12:00:00    0.441050
2017-01-06 00:00:00    0.400631
2017-01-06 12:00:00    0.026122
2017-01-07 00:00:00    0.493281
2017-01-07 12:00:00    0.559460
2017-01-08 00:00:00    0.673397
2017-01-08 12:00:00    0.682465
2017-01-09 00:00:00    0.160642
2017-01-09 12:00:00    0.048712
2017-01-10 00:00:00    0.668822
2017-01-10 12:00:00    0.734941
Freq: 12H, dtype: float64
-----
2017-02-01 00:00:00    0.528840
2017-02-01 12:00:00    0.692276
2017-02-02 00:00:00    0.812610
2017-02-02 12:00:00    0.620347
2017-02-03 00:00:00    0.877217
Freq: 12H, dtype: float64
</code></pre>

<h4 id="toc_56">重复索引的时间序列</h4>

<pre><code class="language-python">dates = pd.DatetimeIndex([&#39;1/1/2015&#39;,&#39;1/2/2015&#39;,&#39;1/3/2015&#39;,&#39;1/4/2015&#39;,&#39;1/1/2015&#39;,&#39;1/2/2015&#39;])
ts = pd.Series(np.random.rand(6), index = dates)
print(ts)
print(ts.is_unique,ts.index.is_unique)
print(&#39;-----&#39;)
# index有重复，is_unique检查 → values唯一，index不唯一

print(ts[&#39;20150101&#39;],type(ts[&#39;20150101&#39;]))
print(ts[&#39;20150104&#39;],type(ts[&#39;20150104&#39;]))
print(&#39;-----&#39;)
# index有重复的将返回多个值

print(ts.groupby(level = 0).mean())
# 通过groupby做分组，重复的值这里用平均值处理

</code></pre>

<pre><code class="language-text">2015-01-01    0.987115
2015-01-02    0.331198
2015-01-03    0.900640
2015-01-04    0.906425
2015-01-01    0.090501
2015-01-02    0.841942
dtype: float64
True False
-----
2015-01-01    0.987115
2015-01-01    0.090501
dtype: float64 &lt;class &#39;pandas.core.series.Series&#39;&gt;
2015-01-04    0.906425
dtype: float64 &lt;class &#39;pandas.core.series.Series&#39;&gt;
-----
2015-01-01    0.538808
2015-01-02    0.586570
2015-01-03    0.900640
2015-01-04    0.906425
dtype: float64
</code></pre>

<h3 id="toc_57">时间序列 - 重采样</h3>

<p>将时间序列从一个频率转换为另一个频率的过程，且会有数据的结合</p>

<ul>
<li><p>降采样：高频数据 → 低频数据，eg.以天为频率的数据转为以月为频率的数据</p></li>
<li><p>升采样：低频数据 → 高频数据，eg.以年为频率的数据转为以月为频率的数据</p></li>
</ul>

<h4 id="toc_58">重采样：.resample()</h4>

<pre><code class="language-python"># 创建一个以天为频率的TimeSeries，重采样为按2天为频率

rng = pd.date_range(&#39;20170101&#39;, periods = 12)
ts = pd.Series(np.arange(12), index = rng)
print(ts)

ts_re = ts.resample(&#39;5D&#39;)
ts_re2 = ts.resample(&#39;5D&#39;).sum()
print(ts_re, type(ts_re))
print(ts_re2, type(ts_re2))
print(&#39;-----&#39;)
# ts.resample(&#39;5D&#39;)：得到一个重采样构建器，频率改为5天
# ts.resample(&#39;5D&#39;).sum():得到一个新的聚合后的Series，聚合方式为求和
# freq：重采样频率 → ts.resample(&#39;5D&#39;)
# .sum()：聚合方法

print(ts.resample(&#39;5D&#39;).mean(),&#39;→ 求平均值\n&#39;)
print(ts.resample(&#39;5D&#39;).max(),&#39;→ 求最大值\n&#39;)
print(ts.resample(&#39;5D&#39;).min(),&#39;→ 求最小值\n&#39;)
print(ts.resample(&#39;5D&#39;).median(),&#39;→ 求中值\n&#39;)
print(ts.resample(&#39;5D&#39;).first(),&#39;→ 返回第一个值\n&#39;)
print(ts.resample(&#39;5D&#39;).last(),&#39;→ 返回最后一个值\n&#39;)
print(ts.resample(&#39;5D&#39;).ohlc(),&#39;→ OHLC重采样\n&#39;)
# OHLC:金融领域的时间序列聚合方式 → open开盘、high最大值、low最小值、close收盘

</code></pre>

<pre><code class="language-text">2017-01-01     0
2017-01-02     1
2017-01-03     2
2017-01-04     3
2017-01-05     4
2017-01-06     5
2017-01-07     6
2017-01-08     7
2017-01-09     8
2017-01-10     9
2017-01-11    10
2017-01-12    11
Freq: D, dtype: int32
DatetimeIndexResampler [freq=&lt;5 * Days&gt;, axis=0, closed=left, label=left, convention=start, base=0] &lt;class &#39;pandas.core.resample.DatetimeIndexResampler&#39;&gt;
2017-01-01    10
2017-01-06    35
2017-01-11    21
dtype: int32 &lt;class &#39;pandas.core.series.Series&#39;&gt;
-----
2017-01-01     2.0
2017-01-06     7.0
2017-01-11    10.5
dtype: float64 → 求平均值

2017-01-01     4
2017-01-06     9
2017-01-11    11
dtype: int32 → 求最大值

2017-01-01     0
2017-01-06     5
2017-01-11    10
dtype: int32 → 求最小值

2017-01-01     2.0
2017-01-06     7.0
2017-01-11    10.5
dtype: float64 → 求中值

2017-01-01     0
2017-01-06     5
2017-01-11    10
dtype: int32 → 返回第一个值

2017-01-01     4
2017-01-06     9
2017-01-11    11
dtype: int32 → 返回最后一个值

            open  high  low  close
2017-01-01     0     4    0      4
2017-01-06     5     9    5      9
2017-01-11    10    11   10     11 → OHLC重采样
</code></pre>

<p>​    </p>

<h4 id="toc_59">降采样</h4>

<pre><code class="language-python">rng = pd.date_range(&#39;20170101&#39;, periods = 12)
ts = pd.Series(np.arange(1,13), index = rng)
print(ts)

print(ts.resample(&#39;5D&#39;).sum(),&#39;→ 默认\n&#39;)
print(ts.resample(&#39;5D&#39;, closed = &#39;left&#39;).sum(),&#39;→ left\n&#39;)
print(ts.resample(&#39;5D&#39;, closed = &#39;right&#39;).sum(),&#39;→ right\n&#39;)
print(&#39;-----&#39;)
# closed：各时间段哪一端是闭合（即包含）的，默认 左闭右闭
# 详解：这里values为0-11，按照5D重采样 → [1,2,3,4,5],[6,7,8,9,10],[11,12]
# left指定间隔左边为结束 → [1,2,3,4,5],[6,7,8,9,10],[11,12]
# right指定间隔右边为结束 → [1],[2,3,4,5,6],[7,8,9,10,11],[12]

print(ts.resample(&#39;5D&#39;, label = &#39;left&#39;).sum(),&#39;→ leftlabel\n&#39;)
print(ts.resample(&#39;5D&#39;, label = &#39;right&#39;).sum(),&#39;→ rightlabel\n&#39;)
# label：聚合值的index，默认为取左
# 值采样认为默认（这里closed默认）

</code></pre>

<pre><code class="language-text">2017-01-01     1
2017-01-02     2
2017-01-03     3
2017-01-04     4
2017-01-05     5
2017-01-06     6
2017-01-07     7
2017-01-08     8
2017-01-09     9
2017-01-10    10
2017-01-11    11
2017-01-12    12
Freq: D, dtype: int32
2017-01-01    15
2017-01-06    40
2017-01-11    23
dtype: int32 → 默认

2017-01-01    15
2017-01-06    40
2017-01-11    23
dtype: int32 → left

2016-12-27     1
2017-01-01    20
2017-01-06    45
2017-01-11    12
dtype: int32 → right

-----
2017-01-01    15
2017-01-06    40
2017-01-11    23
dtype: int32 → leftlabel

2017-01-06    15
2017-01-11    40
2017-01-16    23
dtype: int32 → rightlabel
</code></pre>

<p>​    </p>

<h4 id="toc_60">升采样及插值</h4>

<pre><code class="language-python">rng = pd.date_range(&#39;2017/1/1 0:0:0&#39;, periods = 5, freq = &#39;H&#39;)
ts = pd.DataFrame(np.arange(15).reshape(5,3),
                  index = rng,
                  columns = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;])
print(ts)

print(ts.resample(&#39;15T&#39;).asfreq())
print(ts.resample(&#39;15T&#39;).ffill())
print(ts.resample(&#39;15T&#39;).bfill())
# 低频转高频，主要是如何插值
# .asfreq()：不做填充，返回Nan
# .ffill()：向上填充
# .bfill()：向下填充

</code></pre>

<pre><code class="language-text">                      a   b   c
2017-01-01 00:00:00   0   1   2
2017-01-01 01:00:00   3   4   5
2017-01-01 02:00:00   6   7   8
2017-01-01 03:00:00   9  10  11
2017-01-01 04:00:00  12  13  14
                        a     b     c
2017-01-01 00:00:00   0.0   1.0   2.0
2017-01-01 00:15:00   NaN   NaN   NaN
2017-01-01 00:30:00   NaN   NaN   NaN
2017-01-01 00:45:00   NaN   NaN   NaN
2017-01-01 01:00:00   3.0   4.0   5.0
2017-01-01 01:15:00   NaN   NaN   NaN
2017-01-01 01:30:00   NaN   NaN   NaN
2017-01-01 01:45:00   NaN   NaN   NaN
2017-01-01 02:00:00   6.0   7.0   8.0
2017-01-01 02:15:00   NaN   NaN   NaN
2017-01-01 02:30:00   NaN   NaN   NaN
2017-01-01 02:45:00   NaN   NaN   NaN
2017-01-01 03:00:00   9.0  10.0  11.0
2017-01-01 03:15:00   NaN   NaN   NaN
2017-01-01 03:30:00   NaN   NaN   NaN
2017-01-01 03:45:00   NaN   NaN   NaN
2017-01-01 04:00:00  12.0  13.0  14.0
                      a   b   c
2017-01-01 00:00:00   0   1   2
2017-01-01 00:15:00   0   1   2
2017-01-01 00:30:00   0   1   2
2017-01-01 00:45:00   0   1   2
2017-01-01 01:00:00   3   4   5
2017-01-01 01:15:00   3   4   5
2017-01-01 01:30:00   3   4   5
2017-01-01 01:45:00   3   4   5
2017-01-01 02:00:00   6   7   8
2017-01-01 02:15:00   6   7   8
2017-01-01 02:30:00   6   7   8
2017-01-01 02:45:00   6   7   8
2017-01-01 03:00:00   9  10  11
2017-01-01 03:15:00   9  10  11
2017-01-01 03:30:00   9  10  11
2017-01-01 03:45:00   9  10  11
2017-01-01 04:00:00  12  13  14
                      a   b   c
2017-01-01 00:00:00   0   1   2
2017-01-01 00:15:00   3   4   5
2017-01-01 00:30:00   3   4   5
2017-01-01 00:45:00   3   4   5
2017-01-01 01:00:00   3   4   5
2017-01-01 01:15:00   6   7   8
2017-01-01 01:30:00   6   7   8
2017-01-01 01:45:00   6   7   8
2017-01-01 02:00:00   6   7   8
2017-01-01 02:15:00   9  10  11
2017-01-01 02:30:00   9  10  11
2017-01-01 02:45:00   9  10  11
2017-01-01 03:00:00   9  10  11
2017-01-01 03:15:00  12  13  14
2017-01-01 03:30:00  12  13  14
2017-01-01 03:45:00  12  13  14
2017-01-01 04:00:00  12  13  14
</code></pre>

<h4 id="toc_61">时期重采样 - Period</h4>

<pre><code class="language-python">prng = pd.period_range(&#39;2016&#39;,&#39;2017&#39;,freq = &#39;M&#39;)
ts = pd.Series(np.arange(len(prng)), index = prng)
print(ts)

#print(ts.resample(&#39;3M&#39;).sum())  
# 降采样
print(ts.resample(&#39;15D&#39;).ffill())  # 升采样

</code></pre>

<pre><code class="language-text">2016-01     0
2016-02     1
2016-03     2
2016-04     3
2016-05     4
2016-06     5
2016-07     6
2016-08     7
2016-09     8
2016-10     9
2016-11    10
2016-12    11
2017-01    12
Freq: M, dtype: int32
2016-01-01     0
2016-01-16     0
2016-01-31     0
2016-02-15     1
2016-03-01     2
2016-03-16     2
2016-03-31     2
2016-04-15     3
2016-04-30     3
2016-05-15     4
2016-05-30     4
2016-06-14     5
2016-06-29     5
2016-07-14     6
2016-07-29     6
2016-08-13     7
2016-08-28     7
2016-09-12     8
2016-09-27     8
2016-10-12     9
2016-10-27     9
2016-11-11    10
2016-11-26    10
2016-12-11    11
2016-12-26    11
2017-01-10    12
2017-01-25    12
Freq: 15D, dtype: int3gou
</code></pre>

]]></content>
  </entry>
  
</feed>
